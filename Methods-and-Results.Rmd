---
output: latex_fragment
editor_options:
  chunk_output_type: console
bibliography: references.bib
csl: apa.csl
---

```{r setup, include=FALSE}
# R Studio Clean-Up
cat("\014") # clear console
# rm(list=ls()) # clear workspace - use restart R instead [cmd/alt + shift + F10]
gc() # garbage collector

# Install and Load Packages
# !IMPORTANT!
# BEFORE FIRST RENDER:
# To install all relevant packages please run "renv::restore()" (or renv::init() and then initiate from lockfile) in the console before the first use to ensure that all packages are using the correct version.
# to store the packages in a contained library within the project folder: renv::settings$use.cache(FALSE) and add 'RENV_CONFIG_SANDBOX_ENABLED = FALSE' to an '.Renviron' file
lib <- c(
  "rmarkdown",
  "knitr",
  "remedy",
  "bookdown",
  "brms",
  "psych",
  "ggplot2",
  "ggthemes",
  "purrr",
  "haven",
  "RColorBrewer",
  "plotly",
  "gridExtra",
  "ggpattern",
  "lme4",
  "nlme",
  "jtools",
  "gtsummary",
  "sessioninfo",
  "tibble",
  "pander",
  "devtools",
  "mada",
  "data.table",
  "plyr",
  "dplyr",
  "tidyr",
  "Hmisc",
  "kableExtra",
  "papaja",
  "stringr",
  "stringi",
  "reshape2",
  "lubridate",
  "misty"
)
invisible(lapply(lib, library, character.only = TRUE))
rm(lib)

# Load Custom Packages
source("./scripts/functions/fun.panel.R")
source("./scripts/functions/themes.R")
source("./scripts/functions/binaryCor.R")
source("./scripts/functions/MlCorMat.R")

# Markdown Options
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # set working directory
knitr::opts_knit$get("root.dir") # check working directory
options(
  scipen = 999,
  digits = 4,
  width = 400
) # removes scientific quotation
# knitr::opts_chunk$set(echo = TRUE, cache = F, cache.path = rprojroot::find_rstudio_root_file('cache/')) # cache settings

# Global Chunk Options
knitr::opts_chunk$set(
  fig.width = 12,
  fig.height = 8,
  fig.path = "Figures/",
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)
```

```{r import, include=FALSE}
load("data/wrangled.RData")
```

\faQuestionCircle\ Unsure about order of study one and two. Currently chronological. But could also be: (1) main model works in larger student sample, (2) works in economic migrant sample, (3) test full thing in medical sample.

\section{Study 1}

Based on our main hypotheses, the aim of our first study is to specifically test the general contact hypothesis, the influence of core need fulfillment, and perceived interaction quality during intergroup contacts. To this aim, we conducted an intensive longitudinal survey study with recent migrants to the Netherlands, gathering a large body of ecologically valid data on need satisfaction in real-life intergroup contact situations. Data was collected from May 5th through June 6th, 2018 (and all participants started the study within the first two days).

The full surveys are available in our Online Supplementary Material A and the full data description is available in Online Supplementary Materials B. Correlations and descriptive statistics of the included variables are available in Table \ref{tab:workerVarDescr} and Table \ref{tab:workerOutVarDescr}.

\subsection{Methods}

```{r workerSampleInfo, include=FALSE}
# combine education measure
workerOccupation <- 
  dtWorker$clean %>%
  select(PID, starts_with("occupation")) %>%
  mutate_all(as_factor) %>% 
  mutate_all(as.character) %>%
  replace(is.na(.), "") %>%
  unite("occupation", -PID, sep = "/") %>%
  mutate(occupation = trimws(occupation, which = "both", whitespace = "[/]")) %>%
  distinct

# summarize participant characteristics
workerSampleInfo <- 
  dtWorker$clean %>%
  group_by(PID) %>%
  summarise(
    dailiesN = n(), 
    morningN = sum(daytime=="morning"),
    afternoonN = sum(daytime=="afternoon"),
    age = age,
    gender = as_factor(Gender),
    edu = as_factor(education_level),
    nationality = as_factor(nationality)
  ) %>%
  distinct

# add occupation variable
workerSampleInfo <- merge(workerSampleInfo, workerOccupation)
rm(workerOccupation)

# look at frequencies of characteristics 
table(workerSampleInfo$gender)
table(workerSampleInfo$edu)
table(workerSampleInfo$occupation)
table(as.character(workerSampleInfo$nationality))

# categorical variables:
# - outgroup contact
# - non-outgroup contact

# continuous variables:
# - Core Need fulfillment
# - SDT Competence
# - SDT Autonomy
# - SDT Relatedness
# - Interaction Quality
# - Outgroup Attitudes
######
# within cor
# between cor
# ---
# Grand mean
# SD between
# SD within
# Proportion of variance
# __ __ __
# Note:
# N within ppt.s 
######

# divide into trait and state
dtWorkerSupp$workerWithinBetween <-
  MlTraitState(
    data = dtWorkerSupp$workerInteractionType,
    id = "PID",
    selection =
      c(
        "keyMotiveFulfilled",
        "competence.daily.all",
        "autonomy.daily.all",
        "relatedness.daily.all",
        "thermometerDutch_1",
        "keymotive_fulfillemt_1",
        "competence_1",
        "autonomy_1",
        "relatedness_1", 
        "quality_overall_1"
      )
  )
dtWorkerSupp$workerOutWithinBetween <-
  MlTraitState(
    data = dtWorkerSupp$workerInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection =
      c(
        "keyMotiveFulfilled",
        "thermometerDutch_1",
        "keymotive_fulfillemt_1",
        "competence_1",
        "autonomy_1",
        "relatedness_1", 
        "quality_overall_1"
      )
  )
```

```{r workerVarDescr, include=FALSE}
workerMlCor <-
  MlCorMat(
    data = dtWorkerSupp$workerInteractionType,
    id = "PID",
    selection = c("keyMotiveFulfilled", "competence.daily.all", "autonomy.daily.all", "relatedness.daily.all", "thermometerDutch_1") ,
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Attitudes NL")
  ) 

workerMlCor %>%
  kable(
    .,
    caption = "Worker: Multilevel Core Variable Descriptives",
    format = "latex",
    booktabs = TRUE,
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person coorelations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/workerVarDescr.tex")
```

```{r workerOutVarDescr, include=FALSE}
workerOutMlCor <-
  MlCorMat(
    data = dtWorkerSupp$workerInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection = c("keymotive_fulfillemt_1", "competence_1", "autonomy_1", "relatedness_1", "thermometerDutch_1") ,
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Attitudes NL")
  )

workerOutMlCor %>%
  kable(
    .,
    caption = "Worker: Multilevel Core Variable Descriptives (Outgroup Contact Only)",
    format = "latex",
    booktabs = TRUE,
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person coorelations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/workerOutVarDescr.tex")

# misty::multilevel.descript(dtWorkerSupp$workerWithinBetween$keyMotiveFulfilled, cluster = dtWorkerSupp$workerWithinBetween$PID)
```


\subsubsection{Participants} After receiving ethical approval from the University of Groningen, we recruited `r nrow(workerSampleInfo)` migrants using the local paid participant pool and specifically targeted non-Dutch migrants to participate in our study. Participants reported on their interactions for at least 30 days with two daily measures (capturing the morning and afternoon). With this design, we aimed at getting 50-60 measurements per participant (\textit{M} = `r format(round(mean(workerSampleInfo$dailiesN),2), nsmall=2)`, \textit{M} = `r format(round(sd(workerSampleInfo$dailiesN),2), nsmall=2)`, \textit{total N} = `r sum(workerSampleInfo$dailiesN)`). This is a common number of measurements found in experience sampling studies and should offer sufficient power to model processes within and between participants \citep[e.g., for a systematic review see][]{AanhetRot2012}. Participants were compensated for their participation with up to 34 Euros – each two Euros for pre- and post-questionnaire as well as 50 Eurocents for every experience sampling measurement occasion. The sample consisted of relatively young, educated, and western migrants from the global north ($M_{age}$ = `r format(round(mean(workerSampleInfo$age),2), nsmall=2)`, $SD_{age}$ = `r format(round(sd(workerSampleInfo$age),2), nsmall=2)`, `r nrow(workerSampleInfo %>% filter(gender == "Female"))` women, `r nrow(workerSampleInfo %>% filter(occupation == "student"))` students). The sample accurately describes one of the largest groups of migrants in the region \citep[][]{GemeenteGroningen2015}.

\subsubsection{Procedure} The study itself consisted of three main parts, an introductory pre-measurement, and the daily experience sampling measurements, as well as a concluding post-measurement. After giving informed consent, participants started by filling in an online pre-questionnaire assessing demographics and general information about their immigration. Over the next thirty days, the participants then were invited twice a day (at 12 pm and 7pm) to reflect upon their interactions, psychological need fulfillments, and current attitudes towards the Dutch outgroup (\textit{median duration} = `r seconds_to_period(median(dtWorker$clean$Duration__in_seconds_))`, \textit{MAD duration} = `r seconds_to_period(round(mad(dtWorker$clean$Duration__in_seconds_)))`).  General compliance was high (`r format(round(sum(workerSampleInfo$dailiesN)/(nrow(workerSampleInfo)*62)*100,2), nsmall=2)`\% of all invited surveys were filled in)\footnote{Two participants completed only two days (among the others, participation was `r format(round(sum(workerSampleInfo$dailiesN[workerSampleInfo$dailiesN>3])/(nrow(workerSampleInfo[workerSampleInfo$dailiesN>3,])*62)*100,2), nsmall=2)`\%)}. The response rates were approximately equal during mornings (\textit{n} = `r sum(workerSampleInfo$morningN)`) and afternoons (\textit{n} = `r sum(workerSampleInfo$afternoonN)`) and most measurements were completed within four hours of the invitation. After the final day of daily diary measurements, participants were invited to fill in a longer post measurement survey that mirrored the pre-measurement. All key variables in for this study were part of the short daily diary surveys. 

\subsubsection{Materials}

\paragraph{Intergroup Contact}To test the prerequisite effect of intergroup contact, every experience sampling measurement started with the question “\textit{Did you meet a Dutch person this morning [/afternoon]? (In person interaction for at least 10 minutes)}”. Our participants recorded between `r dtWorkerSupp$workerAvFreQual$SumContactNL[dtWorkerSupp$workerAvFreQual$SumContactNL > 0] %>% min`--`r dtWorkerSupp$workerAvFreQual$SumContactNL[dtWorkerSupp$workerAvFreQual$SumContactNL > 0] %>% max`
(`r dtWorkerSupp$workerAvFreQual$PercContactNL[dtWorkerSupp$workerAvFreQual$PercContactNL > 0] %>% min %>% round(2) %>% format(nsmall=2)`--`r dtWorkerSupp$workerAvFreQual$PercContactNL[dtWorkerSupp$workerAvFreQual$PercContactNL > 0] %>% max %>% round(2) %>% format(nsmall=2)`\% of individual daily diary measurements; `r (sum(dtWorkerSupp$workerAvFreQual$SumContactNL) / nrow(dtWorkerSupp$workerInteractionType) * 100) %>% round(2) %>% format(nsmall=2)`\% of all `r nrow(dtWorkerSupp$workerInteractionType)` daily diary responses)\footnote{Two participants only recorded two daily diary measurements each and non of these included outgroup contacts. These participants are removed from any analyses including outgroup contacts.}.

\paragraph{Psychological Needs}Irrespective of whether participants had an interaction with Dutch people or not, everyone answered a short series of questions on psychological need fulfillment. However, whereas participants with interactions reported on the need fulfillment during the interaction, people without interactions with Dutch people judged the past daytime period in general. To assess the fulfillment of psychological needs, we included two types of need measurement: (1) the core situational need and (2) general self-determination theory needs.

For the core situational need, we asked participants in an open ended text field: “\textit{What was your most important goal [during the interaction / this morning / this afternoon]?}”. Then, with reference to the text entry, we asked how much this core need was fulfilled during the interaction or the past daytime period: “\textit{[The interaction / you] fulfilled your goal: [-previous text entry-]}” on a continuous slider scale ranging from strongly disagree (-50) to strongly agree (+50).

We, additionally, included a common measure of three self-determination theory needs \citep[see][]{Downie2008}. The items were introduced either by “\textit{During the interaction:}” or “\textit{This morning [/afternoon]:}” and measured autonomy (“\textit{I was myself.}”), competence (“\textit{I felt competent.}”), and relatedness (without intergroup contact “\textit{I had a strong need to belong}”; with intergroup contact: “\textit{I shared information about myself.}” and “\textit{The other(s) shared information about themselves.}”). All items were rated on a continuous slider scale from very little (-50) to a great deal (+50).

\paragraph{Perceived Interaction Quality}As an explanatory mechanism, we assessed ratings of the perceived interaction quality. As our main measurement, participants rated the statement “\textit{Overall the interaction was …}” on two continuous slider scales measuring pleasantness \citep[from unpleasant (-50) to pleasant (+50)) and meaningfulness (from superficial (-50) to meaningful (+50); both items adapted from][]{Downie2008}.

\paragraph{Outgroup Attitudes}At the end of every daily diary measurement we asked all participants about their current attitudes towards the Dutch – our main dependent variable. To assess the momentary outgroup evaluation we used the common feeling thermometer: “How favorable do you feel towards the Dutch?” \citep[][]{Lavrakas2008}. Participants then rated their attitude on a continuous slider scale from “very cold – 0” through “no feeling – 50” to “very warm – 100”. Both the question phrasing as well as the tick labels were consistent with large-scale panel surveys \citep[e.g.,][]{DeBell2010}.

\input{Tables/workerVarDescr}
\input{Tables/workerOutVarDescr}

\subsection{Results}

```{r WorkerFreqAttCor, include=FALSE}
# correlation panel
pairs.panels.new(
  dtWorkerSupp$workerAvFreQual %>% select(SumContactNL, SumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)",
    "Sum:\nNumber of Outgroup Contacts (NL)",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)

# correlation panel with interaction sums winsorized
pairs.panels.new(
  dtWorkerSupp$workerAvFreQual %>% select(WinSumContactNL, WinSumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)\n[Winsorized]",
    "Sum:\nNumber of Outgroup Contacts (NL)\n[Winsorized]",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)
```

\paragraph{Contact Hypothesis}We tested the most general contact hypothesis in two steps. First, we assessed whether more intergroup interactions were related to to more positive outgroup attitudes. Second, we tested whether a potential positive effect on outgroup attitudes depended on the interaction quality (jointly with the number of interactions). We find that neither the number of interactions nor the number of daily diary responses with an interaction were significantly related with the average outgroup attitudes. This is to say that within our data, participants with more outgroup interactions did not have significantly more positive outgroup attitudes. This might be due to the aggregation within the participants or the small sample size of between participant data. Nonetheless, the aggregate data does not support the notion that simply having more interactions with an outgroup results in more positive outgroup attitudes.

```{r workerModelOlsAttFreqQual, include=FALSE}
# create list to store Worker models
mdlWorker <- list()

# regression
mdlWorker$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL * AvQuality, data = dtWorkerSupp$workerAvFreQual)
# summary(lmWorkerAttFreqQualX)

summ(
  mdlWorker$lmAttFreqQualX,
  confint = TRUE,
  digits = 3,
  center = TRUE
)

mdlWorker$lmAttFreqQualXEta <-
  effectsize::eta_squared(mdlWorker$lmAttFreqQualX, partial = TRUE)

interactions::interact_plot(
  mdlWorker$lmAttFreqQualX,
  pred = AvQuality,
  modx = SumContactNL,
  interval = TRUE,
  partial.residuals = TRUE
)

interactions::johnson_neyman(mdlWorker$lmAttFreqQualX,
                             pred = AvQuality,
                             modx = SumContactNL,
                             alpha = .05)

```

However, despite the missing relationship with the number of interactions, we find a medium sized correlation between the participants' Average Interaction Quality and their Average Outgroup Attitudes. Thus within our data participants with a higher quality outgroup interactions also held more positive attitudes towards that group. And when considering the number of interactions and average interaction quality jointly in a linear regression, we additionally find a statistically significant interaction term (\textit{b} = `r coef(summary(mdlWorker$lmAttFreqQualX))["SumContactNL:AvQuality","Estimate"] %>% round(2) %>% format(nsmall=2)`, \textit{t}(`r mdlWorker$lmAttFreqQualX$df.residual`) = `r coef(summary(mdlWorker$lmAttFreqQualX))["SumContactNL:AvQuality","t value"] %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r coef(summary(mdlWorker$lmAttFreqQualX))["SumContactNL:AvQuality","Pr(>|t|)"] %>% round(3) %>% format(nsmall=3)`, $\eta_p^2$ = `r mdlWorker$lmAttFreqQualXEta %>% filter(Parameter == "SumContactNL:AvQuality") %>% select(Eta2_partial) %>% as.numeric %>% round(2) %>% format(nsmall=2)`). Looking at a floodlight analysis of the effect, we find that in our sample with an increasing number of interactions the positive effect of average interaction quality becomes weaker. However, it should be noted that this is based on data aggregating all within participant nuances and is only the date of 21 people. 

```{r workerModelMLAttNull, include=FALSE}
# Create and save Model
mdlWorker$lmerAttNull <-
  lme4::lmer(thermometerDutch_1 ~ 1 + (1 | PID),
    data = dtWorker$full
  ) # use optim if it does not converge

mdlWorker$lmeAttNull <-
  lme(
    thermometerDutch_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorker$full,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(lmerWorkerAttNull) #or with the lme function
summ(mdlWorker$lmerAttNull, digits = 3, center = TRUE)

# generate 95% parametric bootstrap CIs (and save them as a csv-file):
# write.csv(confint(lmer(thermometerDutch_1~1 + (1|PID),data=dtWorker$full),
#                  method="boot",nsim=1000,
#                  parallel = "multicore", ncpus = 4, seed = 42),
#          "output/tables/ML-Null-CI.csv")

# Save variances
mdlWorker$varAttNull <- 
  VarCorr(mdlWorker$lmeAttNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorker$tauAttNull <- 
  as.numeric(mdlWorker$varAttNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorker$sigmaAttNull <- 
  as.numeric(mdlWorker$varAttNull[2])
# The ICC estimate (between/between+within) is:
mdlWorker$IccAttNull <-
  (as.numeric(mdlWorker$varAttNull[1]) / (as.numeric(mdlWorker$varAttNull[1]) + as.numeric(mdlWorker$varAttNull[2])))
mdlWorker$IccPercAttNull <-
  ((as.numeric(mdlWorker$varAttNull[1]) / (as.numeric(mdlWorker$varAttNull[1]) + as.numeric(mdlWorker$varAttNull[2])))) * 100
```
```{r workerModelInterceptAttType, include=FALSE}
# Create and save Model
mdlWorker$lmeInterceptAttType <-
  lme(
    thermometerDutch_1 ~ OutgroupInteraction + NonOutgroupInteraction,
    random =  ~ 1 | PID,
    data = dtWorkerSupp$workerInteractionType
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorker$lmerInterceptAttType <- lmer(
    thermometerDutch_1 ~ OutgroupInteraction + NonOutgroupInteraction + (1 | PID),
    data = dtWorkerSupp$workerInteractionType
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlWorker$lmerInterceptAttTypeCI <- confint(mdlWorker$lmerInterceptAttType)

# Generate 95% parametric bootstrap CIs (and save them as a csv-file):
# write.csv(confint(lmer(thermometerDutch_1 ~ Contact_dum + inNonDutch + (1|PID),data=dtWorker$full),
#                  method="boot",nsim=1000, parallel = "multicore",
#                  ncpus = 4, seed = 42),
#          "output/tables/ML-Inter-CI.csv")

# Compare new model to previous step
anova(mdlWorker$lmeAttNull, 
      mdlWorker$lmeInterceptAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorker$varInterceptAttType <- 
  lme4::VarCorr(mdlWorker$lmeInterceptAttType)
```

We additionally used a multilevel regression to check whether having an interaction with an outgroup member had a situational (i.e., contemporaneous) effect within the participants. We find that having an outgroup interaction is indeed associated with significantly more positive outgroup attitudes within the participants (`r MlCoeffLatex(lmeMdl = mdlWorker$lmeInterceptAttType, lmerCI = mdlWorker$lmerInterceptAttTypeCI, varName = "OutgroupInteractionYes")`), even after controlling for having an interaction with a non-Dutch (which did not relate to outgroup attitudes independently; For full results see Online Supplementary Materials B)\footnote{Interestingly, adding random slopes to this model did not significantly add explained variance. This is unusual because this might indicate the the effect is very consistent across participants. However, this might also be the case due to a small number of participants, or other measurement issues.}. Thus, in our first data we find mixed results, where outgroup contacts show a positive effect on outgroup attitudes in the moment but these results do not translate into average differences between participants, keeping in mind that the between-participant analyses in the aggregated form are based in a small sample size.

\paragraph{Core Need}The main proposal of our article is that the success of an outgroup interaction might be explained by whether or not the interaction fulfilled the person's core situational need. This should, in turn, be due to a higher perceived interaction quality. We will this sequentially test whether the fulfillment of the core need during an interaction is (1) related to more positive outgroup attitudes, (2) higher perceived interaction quality, and (3) whether the variance explained by the core need is assumed by the perceived interaction quality if considered jointly. 

```{r workerOutModelMLAttNull, include=FALSE}
# create empty list to organize models
mdlWorkerOut <- 
  list(
    Att = list(),
    Qlt = list()
  )

# Create and save Model
mdlWorkerOut$Att$lmerNull <-
  lme4::lmer(thermometerDutch_1 ~ 1 + (1 | PID), 
             data = dtWorkerSupp$workerOutgroupInteraction) # use optim if it does not converge
mdlWorkerOut$Att$lmeNull <-
  lme(
    thermometerDutch_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutgroupInteraction,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.ML.r) #or with the lme function
summ(mdlWorkerOut$Att$lmerNull, digits = 3, center = TRUE)

# generate 95% parametric bootstrap CIs (and save them as a csv-file):
# write.csv(confint(lmer(thermometerDutch_1~1 + (1|PID),data=dtWorker$full),
#                  method="boot",nsim=1000,
#                  parallel = "multicore", ncpus = 4, seed = 42),
#          "output/tables/ML-Null-CI.csv")

# Save variances
mdlWorkerOut$Att$varNull <- 
  VarCorr(mdlWorkerOut$Att$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorkerOut$Att$tauNull <- 
  as.numeric(mdlWorkerOut$Att$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorkerOut$Att$sigmaNull <- 
  as.numeric(mdlWorkerOut$Att$varNull[2])
# The ICC estimate (between/between+within) is:
mdlWorkerOut$Att$IccNull <-
  (as.numeric(mdlWorkerOut$Att$varNull[1]) / (as.numeric(mdlWorkerOut$Att$varNull[1]) + as.numeric(mdlWorkerOut$Att$varNull[2])))
mdlWorkerOut$Att$IccPercNull <-
  ((as.numeric(mdlWorkerOut$Att$varNull[1]) / (as.numeric(mdlWorkerOut$Att$varNull[1]) + as.numeric(mdlWorkerOut$Att$varNull[2])))) * 100
```
```{r workerOutModelInterceptAttCore, include=FALSE}
# Create and save Model
mdlWorkerOut$Att$lmeInterceptCore <-
  lme(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Att$lmerInterceptCore <-
    lmer(
      thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + (1 | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlWorkerOut$Att$lmerInterceptCoreCI <- 
  confint(mdlWorkerOut$Att$lmerInterceptCore)

# Generate 95% parametric bootstrap CIs (and save them as a csv-file):
# write.csv(confint(lmer(thermometerDutch_1 ~ Contact_dum + inNonDutch + (1|PID),data=workerOutgroupInteraction),
#                  method="boot",nsim=1000, parallel = "multicore",
#                  ncpus = 4, seed = 42),
#          "output/tables/ML-Inter-CI.csv")

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeNull, 
      mdlWorkerOut$Att$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varInterceptCore <-
  lme4::VarCorr(mdlWorkerOut$Att$lmeInterceptCore)

# The estimate of between-group (or Intercept variance) explained:
# Variance Explained = 1 – (Var with Predictor/Var without Predictor)
mdlWorkerOut$Att$varBtwInterceptCore <-
  1 - (mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["(Intercept)", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varBtwPercInterceptCore <-
  (1 - (mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["(Intercept)", "Variance"] %>% as.numeric)) * 100
# and the estimate of within-group (or residual variance) explained is:
mdlWorkerOut$Att$varWithinInterceptCore <-
  1 - (mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["Residual", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varWithinPercInterceptCore <-
  (1 - (mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["Residual", "Variance"] %>% as.numeric)) * 100
```
```{r workerOutModelSlopesAttCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesCore <-
  lme(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesCore <- lmer(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc +
      (1 + keymotive_fulfillemt_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# all variables standardized within PPT
summ(
  mdlWorkerOut$Att$lmerSlopesCoreZ <- lmer(
    thermometerDutch_1_zwc ~
      keymotive_fulfillemt_1_zwc +
      (1 + keymotive_fulfillemt_1_zwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# standardized coefficients
stdCoef.merMod(mdlWorkerOut$Att$lmerSlopesCore)

# 95%CIs
mdlWorkerOut$Att$lmerSlopesCoreCI <- confint(mdlWorkerOut$Att$lmerSlopesCore)

# Attempts at R^2
r2mlm::r2mlm(mdlWorkerOut$Att$lmerSlopesCore, bargraph = TRUE)
mitml::multilevelR2(mdlWorkerOut$Att$lmerSlopesCore)
performance::r2(mdlWorkerOut$Att$lmerSlopesCore)
performance::model_performance(mdlWorkerOut$Att$lmerSlopesCore)
performance::compare_performance(mdlWorkerOut$Att$lmerNull, 
                                 mdlWorkerOut$Att$lmerInterceptCore, 
                                 mdlWorkerOut$Att$lmerSlopesCore)

# Generate 95% parametric bootstrap CIs (and save them as a csv-file):
# write.csv(confint(model.ran0,
#               method="boot",nsim=1000,
#               parallel = "multicore", ncpus = 4, seed = 42),
#          "output/tables/ML-RandomSlopes-CI.csv")

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeNull, 
      mdlWorkerOut$Att$lmeInterceptCore, 
      mdlWorkerOut$Att$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varSlopesCore <- 
  lme4::VarCorr(mdlWorkerOut$Att$lmeSlopesCore)

# The estimate of between-group (or Intercept variance) explained:
# Variance Explained = 1 – (Var with Predictor/Var without Predictor)
mdlWorkerOut$Att$varBtwSlopesCore <-
  1 - (mdlWorkerOut$Att$varSlopesCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varBtwPercSlopesCore <-
  (1 - (mdlWorkerOut$Att$varSlopesCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric)) * 100
# and the estimate of within-group (or residual variance) explained is:
mdlWorkerOut$Att$varWithinSlopesCore <-
  1 - (mdlWorkerOut$Att$varSlopesCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varWithinPercSlopesCore <-
  (1 - (mdlWorkerOut$Att$varSlopesCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric)) * 100

# Assumption Checks:
mdlWorkerOut$Att$diagSlopesCore <- 
  sjPlot::plot_model(mdlWorkerOut$Att$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlWorkerOut$Att$diagSlopesCore[[1]],
  mdlWorkerOut$Att$diagSlopesCore[[2]]$`PID`,
  mdlWorkerOut$Att$diagSlopesCore[[3]],
  mdlWorkerOut$Att$diagSlopesCore[[4]]
)

# Plot prediction model
mdlWorkerOut$Att$predSlopesCore <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  select(thermometerDutch_1, session, PID) %>% 
  mutate(measure = predict(mdlWorkerOut$Att$lmeSlopesCore,
                           dtWorkerSupp$workerOutWithinBetween,
                           re.form = NA
                           )
         )

(
  mdlWorkerOut$Att$predPltSlopesCore <-
    ggplot(data = mdlWorkerOut$Att$predSlopesCore, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/WorkerOut_PredictionPlot_SlopesAttCore.png",
  mdlWorkerOut$Att$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

```{r workerOutModelMLQltNull, include=FALSE}
# Create and save Model
mdlWorkerOut$Qlt$lmerNull <-
  lme4::lmer(quality_overall_1 ~ 1 + (1 | PID), 
             data = dtWorkerSupp$workerOutWithinBetween) # use optim if it does not converge
mdlWorkerOut$Qlt$lmeNull <-
  mdlWorkerOut$Qlt$lmeNull <-lme(
    quality_overall_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.Qual.ML.r) #or with the lme function
summ(mdlWorkerOut$Qlt$lmerNull, digits = 3)

# generate 95% parametric bootstrap CIs (and save them as a csv-file):
# write.csv(confint(lmer(thermometerDutch_1~1 + (1|PID),data=workerOutgroupInteraction),
#                  method="boot",nsim=1000,
#                  parallel = "multicore", ncpus = 4, seed = 42),
#          "output/tables/ML-Null-CI.csv")

# Save variances
mdlWorkerOut$Qlt$varNull <- 
  VarCorr(mdlWorkerOut$Qlt$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorkerOut$Qlt$tauNull <- 
  as.numeric(mdlWorkerOut$Qlt$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorkerOut$Qlt$sigmaNull <- 
  as.numeric(mdlWorkerOut$Qlt$varNull[2])
# The ICC estimate (between/between+within) is:
mdlWorkerOut$Qlt$IccNull <-
  (as.numeric(mdlWorkerOut$Qlt$varNull[1]) / (as.numeric(mdlWorkerOut$Qlt$varNull[1]) + as.numeric(mdlWorkerOut$Qlt$varNull[2])))
mdlWorkerOut$Qlt$IccPercNull <-
  ((as.numeric(mdlWorkerOut$Qlt$varNull[1]) / (as.numeric(mdlWorkerOut$Qlt$varNull[1]) + as.numeric(mdlWorkerOut$Qlt$varNull[2])))) * 100
```
```{r workerOutModelInterceptQltCore, include=FALSE}
# Create and save Model
mdlWorkerOut$Qlt$lmeInterceptCore <-
  lme(
    quality_overall_1 ~ keymotive_fulfillemt_1_cwc,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Qlt$lmerInterceptCore <-
    lmer(
      quality_overall_1 ~ keymotive_fulfillemt_1_cwc + (1 | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlWorkerOut$Qlt$lmerInterceptCoreCI <- 
  confint(mdlWorkerOut$Qlt$lmerInterceptCore)

# Generate 95% parametric bootstrap CIs (and save them as a csv-file):
# write.csv(confint(lmer(quality_overall_1 ~ Contact_dum + inNonDutch + (1|PID),data=workerOutgroupInteraction),
#                  method="boot",nsim=1000, parallel = "multicore",
#                  ncpus = 4, seed = 42),
#          "output/tables/ML-Inter-CI.csv")

# Compare new model to previous step
anova(mdlWorkerOut$Qlt$lmeNull, 
      mdlWorkerOut$Qlt$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Qlt$varInterceptCore <-
  lme4::VarCorr(mdlWorkerOut$Qlt$lmeInterceptCore)
```
```{r workerOutModelSlopesQltCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Qlt$lmeSlopesCore <-
  lme(
    quality_overall_1 ~
      keymotive_fulfillemt_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Qlt$lmerSlopesCore <-
    lmer(
      quality_overall_1 ~
        keymotive_fulfillemt_1_cwc +
        (1 + keymotive_fulfillemt_1_cwc | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlWorkerOut$Qlt$lmerSlopesCoreCI <- 
  confint(mdlWorkerOut$Qlt$lmerSlopesCore)

# Generate 95% parametric bootstrap CIs (and save them as a csv-file):
# write.csv(confint(mdlWorkerOut$Qlt$lmerSlopesCore,
#               method="boot",nsim=1000,
#               parallel = "multicore", ncpus = 4, seed = 42),
#          "output/tables/ML-RandomSlopes-CI.csv")

# Compare new model to previous step
anova(mdlWorkerOut$Qlt$lmeNull, 
      mdlWorkerOut$Qlt$lmeInterceptCore, 
      mdlWorkerOut$Qlt$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Qlt$varSlopesCore <- 
  lme4::VarCorr(mdlWorkerOut$Qlt$lmeSlopesCore)
```
```{r workerOutModelInterceptAttCoreQlt, include=FALSE}
# Create and save Model
mdlWorkerOut$Att$lmeInterceptCoreQlt <-
  lme(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + quality_overall_1_cwc,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Att$lmerInterceptCoreQlt <-
    lmer(
      thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + quality_overall_1_cwc + (1 | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

mdlWorkerOut$Att$lmerInterceptCoreQltCI <- 
  confint(mdlWorkerOut$Att$lmerInterceptCoreQlt)

# Generate 95% parametric bootstrap CIs (and save them as a csv-file):
# write.csv(confint(lmer(thermometerDutch_1 ~ Contact_dum + inNonDutch + (1|PID),data=workerOutgroupInteraction),
#                  method="boot",nsim=1000, parallel = "multicore",
#                  ncpus = 4, seed = 42),
#          "output/tables/ML-Inter-CI.csv")

# Compare new model to previous step
anova(
  mdlWorkerOut$Att$lmeNull, 
  mdlWorkerOut$Att$lmeInterceptCoreQlt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varInterceptCoreQlt <-
  lme4::VarCorr(mdlWorkerOut$Att$lmeInterceptCoreQlt)
```
```{r workerOutModelSlopesAttCoreQlt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesCoreQlt <-
  lme(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + quality_overall_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc + quality_overall_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesCoreQlt <- lmer(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + quality_overall_1_cwc +
      (1 + keymotive_fulfillemt_1_cwc + quality_overall_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlWorkerOut$Att$lmerSlopesCoreQltCI <- 
  confint(mdlWorkerOut$Att$lmerSlopesCoreQlt)

# Generate 95% parametric bootstrap CIs (and save them as a csv-file):
# write.csv(confint(model.ran0,
#               method="boot",nsim=1000,
#               parallel = "multicore", ncpus = 4, seed = 42),
#          "output/tables/ML-RandomSlopes-CI.csv")

# Compare new model to previous step
anova(
  mdlWorkerOut$Att$lmeNull,
  mdlWorkerOut$Att$lmeInterceptCoreQlt,
  mdlWorkerOut$Att$lmeSlopesCoreQlt
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varSlopesCoreQlt <- 
  lme4::VarCorr(mdlWorkerOut$Att$lmeSlopesCoreQlt)

# Assumption Checks:
mdlWorkerOut$Att$diagSlopesCoreQlt <- 
  sjPlot::plot_model(mdlWorkerOut$Att$lmerSlopesCoreQlt, type = "diag")
grid.arrange(
  mdlWorkerOut$Att$diagSlopesCoreQlt[[1]],
  mdlWorkerOut$Att$diagSlopesCoreQlt[[2]]$`PID`,
  mdlWorkerOut$Att$diagSlopesCoreQlt[[3]],
  mdlWorkerOut$Att$diagSlopesCoreQlt[[4]]
)

# Plot prediction model
mdlWorkerOut$Att$predSlopesCoreQlt <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  select(thermometerDutch_1, session, PID) %>% 
  mutate(measure = predict(mdlWorkerOut$Att$lmeSlopesCoreQlt,
                           dtWorkerSupp$workerOutWithinBetween,
                           re.form = NA
                           )
         )

(
  mdlWorkerOut$Att$predPltSlopesCoreQlt <-
    ggplot(data = mdlWorkerOut$Att$predSlopesCoreQlt, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/WorkerOut_PredictionPlot_SlopesAttCoreQlt.png",
  mdlWorkerOut$Att$predPltSlopesCoreQlt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We find that in the highest multilevel models, the fulfillment of core situational needs during outgroup contacts was associated with more positive outgroup attitudes (random slopes model; `r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCore, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreCI, varName = "keymotive_fulfillemt_1_cwc")`) and also predicted higher perceived interaction quality (random intercept model; `r MlCoeffLatex(lmeMdl = mdlWorkerOut$Qlt$lmeInterceptCore, lmerCI = mdlWorkerOut$Qlt$lmerInterceptCoreCI, varName = "keymotive_fulfillemt_1_cwc")`). However, if we consider the influences of core need fulfillment and interaction quality on outgroup attitudes jointly, we find that virtually all variance is explained by perceived interaction quality (random slopes mode; `r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreQlt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreQltCI, varName = "quality_overall_1_cwc")`) and only little unique variance is still explained by core need fulfillment (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreQlt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreQltCI, varName = "keymotive_fulfillemt_1_cwc")`). We thus find support for our hypotheses and can conclude that in this data set the fulfillment of core situational needs had a significant influence on outgroup attitudes and that this effect is likely explained by its effect through perceived interaction quality. 

\faQuestionCircle\ Are we sure that we don't want some sort of bootstrapped indirect effect? 

\paragraph{Robustness}

\subparagraph{Interaction Type}

\subparagraph{Other Needs}

For full results see Online Supplementary Information B.

\section{Study 2}

\subsection{Methods}

\subsection{Results}

\section{Study 2}

\subsection{Methods}

\subsection{Results}

<!-- \begin{figure}[h] -->

<!-- \centering -->

<!-- \caption{PRISMA Diagrams for the Theoretical, Methodological, and Empirical Literature.} -->

<!-- \makebox[\textwidth]{\includegraphics[width=\paperwidth]{Figures/PrismaCombined}} -->

<!-- \label{fig:PrismaCombined} -->

<!-- \end{figure} -->

<!-- \input{Tables/ExclusionsCombined} -->

<!-- \input{Tables/TheoreticalExclusion} -->

<!-- \begin{figure}[h] -->

<!-- \centering -->

<!-- \caption{Literature Levels: (A) Bar graph of the experience aspect frequencies for theoretical, methodological, and broader empirical literature. (B) Bar graph of the number of experience aspects used for theoretical, methodological, and broader empirical literature. (C) Average number of additional aspects included when the aspect was considered for theoretical, methodological, and broader empirical literature [Mean ± 95\%CI].} -->

<!-- \includegraphics[width=\textwidth]{Figures/LiteratureComparison-1} -->

<!-- \caption*{Note that in (C) within each literature body the aspects are not mutually exclusive (and thus not independent) because scales can include multiple experience aspects.} -->

<!-- \label{fig:LiteratureComparison} -->

<!-- \end{figure} -->
