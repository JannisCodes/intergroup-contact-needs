---
output: latex_fragment
editor_options:
  chunk_output_type: console
bibliography: references.bib
csl: apa.csl
---

```{r setup, include=FALSE}
# R Studio Clean-Up
cat("\014") # clear console
# rm(list=ls()) # clear workspace - use restart R instead [cmd/alt + shift + F10]
gc() # garbage collector

# Install and Load Packages
# !IMPORTANT!
# BEFORE FIRST RENDER:
# To install all relevant packages please run "renv::restore()" (or renv::init() and then initiate from lockfile) in the console before the first use to ensure that all packages are using the correct version.
# to store the packages in a contained library within the project folder: renv::settings$use.cache(FALSE) and add 'RENV_CONFIG_SANDBOX_ENABLED = FALSE' to an '.Renviron' file
lib <- c(
  "rmarkdown",
  "knitr",
  "berryFunctions",
  "remedy",
  "bookdown",
  "brms",
  "psych",
  "ggplot2",
  "ggthemes",
  "purrr",
  "haven",
  "RColorBrewer",
  "plotly",
  "gridExtra",
  "ggpattern",
  "lme4",
  "nlme",
  "jtools",
  "gtsummary",
  "sessioninfo",
  "tibble",
  "pander",
  "devtools",
  "mada",
  "data.table",
  "plyr",
  "dplyr",
  "tidyr",
  "Hmisc",
  "kableExtra",
  "papaja",
  "stringr",
  "stringi",
  "reshape2",
  "lubridate",
  "misty",
  "sjPlot",
  "sjmisc",
  "sjmisc"
)
invisible(lapply(lib, library, character.only = TRUE))
rm(lib)

# Load Custom Packages
source("./scripts/functions/fun.panel.R")
source("./scripts/functions/themes.R")
source("./scripts/functions/binaryCor.R")
source("./scripts/functions/MlCorMat.R")
source("./scripts/functions/MlTbl.R")

# Markdown Options
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # set working directory
knitr::opts_knit$get("root.dir") # check working directory
options(
  scipen = 999,
  digits = 4,
  width = 400
) # removes scientific quotation
# knitr::opts_chunk$set(echo = TRUE, cache = F, cache.path = rprojroot::find_rstudio_root_file('cache/')) # cache settings

# Global Chunk Options
knitr::opts_chunk$set(
  fig.width = 12,
  fig.height = 8,
  fig.path = "Figures/",
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)
```

```{r import, include=FALSE}
load("data/wrangled.RData")
```

\section{Study 1}

Based on our main hypotheses, the aim of our first study is to specifically test the general contact hypothesis, the influence of core need fulfillment, and perceived interaction quality during intergroup contacts. To this aim, we conducted an intensive longitudinal survey study with recent migrants to the Netherlands, gathering a large body of ecologically valid data on need satisfaction in real-life intergroup contact situations. Data was collected from May 5th through June 6th, 2018 (and all participants started the study within the first two days).

The full surveys are available in our Online Supplementary Material A and the full data description is available in Online Supplementary Materials B. Correlations and descriptive statistics of the included variables are available in Table \ref{tab:workerVarDescr} and Table \ref{tab:workerOutVarDescr}.

\subsection{Methods}

```{r workerSampleInfo, include=FALSE}
# combine education measure
workerOccupation <- 
  dtWorker$clean %>%
  select(PID, starts_with("occupation")) %>%
  mutate_all(as_factor) %>% 
  mutate_all(as.character) %>%
  replace(is.na(.), "") %>%
  unite("occupation", -PID, sep = "/") %>%
  mutate(occupation = trimws(occupation, which = "both", whitespace = "[/]")) %>%
  distinct

# summarize participant characteristics
workerSampleInfo <- 
  dtWorker$clean %>%
  group_by(PID) %>%
  summarise(
    dailiesN = n(), 
    morningN = sum(daytime=="morning"),
    afternoonN = sum(daytime=="afternoon"),
    age = age,
    gender = as_factor(Gender),
    edu = as_factor(education_level),
    nationality = as_factor(nationality)
  ) %>%
  distinct

# add occupation variable
workerSampleInfo <- merge(workerSampleInfo, workerOccupation)
rm(workerOccupation)

# look at frequencies of characteristics 
table(workerSampleInfo$gender)
table(workerSampleInfo$edu)
table(workerSampleInfo$occupation)
table(as.character(workerSampleInfo$nationality))

# categorical variables:
# - outgroup contact
# - non-outgroup contact

# continuous variables:
# - Core Need fulfillment
# - SDT Competence
# - SDT Autonomy
# - SDT Relatedness
# - Interaction Quality
# - Outgroup Attitudes
######
# within cor
# between cor
# ---
# Grand mean
# SD between
# SD within
# Proportion of variance
# __ __ __
# Note:
# N within ppt.s 
######

# divide into trait and state
dtWorkerSupp$workerWithinBetween <-
  MlTraitState(
    data = dtWorkerSupp$workerInteractionType,
    id = "PID",
    selection =
      c(
        "keyMotiveFulfilled",
        "competence.daily.all",
        "autonomy.daily.all",
        "relatedness.daily.all",
        "thermometerDutch_1",
        "keymotive_fulfillemt_1",
        "competence_1",
        "autonomy_1",
        "relatedness_1", 
        "quality_overall_1", 
        "OutgroupInteraction",
        "NonOutgroupInteraction"
      )
  )

dtWorkerSupp$workerOutWithinBetween <-
  MlTraitState(
    data = dtWorkerSupp$workerInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection =
      c(
        "keyMotiveFulfilled",
        "thermometerDutch_1",
        "keymotive_fulfillemt_1",
        "competence_1",
        "autonomy_1",
        "relatedness_1", 
        "quality_overall_1"
      )
  )
```

```{r workerVarDescr, include=FALSE}
workerMlCor <-
  MlCorMat(
    data = dtWorkerSupp$workerInteractionType,
    id = "PID",
    selection = c("keyMotiveFulfilled", "competence.daily.all", "autonomy.daily.all", "relatedness.daily.all", "quality_overall_1", "thermometerDutch_1"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Quality", "Attitudes NL")
  ) 

workerMlCor %>%
  kable(
    .,
    caption = "Worker: Multilevel Core Variable Descriptives",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/workerVarDescr.tex")
```

```{r workerOutVarDescr, include=FALSE}
workerOutMlCor <-
  MlCorMat(
    data = dtWorkerSupp$workerInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection = c("keymotive_fulfillemt_1", "competence_1", "autonomy_1", "relatedness_1", "quality_overall_1", "thermometerDutch_1"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Quality", "Attitudes NL")
  )

workerOutMlCor %>%
  kable(
    .,
    caption = "Worker: Multilevel Core Variable Descriptives (Outgroup Contact Only)",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/workerOutVarDescr.tex")

# misty::multilevel.descript(dtWorkerSupp$workerWithinBetween$keyMotiveFulfilled, cluster = dtWorkerSupp$workerWithinBetween$PID)
```


\subsubsection{Participants} After receiving ethical approval from the University of Groningen, we recruited `r nrow(workerSampleInfo)` migrants using the local paid participant pool and specifically targeted non-Dutch migrants to participate in our study. Participants reported on their interactions for at least 30 days with two daily measures (capturing the morning and afternoon). With this design, we aimed at getting 50-60 measurements per participant (\textit{M} = `r format(round(mean(workerSampleInfo$dailiesN),2), nsmall=2)`, \textit{SD} = `r format(round(sd(workerSampleInfo$dailiesN),2), nsmall=2)`, \textit{total N} = `r sum(workerSampleInfo$dailiesN)`). This is a common number of measurements found in experience sampling studies and should offer sufficient power to model processes within and between participants \citep[e.g., for a systematic review see][]{AanhetRot2012}. Participants were compensated for their participation with up to 34 Euros – each two Euros for pre- and post-questionnaire as well as 50 Eurocents for every experience sampling measurement occasion. The sample consisted of relatively young, educated, and western migrants from the global north ($M_{age}$ = `r format(round(mean(workerSampleInfo$age),2), nsmall=2)`, $SD_{age}$ = `r format(round(sd(workerSampleInfo$age),2), nsmall=2)`, `r nrow(workerSampleInfo %>% filter(gender == "Female"))` women, `r nrow(workerSampleInfo %>% filter(occupation == "student"))` students). The sample accurately describes one of the largest groups of migrants in the region \citep[][]{GemeenteGroningen2015}.

\subsubsection{Procedure} The study itself consisted of three main parts, an introductory pre-measurement, and the daily experience sampling measurements, as well as a concluding post-measurement. After giving informed consent, participants started by filling in an online pre-questionnaire assessing demographics and general information about their immigration. Over the next thirty days, the participants then were invited twice a day (at 12 pm and 7pm) to reflect upon their interactions, psychological need fulfillments, and current attitudes towards the Dutch outgroup (\textit{median duration} = `r seconds_to_period(median(dtWorker$clean$Duration__in_seconds_)) %>% as.character`, \textit{MAD duration} = `r seconds_to_period(round(mad(dtWorker$clean$Duration__in_seconds_))) %>% as.character`).  General compliance was high (`r format(round(sum(workerSampleInfo$dailiesN)/(nrow(workerSampleInfo)*62)*100,2), nsmall=2)`\% of all invited surveys were filled in)\footnote{Two participants completed only two days (among the others, participation was `r format(round(sum(workerSampleInfo$dailiesN[workerSampleInfo$dailiesN>3])/(nrow(workerSampleInfo[workerSampleInfo$dailiesN>3,])*62)*100,2), nsmall=2)`\%)}. The response rates were approximately equal during mornings (\textit{n} = `r sum(workerSampleInfo$morningN)`) and afternoons (\textit{n} = `r sum(workerSampleInfo$afternoonN)`) and most measurements were completed within four hours of the invitation. After the final day of daily diary measurements, participants were invited to fill in a longer post measurement survey that mirrored the pre-measurement. All key variables for this study were part of the short daily diary surveys. 

\subsubsection{Materials}

\paragraph{Intergroup Contact}To test the prerequisite effect of intergroup contact, every experience sampling measurement started with the question “\textit{Did you meet a Dutch person this morning [/afternoon]? (In person interaction for at least 10 minutes)}”. Our participants recorded between `r dtWorkerSupp$workerAvFreQual$SumContactNL[dtWorkerSupp$workerAvFreQual$SumContactNL > 0] %>% min`--`r dtWorkerSupp$workerAvFreQual$SumContactNL[dtWorkerSupp$workerAvFreQual$SumContactNL > 0] %>% max`
(`r dtWorkerSupp$workerAvFreQual$PercContactNL[dtWorkerSupp$workerAvFreQual$PercContactNL > 0] %>% min %>% round(2) %>% format(nsmall=2)`--`r dtWorkerSupp$workerAvFreQual$PercContactNL[dtWorkerSupp$workerAvFreQual$PercContactNL > 0] %>% max %>% round(2) %>% format(nsmall=2)`\% of individual daily diary measurements; `r (sum(dtWorkerSupp$workerAvFreQual$SumContactNL) / nrow(dtWorkerSupp$workerInteractionType) * 100) %>% round(2) %>% format(nsmall=2)`\% of all `r nrow(dtWorkerSupp$workerInteractionType)` daily diary responses)\footnote{Two participants only recorded two daily diary measurements each and non of these included outgroup contacts. These participants are removed from any analyses including outgroup contacts.}.

\paragraph{Psychological Needs}Irrespective of whether participants had an interaction with Dutch people or not, everyone answered a short series of questions on psychological need fulfillment. However, whereas participants with interactions reported on the need fulfillment during the interaction, people without interactions with Dutch people judged the past daytime period in general. To assess the fulfillment of psychological needs, we included two types of need measurement: (1) the core situational need and (2) general self-determination theory needs.

For the core situational need, we asked participants in an open ended text field: “\textit{What was your most important goal [during the interaction / this morning / this afternoon]?}”. Then, with reference to the text entry, we asked how much this core need was fulfilled during the interaction or the past daytime period: “\textit{[The interaction / You] fulfilled your goal: [-previous text entry-]}” on a continuous slider scale ranging from strongly disagree (-50) to strongly agree (+50).

We, additionally, included a common measure of three self-determination theory needs \citep[see][]{Downie2008}. The items were introduced either by “\textit{During the interaction:}” or “\textit{This morning [/afternoon]:}” and measured autonomy (“\textit{I was myself.}”), competence (“\textit{I felt competent.}”), and relatedness (without intergroup contact “\textit{I had a strong need to belong}”; with intergroup contact: “\textit{I shared information about myself.}” and “\textit{The other(s) shared information about themselves.}”). All items were rated on a continuous slider scale from very little (-50) to a great deal (+50).

\paragraph{Perceived Interaction Quality}As an explanatory mechanism, we assessed ratings of the perceived interaction quality. As our main measurement, participants rated the statement “\textit{Overall the interaction was …}” on two continuous slider scales measuring pleasantness \citep[from unpleasant (-50) to pleasant (+50)) and meaningfulness (from superficial (-50) to meaningful (+50); both items adapted from][]{Downie2008}.

\paragraph{Outgroup Attitudes}At the end of every daily diary measurement we asked all participants about their current attitudes towards the Dutch – our main dependent variable. To assess the momentary outgroup evaluation we used the common feeling thermometer: “How favorable do you feel towards the Dutch?” \citep[][]{Lavrakas2008}. Participants then rated their attitude on a continuous slider scale from “very cold – 0” through “no feeling – 50” to “very warm – 100”. Both the question phrasing as well as the tick labels were consistent with large-scale panel surveys \citep[e.g.,][]{DeBell2010}.

\input{Tables/workerVarDescr}
\input{Tables/workerOutVarDescr}

\subsection{Results}

```{r WorkerFreqAttCor, include=FALSE}
dtWorkerSupp$workerAvFreQual <-
  dtWorkerSupp$workerAvFreQual %>%
  mutate(
    SumContactNL_c = SumContactNL - mean(SumContactNL, na.rm = TRUE),
    SumContactNLAll_c = SumContactNLAll - mean(SumContactNLAll, na.rm = TRUE),
    AvAttitude_c = AvAttitude - mean(AvAttitude, na.rm = TRUE),
    AvQuality_c = AvQuality - mean(AvQuality, na.rm = TRUE)
  )

# correlation panel
pairs.panels.new(
  dtWorkerSupp$workerAvFreQual %>% select(SumContactNL, SumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)",
    "Sum:\nNumber of Outgroup Contacts (NL)",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)

# correlation panel with interaction sums winsorized
pairs.panels.new(
  dtWorkerSupp$workerAvFreQual %>% select(WinSumContactNL, WinSumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)\n[Winsorized]",
    "Sum:\nNumber of Outgroup Contacts (NL)\n[Winsorized]",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)
```

\subsubsection{Contact Hypothesis}We tested the most general contact hypothesis in two steps. First, we assessed whether more intergroup interactions were related to to more positive outgroup attitudes. Second, we tested whether a potential positive effect on outgroup attitudes depended on the interaction quality (jointly with the number of interactions). We find that neither the number of interactions nor the number of daily diary responses with an interaction were significantly related with the average outgroup attitudes. This is to say that within our data, participants with more outgroup interactions did not have significantly more positive outgroup attitudes. This might be due to the aggregation within the participants or the small sample size of between participant data. Nonetheless, the aggregated data does not support the notion that simply having more interactions with an outgroup results in more positive outgroup attitudes.

```{r workerModelOlsAttFreqQual, include=FALSE}
# create list to store Worker models
mdlWorker <- list()

# regression
mdlWorker$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtWorkerSupp$workerAvFreQual)
# summary(lmWorkerAttFreqQualX)

summ(
  mdlWorker$lmAttFreqQualX,
  confint = TRUE,
  digits = 3
)

mdlWorker$lmAttFreqQualXEta <-
  effectsize::eta_squared(mdlWorker$lmAttFreqQualX, partial = TRUE)

interactions::interact_plot(
  mdlWorker$lmAttFreqQualX,
  pred = AvQuality_c,
  modx = SumContactNL_c,
  interval = TRUE,
  partial.residuals = TRUE
)

interactions::johnson_neyman(mdlWorker$lmAttFreqQualX,
                             pred = AvQuality_c,
                             modx = SumContactNL_c,
                             alpha = .05)

```

However, despite the missing relationship with the number of interactions, we find a medium sized correlation between the participants' Average Interaction Quality and their Average Outgroup Attitudes. Thus within our data participants with a higher quality outgroup interactions also held more positive attitudes towards that group. And when considering the number of interactions and average interaction quality jointly in a linear regression, we additionally find a statistically significant interaction term (\textit{b} = `r coef(summary(mdlWorker$lmAttFreqQualX))["SumContactNL_c:AvQuality_c","Estimate"] %>% round(2) %>% format(nsmall=2)`, \textit{t}(`r mdlWorker$lmAttFreqQualX$df.residual`) = `r coef(summary(mdlWorker$lmAttFreqQualX))["SumContactNL_c:AvQuality_c","t value"] %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r coef(summary(mdlWorker$lmAttFreqQualX))["SumContactNL_c:AvQuality_c","Pr(>|t|)"] %>% round(3) %>% format(nsmall=3)`, $\eta_p^2$ = `r mdlWorker$lmAttFreqQualXEta %>% filter(Parameter == "SumContactNL_c:AvQuality_c") %>% select(Eta2_partial) %>% as.numeric %>% round(2) %>% format(nsmall=2)`). Looking at a floodlight analysis of the effect, we find that in our sample with an increasing number of interactions the positive effect of average interaction quality becomes weaker. However, it should be noted that this is based on data aggregating all within participant nuances and is only the date of 21 people. 

```{r workerModelMLAttNull, include=FALSE}
# Create and save Model
mdlWorker$lmerAttNull <-
  lme4::lmer(thermometerDutch_1 ~ 1 + (1 | PID),
    data = dtWorker$full
  ) # use optim if it does not converge

mdlWorker$lmeAttNull <-
  lme(
    thermometerDutch_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorker$full,
    na.action=na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(lmerWorkerAttNull) #or with the lme function
summ(mdlWorker$lmerAttNull, digits = 3, center = TRUE)

# Save variances
mdlWorker$varAttNull <- 
  VarCorr(mdlWorker$lmeAttNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorker$tauAttNull <- 
  as.numeric(mdlWorker$varAttNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorker$sigmaAttNull <- 
  as.numeric(mdlWorker$varAttNull[2])
# The ICC estimate (between/between+within) is:
mdlWorker$IccAttNull <-
  (as.numeric(mdlWorker$varAttNull[1]) / (as.numeric(mdlWorker$varAttNull[1]) + as.numeric(mdlWorker$varAttNull[2])))
mdlWorker$IccPercAttNull <-
  ((as.numeric(mdlWorker$varAttNull[1]) / (as.numeric(mdlWorker$varAttNull[1]) + as.numeric(mdlWorker$varAttNull[2])))) * 100
```
```{r workerModelInterceptAttType, include=FALSE}
# Create and save Model
mdlWorker$lmeInterceptAttType <-
  lme(
    thermometerDutch_1 ~ OutgroupInteraction + NonOutgroupInteraction,
    random =  ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerInteractionType
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorker$lmerInterceptAttType <- lmer(
    thermometerDutch_1 ~ OutgroupInteraction + NonOutgroupInteraction + (1 | PID),
    data = dtWorkerSupp$workerInteractionType
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlWorker$lmerInterceptAttTypeCI <- 
  confint(method = "Wald", mdlWorker$lmerInterceptAttType)

# Compare new model to previous step
anova(mdlWorker$lmeAttNull, 
      mdlWorker$lmeInterceptAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorker$varInterceptAttType <- 
  lme4::VarCorr(mdlWorker$lmeInterceptAttType)
```

We additionally used a multilevel regression to check whether having an interaction with an outgroup member had a situational (i.e., contemporaneous) effect within the participants. We find that having an outgroup interaction is indeed associated with significantly more positive outgroup attitudes within the participants (`r MlCoeffLatex(lmeMdl = mdlWorker$lmeInterceptAttType, lmerCI = mdlWorker$lmerInterceptAttTypeCI, varName = "OutgroupInteractionYes")`), even after controlling for having an interaction with a non-Dutch (which did not relate to outgroup attitudes independently; For full results see Online Supplementary Materials B)\footnote{Interestingly, adding random slopes to this model did not explain additional variance. This is unusual and might indicate the the effect is very consistent across participants. However, the small number of participants, or other measurement issues provide an alternative explanation}. Thus, in our first data we find mixed results, where outgroup contacts show a positive effect on outgroup attitudes in the moment but these results do not translate into average differences between participants, keeping in mind that the between-participant analyses in the aggregated form are based in a small sample size.

\subsubsection{Core Need}The main proposal of our article is that the success of an outgroup interaction might be explained by whether or not the interaction fulfilled the person's core situational need. This should, in turn, be due to a higher perceived interaction quality. We will sequentially test whether the fulfillment of the core need during an interaction is (1) related to more positive outgroup attitudes, (2) higher perceived interaction quality, and (3) whether the variance explained by the core need is assumed by the perceived interaction quality if considered jointly. 

```{r workerOutModelMLAttNull, include=FALSE}
# create empty list to organize models
mdlWorkerOut <- 
  list(
    Att = list(),
    Qlt = list()
  )

# Create and save Model
mdlWorkerOut$Att$lmerNull <-
  lme4::lmer(thermometerDutch_1 ~ 1 + (1 | PID), 
             data = dtWorkerSupp$workerOutgroupInteraction) # use optim if it does not converge
mdlWorkerOut$Att$lmeNull <-
  lme(
    thermometerDutch_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutgroupInteraction,
    na.action=na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.ML.r) #or with the lme function
summ(mdlWorkerOut$Att$lmerNull, digits = 3, center = TRUE)

# Save variances
mdlWorkerOut$Att$varNull <- 
  VarCorr(mdlWorkerOut$Att$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorkerOut$Att$tauNull <- 
  as.numeric(mdlWorkerOut$Att$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorkerOut$Att$sigmaNull <- 
  as.numeric(mdlWorkerOut$Att$varNull[2])
# The ICC estimate (between/between+within) is:
mdlWorkerOut$Att$IccNull <-
  (as.numeric(mdlWorkerOut$Att$varNull[1]) / (as.numeric(mdlWorkerOut$Att$varNull[1]) + as.numeric(mdlWorkerOut$Att$varNull[2])))
mdlWorkerOut$Att$IccPercNull <-
  ((as.numeric(mdlWorkerOut$Att$varNull[1]) / (as.numeric(mdlWorkerOut$Att$varNull[1]) + as.numeric(mdlWorkerOut$Att$varNull[2])))) * 100
```
```{r workerOutModelInterceptAttCore, include=FALSE}
# Create and save Model
mdlWorkerOut$Att$lmeInterceptCore <-
  lme(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc,
    random = ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Att$lmerInterceptCore <-
    lmer(
      thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + (1 | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlWorkerOut$Att$lmerInterceptCoreCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerInterceptCore)

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeNull, 
      mdlWorkerOut$Att$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varInterceptCore <-
  lme4::VarCorr(mdlWorkerOut$Att$lmeInterceptCore)

# The estimate of between-group (or Intercept variance) explained:
# Variance Explained = 1 – (Var with Predictor/Var without Predictor)
mdlWorkerOut$Att$varBtwInterceptCore <-
  1 - (mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["(Intercept)", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varBtwPercInterceptCore <-
  (1 - (mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["(Intercept)", "Variance"] %>% as.numeric)) * 100
# and the estimate of within-group (or residual variance) explained is:
mdlWorkerOut$Att$varWithinInterceptCore <-
  1 - (mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["Residual", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varWithinPercInterceptCore <-
  (1 - (mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["Residual", "Variance"] %>% as.numeric)) * 100
```
```{r workerOutModelSlopesAttCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesCore <-
  lme(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesCore <- lmer(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc +
      (1 + keymotive_fulfillemt_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# all variables standardized within PPT
summ(
  mdlWorkerOut$Att$lmerSlopesCoreZ <- lmer(
    thermometerDutch_1_zwc ~
      keymotive_fulfillemt_1_zwc +
      (1 + keymotive_fulfillemt_1_zwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# standardized coefficients
stdCoef.merMod(mdlWorkerOut$Att$lmerSlopesCore)

# 95%CIs
mdlWorkerOut$Att$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerSlopesCore)

# Attempts at R^2
r2mlm::r2mlm(mdlWorkerOut$Att$lmerSlopesCore, bargraph = TRUE)
mitml::multilevelR2(mdlWorkerOut$Att$lmerSlopesCore)
performance::r2(mdlWorkerOut$Att$lmerSlopesCore)
performance::model_performance(mdlWorkerOut$Att$lmerSlopesCore)
performance::compare_performance(mdlWorkerOut$Att$lmerNull, 
                                 mdlWorkerOut$Att$lmerInterceptCore, 
                                 mdlWorkerOut$Att$lmerSlopesCore)

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeNull, 
      mdlWorkerOut$Att$lmeInterceptCore, 
      mdlWorkerOut$Att$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varSlopesCore <- 
  lme4::VarCorr(mdlWorkerOut$Att$lmeSlopesCore)

# The estimate of between-group (or Intercept variance) explained:
# Variance Explained = 1 – (Var with Predictor/Var without Predictor)
mdlWorkerOut$Att$varBtwSlopesCore <-
  1 - (mdlWorkerOut$Att$varSlopesCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varBtwPercSlopesCore <-
  (1 - (mdlWorkerOut$Att$varSlopesCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric)) * 100
# and the estimate of within-group (or residual variance) explained is:
mdlWorkerOut$Att$varWithinSlopesCore <-
  1 - (mdlWorkerOut$Att$varSlopesCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varWithinPercSlopesCore <-
  (1 - (mdlWorkerOut$Att$varSlopesCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric)) * 100

# Assumption Checks:
mdlWorkerOut$Att$diagSlopesCore <- 
  sjPlot::plot_model(mdlWorkerOut$Att$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlWorkerOut$Att$diagSlopesCore[[1]],
  mdlWorkerOut$Att$diagSlopesCore[[2]]$`PID`,
  mdlWorkerOut$Att$diagSlopesCore[[3]],
  mdlWorkerOut$Att$diagSlopesCore[[4]]
)

# Plot prediction model
mdlWorkerOut$Att$predSlopesCore <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  select(thermometerDutch_1, session, PID) %>% 
  mutate(measure = predict(mdlWorkerOut$Att$lmeSlopesCore,
                           dtWorkerSupp$workerOutWithinBetween,
                           re.form = NA
                           )
         )

(
  mdlWorkerOut$Att$predPltSlopesCore <-
    ggplot(data = mdlWorkerOut$Att$predSlopesCore, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/WorkerOut_PredictionPlot_SlopesAttCore.png",
  mdlWorkerOut$Att$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

```{r workerOutModelMLQltNull, include=FALSE}
# Create and save Model
mdlWorkerOut$Qlt$lmerNull <-
  lme4::lmer(quality_overall_1 ~ 1 + (1 | PID), 
             data = dtWorkerSupp$workerOutWithinBetween) # use optim if it does not converge
mdlWorkerOut$Qlt$lmeNull <-
  mdlWorkerOut$Qlt$lmeNull <-lme(
    quality_overall_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action=na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.Qual.ML.r) #or with the lme function
summ(mdlWorkerOut$Qlt$lmerNull, digits = 3)

# Save variances
mdlWorkerOut$Qlt$varNull <- 
  VarCorr(mdlWorkerOut$Qlt$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorkerOut$Qlt$tauNull <- 
  as.numeric(mdlWorkerOut$Qlt$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorkerOut$Qlt$sigmaNull <- 
  as.numeric(mdlWorkerOut$Qlt$varNull[2])
# The ICC estimate (between/between+within) is:
mdlWorkerOut$Qlt$IccNull <-
  (as.numeric(mdlWorkerOut$Qlt$varNull[1]) / (as.numeric(mdlWorkerOut$Qlt$varNull[1]) + as.numeric(mdlWorkerOut$Qlt$varNull[2])))
mdlWorkerOut$Qlt$IccPercNull <-
  ((as.numeric(mdlWorkerOut$Qlt$varNull[1]) / (as.numeric(mdlWorkerOut$Qlt$varNull[1]) + as.numeric(mdlWorkerOut$Qlt$varNull[2])))) * 100
```
```{r workerOutModelInterceptQltCore, include=FALSE}
# Create and save Model
mdlWorkerOut$Qlt$lmeInterceptCore <-
  lme(
    quality_overall_1 ~ keymotive_fulfillemt_1_cwc,
    random = ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Qlt$lmerInterceptCore <-
    lmer(
      quality_overall_1 ~ keymotive_fulfillemt_1_cwc + (1 | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlWorkerOut$Qlt$lmerInterceptCoreCI <- 
  confint(method = "Wald", mdlWorkerOut$Qlt$lmerInterceptCore)

# Compare new model to previous step
anova(mdlWorkerOut$Qlt$lmeNull, 
      mdlWorkerOut$Qlt$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Qlt$varInterceptCore <-
  lme4::VarCorr(mdlWorkerOut$Qlt$lmeInterceptCore)
```
```{r workerOutModelSlopesQltCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Qlt$lmeSlopesCore <-
  lme(
    quality_overall_1 ~
      keymotive_fulfillemt_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Qlt$lmerSlopesCore <-
    lmer(
      quality_overall_1 ~
        keymotive_fulfillemt_1_cwc +
        (1 + keymotive_fulfillemt_1_cwc | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlWorkerOut$Qlt$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlWorkerOut$Qlt$lmerSlopesCore)

# Compare new model to previous step
anova(mdlWorkerOut$Qlt$lmeNull, 
      mdlWorkerOut$Qlt$lmeInterceptCore, 
      mdlWorkerOut$Qlt$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Qlt$varSlopesCore <- 
  lme4::VarCorr(mdlWorkerOut$Qlt$lmeSlopesCore)
```
```{r workerOutModelInterceptAttCoreQlt, include=FALSE}
# Create and save Model
mdlWorkerOut$Att$lmeInterceptCoreQlt <-
  lme(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + quality_overall_1_cwc,
    random = ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Att$lmerInterceptCoreQlt <-
    lmer(
      thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + quality_overall_1_cwc + (1 | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

mdlWorkerOut$Att$lmerInterceptCoreQltCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerInterceptCoreQlt)

# Compare new model to previous step
anova(
  mdlWorkerOut$Att$lmeNull, 
  mdlWorkerOut$Att$lmeInterceptCoreQlt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varInterceptCoreQlt <-
  lme4::VarCorr(mdlWorkerOut$Att$lmeInterceptCoreQlt)
```
```{r workerOutModelSlopesAttCoreQlt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesCoreQlt <-
  lme(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + quality_overall_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc + quality_overall_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesCoreQlt <- lmer(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + quality_overall_1_cwc +
      (1 + keymotive_fulfillemt_1_cwc + quality_overall_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlWorkerOut$Att$lmerSlopesCoreQltCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerSlopesCoreQlt)

# Compare new model to previous step
anova(
  mdlWorkerOut$Att$lmeNull,
  mdlWorkerOut$Att$lmeInterceptCoreQlt,
  mdlWorkerOut$Att$lmeSlopesCoreQlt
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varSlopesCoreQlt <- 
  lme4::VarCorr(mdlWorkerOut$Att$lmeSlopesCoreQlt)

# Assumption Checks:
mdlWorkerOut$Att$diagSlopesCoreQlt <- 
  sjPlot::plot_model(mdlWorkerOut$Att$lmerSlopesCoreQlt, type = "diag")
grid.arrange(
  mdlWorkerOut$Att$diagSlopesCoreQlt[[1]],
  mdlWorkerOut$Att$diagSlopesCoreQlt[[2]]$`PID`,
  mdlWorkerOut$Att$diagSlopesCoreQlt[[3]],
  mdlWorkerOut$Att$diagSlopesCoreQlt[[4]]
)

# Plot prediction model
mdlWorkerOut$Att$predSlopesCoreQlt <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  select(thermometerDutch_1, session, PID) %>% 
  mutate(measure = predict(mdlWorkerOut$Att$lmeSlopesCoreQlt,
                           dtWorkerSupp$workerOutWithinBetween,
                           re.form = NA
                           )
         )

(
  mdlWorkerOut$Att$predPltSlopesCoreQlt <-
    ggplot(data = mdlWorkerOut$Att$predSlopesCoreQlt, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/WorkerOut_PredictionPlot_SlopesAttCoreQlt.png",
  mdlWorkerOut$Att$predPltSlopesCoreQlt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We find that in the highest multilevel models, the fulfillment of core situational needs during outgroup contacts was associated with more positive outgroup attitudes (random slopes model; `r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCore, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreCI, varName = "keymotive_fulfillemt_1_cwc")`) and also predicted higher perceived interaction quality (random intercept model; `r MlCoeffLatex(lmeMdl = mdlWorkerOut$Qlt$lmeInterceptCore, lmerCI = mdlWorkerOut$Qlt$lmerInterceptCoreCI, varName = "keymotive_fulfillemt_1_cwc")`). Moreover, when we consider the influences of core need fulfillment and interaction quality on outgroup attitudes jointly, we find that virtually all variance is explained by perceived interaction quality (random slopes mode; `r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreQlt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreQltCI, varName = "quality_overall_1_cwc")`) and only little unique variance is still explained by core need fulfillment (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreQlt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreQltCI, varName = "keymotive_fulfillemt_1_cwc")`). We thus find support for our hypotheses and can conclude that in this data set the fulfillment of core situational needs had a significant influence on outgroup attitudes; this effect likely being explained by its effect through perceived interaction quality. 

\faQuestionCircle\ Are we sure that we don't want some sort of bootstrapped indirect effect? 

\subsubsection{Robustness}
```{r workerModelInterceptAttCoreInt, include=FALSE}
# Create and save Model
mdlWorker$lmeInterceptAttCoreInt <-
  lme(
    thermometerDutch_1 ~ keyMotiveFulfilled_cwc * OutgroupInteraction,
    random =  ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorker$lmerInterceptAttCoreInt <- lmer(
    thermometerDutch_1 ~ keyMotiveFulfilled_cwc * OutgroupInteraction + (1 | PID),
    data = dtWorkerSupp$workerWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlWorker$lmerInterceptAttCoreIntCI <- 
  confint(method = "Wald", mdlWorker$lmerInterceptAttCoreInt)

# Compare new model to previous step
anova(mdlWorker$lmeAttNull, 
      mdlWorker$lmeInterceptAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorker$varInterceptAttCoreInt <- 
  lme4::VarCorr(mdlWorker$lmeInterceptAttCoreInt)
```
```{r workerModelSlopesAttCoreIntX, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorker$lmeSlopesAttCoreInt <- lme(
  thermometerDutch_1 ~
    keyMotiveFulfilled_cwc * OutgroupInteraction,
  random = ~ 1 + keyMotiveFulfilled_cwc + OutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  na.action=na.omit,
  data = dtWorkerSupp$workerWithinBetween
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorker$lmerSlopesAttCoreInt <- lmer(
    thermometerDutch_1 ~
      keyMotiveFulfilled_cwc * OutgroupInteraction +
      (1 + keyMotiveFulfilled_cwc + OutgroupInteraction | PID),
    data = dtWorkerSupp$workerWithinBetween
  ), 
  confint = TRUE,
  digits = 3
)

mdlWorker$lmerSlopesAttCoreIntCI <- 
  confint(method = "Wald", mdlWorker$lmerSlopesAttCoreInt)

# Compare new model to previous step
anova(mdlWorker$lmeAttNull, 
      mdlWorker$lmeInterceptAttCoreInt,
      mdlWorker$lmeSlopesAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorker$varSlopesAttCoreInt <- 
  lme4::VarCorr(mdlWorker$lmeSlopesAttCoreInt)

# Assumption Checks:
mdlWorker$diagSlopesAttCoreInt <-
  sjPlot::plot_model(mdlWorker$lmerSlopesAttCoreInt, type = "diag")
grid.arrange(
  mdlWorker$diagSlopesAttCoreInt[[1]],
  mdlWorker$diagSlopesAttCoreInt[[2]]$`PID`,
  mdlWorker$diagSlopesAttCoreInt[[3]],
  mdlWorker$diagSlopesAttCoreInt[[4]]
)

# Plot prediction model
mdlWorker$predSlopesAttCoreInt <- 
  dtWorkerSupp$workerWithinBetween %>%
  select(thermometerDutch_1, session, PID) %>% 
  mutate(measure = predict(mdlWorker$lmeSlopesAttCoreInt,
                           dtWorkerSupp$workerWithinBetween,
                           re.form = NA
                           )
         )

(
  mdlWorker$predPltSlopesAttCoreInt <-
    ggplot(data = mdlWorker$predSlopesAttCoreInt, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Worker_PredictionPlot_SlopesAttCoreInt.png",
  mdlWorker$predPltSlopesAttCoreInt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

To build further confidence in our results, we assessed two additional models that might offer alternative explanations. First, to ensure that the effect of core need fulfillment is specific to an actual interaction, we compared it core need fulfillement in situations without an interaction. For this, we analyzed the generalized situational core need fulfillment (either during an interaction or about the daytime in general) and tested whether the effect differed during daily diary measurements with and without outgroup contacts. We found no main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlWorker$lmeSlopesAttCoreInt, lmerCI = mdlWorker$lmerSlopesAttCoreIntCI, varName = "keyMotiveFulfilled_cwc")`) but a significant interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlWorker$lmeSlopesAttCoreInt, lmerCI = mdlWorker$lmerSlopesAttCoreIntCI, varName = "keyMotiveFulfilled_cwc:OutgroupInteraction")`). Together with a significant main effect of having an outgroup contact, this indicates that it is not key need fulfillment in general --- but only key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. 

```{r workerOutModelInterceptAttCoreSdt, include=FALSE}
# Create and save Model
mdlWorkerOut$Att$lmeInterceptCoreSdt <-
  lme(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Att$lmerInterceptCoreSdt <- lmer(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc + (1 | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# To be compared against a model with only the self determination theory needs
mdlWorkerOut$Att$lmeInterceptSdt <-
  lme(
    thermometerDutch_1 ~ competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

summ(
  mdlWorkerOut$Att$lmerInterceptSdt <- lmer(
    thermometerDutch_1 ~ competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc + (1 | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous steps
anova(
  mdlWorkerOut$Att$lmeInterceptSdt,
  mdlWorkerOut$Att$lmeInterceptCoreSdt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")
rm(lmeInterceptCoreRed)

# Save variances
mdlWorkerOut$Att$varInterceptCoreSdt <-
  lme4::VarCorr(mdlWorkerOut$Att$lmeInterceptCoreSdt)
```
```{r workerOutModelSlopesAttCoreSdt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesCoreSdt <-
  lme(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesCoreSdt <- lmer(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc +
      (1 + keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlWorkerOut$Att$lmerSlopesCoreSdtCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerSlopesCoreSdt)

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeInterceptSdt,
      mdlWorkerOut$Att$lmeInterceptCoreSdt, 
      mdlWorkerOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# model with SDT only
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesSdt <-
  lme(
    thermometerDutch_1 ~
      competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesSdt <- lmer(
    thermometerDutch_1 ~
      competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc +
      (1 + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeInterceptSdt,
      mdlWorkerOut$Att$lmeSlopesSdt, 
      mdlWorkerOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")


# Save variances
mdlWorkerOut$Att$varSlopesCoreSdt <- 
  lme4::VarCorr(mdlWorkerOut$Att$lmeSlopesCoreSdt)

# Assumption Checks:
mdlWorkerOut$Att$diagSlopesCoreSdt <- 
  sjPlot::plot_model(mdlWorkerOut$Att$lmerSlopesCoreSdt, type = "diag")
grid.arrange(
  mdlWorkerOut$Att$diagSlopesCoreSdt[[1]],
  mdlWorkerOut$Att$diagSlopesCoreSdt[[2]]$`PID`,
  mdlWorkerOut$Att$diagSlopesCoreSdt[[3]],
  mdlWorkerOut$Att$diagSlopesCoreSdt[[4]]
)

# Plot prediction model
mdlWorkerOut$Att$predSlopesCoreSdt <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  filter(!is.na(autonomy_1)) %>%
  select(thermometerDutch_1, session, PID, autonomy_1) %>% 
  mutate(measure = predict(mdlWorkerOut$Att$lmeSlopesCoreSdt,
                           dtWorkerSupp$workerOutWithinBetween %>% filter(!is.na(autonomy_1)),
                           re.form = NA
                           )
         )

(
  mdlWorkerOut$Att$predPltSlopesCoreSdt <-
    ggplot(data = mdlWorkerOut$Att$predSlopesCoreSdt, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/WorkerOut_PredictionPlot_SlopesAttCoreStd.png",
  mdlWorkerOut$Att$predPltSlopesCoreSdt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

# Model comparison
workerSdtComp <-
  anova(
    mdlWorkerOut$Att$lmerSlopesSdt, 
    mdlWorkerOut$Att$lmerSlopesCoreSdt
  ) %>%
  as.data.frame()
workerSdtCompDf <- workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Df"]
workerSdtCompN <- sapply(ranef(mdlWorkerOut$Att$lmerSlopesCoreSdt), nrow)
workerSdtCompChi <- workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2)
workerSdtCompP <-
  ifelse(workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001,
         "< .001",
         paste0("= ", workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3)))

workerSdtCompChiSq <- paste0("$\\chi^2$(", workerSdtCompDf, ", \\textit{N} = ", workerSdtCompN, ") = ", workerSdtCompChi, ", \\textit{p} ", workerSdtCompP)
```

In a final step, we controlled for other fundamental psychological needs during the interaction. We focus on the three commonly considered self determination needs: competence, autonomy, and relatedness. We find that the core need adds significantly above a model with only the self determination theory needs (random slopes models; `r workerSdtCompChiSq`). We find that next to relatedness (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreSdt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreSdtCI, varName = "relatedness_1_cwc")`), the core need explains the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreSdt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreSdtCI, varName = "keymotive_fulfillemt_1_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all three fundamental needs (competence and autonomy needs turning non-significant; all \textit{b} < `r coef(summary(mdlWorkerOut$Att$lmeSlopesCoreSdt))[c("competence_1_cwc", "autonomy_1_cwc"),"Value"] %>% max %>% round(2) %>% format(nsmall=2)`, all \textit{p} > `r coef(summary(mdlWorkerOut$Att$lmeSlopesCoreSdt))[c("competence_1_cwc", "autonomy_1_cwc"),"p-value"] %>% min %>% round(3) %>% format(nsmall=3)`). For full results see Online Supplementary Information B.

\section{Study 2}

The aim of Study 2 is similar to Study 1, as we again test the general contact hypothesis, the influence of core need fulfillment, and perceived interaction quality during intergroup contacts. However, in this second study we collected a substantially larger sample of international students who recently arrived in the Netherlands and also improved the study design (e.g. pop up explanations described later). The survey method again offers a large body of ecologically valid data on need satisfaction in real-life intergroup contact situations as these students will likely interact with the Dutch majority outgroup on a daily basis. Data was collected from November 19th, 2018 through January 6th, 2019.

The full surveys are available in our Online Supplementary Material A and the full data description is available in Online Supplementary Materials B. Correlations and descriptive statistics of the included variables are available in Table \ref{tab:studentVarDescr} and Table \ref{tab:studentOutVarDescr}.

\subsection{Methods}

```{r studentSampleInfo, include=FALSE}
# summarize participant characteristics
studentSampleInfo <- 
  dtStudents$full %>%
  mutate(gender = as.factor(ifelse(.$Gender == 1, "women", ifelse(.$Gender == 2, "man", ifelse(.$Gender == 3, "other", NA))))) %>%
  group_by(PID) %>%
  summarise(
    dailiesN = n(), 
    morningN = sum(periodMA=="morning"),
    afternoonN = sum(periodMA=="afternoon"),
    age = age,
    gender = gender,
    nationality = nationality
  ) %>%
  distinct

# look at frequencies of characteristics 
table(studentSampleInfo$gender)
table(as.character(studentSampleInfo$nationality))

# categorical variables:
# - outgroup contact
# - non-outgroup contact

# continuous variables:
# - Core Need fulfillment
# - SDT Competence
# - SDT Autonomy
# - SDT Relatedness
# - Interaction Quality
# - Outgroup Attitudes
######
# within cor
# between cor
# ---
# Grand mean
# SD between
# SD within
# Proportion of variance
# __ __ __
# Note:
# N within ppt.s 
######

# divide into trait and state
dtStudentSupp$studentWithinBetween <-
  MlTraitState(
    data = dtStudentSupp$studentInteractionType,
    id = "PID",
    selection =
      c(
        "KeyNeedFullfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AttitudesDutch",
        "quality_overall",
        "OutgroupInteraction",
        "NonOutgroupInteraction"
      )
  )
dtStudentSupp$studentOutWithinBetween <-
  MlTraitState(
    data = dtStudentSupp$studentInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection =
      c(
        "KeyNeedFullfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AttitudesDutch",
        "quality_overall"
      )
  )
```

```{r studentVarDescr, include=FALSE}
studentMlCor <-
  MlCorMat(
    data = dtStudentSupp$studentInteractionType,
    id = "PID",
    selection = c("KeyNeedFullfillment", "Competence", "Autonomy", "Relatedness", "quality_overall", "AttitudesDutch"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Quality", "Attitudes NL")
  ) 

studentMlCor %>%
  kable(
    .,
    caption = "Student: Multilevel Core Variable Descriptives",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/studentVarDescr.tex")
```

```{r studentOutVarDescr, include=FALSE}
studentOutMlCor <-
  MlCorMat(
    data = dtStudentSupp$studentInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection = c("KeyNeedFullfillment", "Competence", "Autonomy", "Relatedness", "quality_overall", "AttitudesDutch"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Quality", "Attitudes NL")
  )

studentOutMlCor %>%
  kable(
    .,
    caption = "Student: Multilevel Core Variable Descriptives (Outgroup Contact Only)",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/studentOutVarDescr.tex")

# misty::multilevel.descript(dtStudentsSupp$studentWithinBetween$keyMotiveFulfilled, cluster = dtStudentsSupp$studentWithinBetween$PID)
```

\subsubsection{Participants} After receiving ethical approval from the University of Groningen, we recruited `r nrow(studentSampleInfo)` international students using a local participant pool. We specifically targeted non-Dutch students, who had recently arrived in the Netherlands. Participants reported on their interactions for at least 30 days with two daily measures (capturing the morning and afternoon). With this design, we aimed at getting 50-60 measurements per participant (\textit{M} = `r format(round(mean(studentSampleInfo$dailiesN),2), nsmall=2)`, \textit{SD} = `r format(round(sd(studentSampleInfo$dailiesN),2), nsmall=2)`, \textit{total N} = `r sum(studentSampleInfo$dailiesN)`). As with the previous study this should offer sufficient power to model processes within participants and will lend stronger weight to between-participant results. Participants were compensated for their participation with partial course credits --- depending on their participation. The sample consisted of relatively young migrants, who were mostly from the global north ($M_{age}$ = `r format(round(mean(studentSampleInfo$age),2), nsmall=2)`, $SD_{age}$ = `r format(round(sd(studentSampleInfo$age),2), nsmall=2)`, `r nrow(studentSampleInfo %>% filter(gender == "women"))` women). The sample fairly accurately describes the local population of international students.

\subsubsection{Procedure} The study procedure mirrored the setup of study one and consisted of pre-, daily diary-, and post-measurement. The participants were invited for daily diary measurements twice a day (at 12 pm and 7pm) for 30 days (\textit{median duration} = `r seconds_to_period(median(difftime(dtStudents$clean$ended.daily, dtStudents$clean$created.daily))) %>% as.character`, \textit{MAD duration} = `r seconds_to_period(round(mad(difftime(dtStudents$clean$ended.daily, dtStudents$clean$created.daily)))) %>% as.character`).  General compliance was high (`r format(round(sum(studentSampleInfo$dailiesN)/(nrow(studentSampleInfo)*62)*100,2), nsmall=2)`\% of all invited surveys were filled in). The response rates were approximately equal during mornings (\textit{n} = `r sum(studentSampleInfo$morningN)`) and afternoons (\textit{n} = `r sum(studentSampleInfo$afternoonN)`). All key variables for this study were part of the short daily diary surveys. 

\subsubsection{Materials}

\paragraph{Intergroup Contact}To measure intergroup contacts, every experience sampling measurement started with the question “\textit{Did you meet a Dutch person this morning [/afternoon]? (in-person interaction for at least 10 minutes)}”. Participants were additionally offered a pop-up explanation: "With in-person interaction, we mean a continued interaction with another person (potentially in a group) that lasted at least 10 minutes. This interaction should be offline and face-to-face. It should include some form of verbal communication and should be uninterrupted to still count as the same interaction. Any individual interaction can last minutes or hours. If there were multiple interaction partners, we would like you to focus on the person that was most important to you during the interaction.". The participants recorded between `r dtStudentSupp$studentContactFreq$SumContactNL[dtStudentSupp$studentContactFreq$SumContactNL > 0] %>% min`--`r dtStudentSupp$studentContactFreq$SumContactNL %>% max`
(`r dtStudentSupp$studentContactFreq$PercContactNL[dtStudentSupp$studentContactFreq$PercContactNL > 0] %>% min %>% round(2) %>% format(nsmall=2)`--`r dtStudentSupp$studentContactFreq$PercContactNL %>% max %>% round(2) %>% format(nsmall=2)`\% of individual daily diary measurements; `r (sum(dtStudentSupp$studentContactFreq$SumContactNL) / nrow(dtStudentSupp$studentInteractionType) * 100) %>% round(2) %>% format(nsmall=2)`\% of all `r nrow(dtStudentSupp$studentInteractionType)` daily diary responses). 

\paragraph{Psychological Needs}For the core situational need, we asked participants in an open ended text field: “\textit{What was your main goal [during the interaction with X / this morning / this afternoon]?}”. Participants could additionally click on a pop-up explanation: "Your main goal during an interaction can vary depending on the interaction. It could be to connect with friends, to find or provide help, to achieve academic ambitions, work on your fitness, work for a job, or simply to get a coffee, just as well as many many other concrete or abstract goals that are import to you in the moment. It really depends on your subjective experience of the interaction.". Then, with reference to the text entry, we asked how much this core need was fulfilled during the interaction or the past daytime period: “\textit{During your interaction with X [this morning / this evening] your goal (-previous text entry-) was fulfilled.}” on a continuous slider scale ranging from strongly disagree (1) to strongly agree (100).

The measurement of the self determination needs was identical to study 1. 

\paragraph{Perceived Interaction Quality}The ratings of the perceived interaction quality was identical to study one.

\paragraph{Outgroup Attitudes}As in Study 1, attitudes towards the Dutch majority outgroup were again measured using the feeling thermometer. All survey details are also available in Online Supplemental Materials A and B. 

\input{Tables/studentVarDescr}
\input{Tables/studentOutVarDescr}

\subsection{Results}

```{r studentFreqAttCor, include=FALSE}

dtStudentSupp$studentContactFreq <-
  dtStudentSupp$studentContactFreq %>%
  mutate(
    SumContactNL_c = SumContactNL - mean(SumContactNL, na.rm = TRUE),
    SumContactNLAll_c = SumContactNLAll - mean(SumContactNLAll, na.rm = TRUE),
    AvAttitude_c = AvAttitude - mean(AvAttitude, na.rm = TRUE),
    AvQuality_c = AvQuality - mean(AvQuality, na.rm = TRUE)
  )

# correlation panel
pairs.panels.new(
  dtStudentSupp$studentContactFreq %>% select(SumContactNL, SumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)",
    "Sum:\nNumber of Outgroup Contacts (NL)",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)

# correlation panel with interaction sums winsorized
pairs.panels.new(
  dtStudentSupp$studentContactFreq %>% select(WinSumContactNL, WinSumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)\n[Winsorized]",
    "Sum:\nNumber of Outgroup Contacts (NL)\n[Winsorized]",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)
```

\subsubsection{Contact Hypothesis}We tested the most general contact hypothesis in two steps. First, we assessed whether more intergroup interactions were related to to more positive outgroup attitudes. Second, we tested whether a potential positive effect on outgroup attitudes depended on the interaction quality (jointly with the number of interactions). We find a significant correlation with average outgroup attitudes for both the total number of outgroup interactions (\textit{r} = `r cor(dtStudentSupp$studentContactFreq$SumContactNLAll, dtStudentSupp$studentContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r cor.test(dtStudentSupp$studentContactFreq$SumContactNLAll, dtStudentSupp$studentContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`) and the number of measurement beeps with an interaction (\textit{r} = `r cor(dtStudentSupp$studentContactFreq$SumContactNL, dtStudentSupp$studentContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r cor.test(dtStudentSupp$studentContactFreq$SumContactNL, dtStudentSupp$studentContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`). This is to say that within our data, participants with more outgroup interactions did have significantly more positive outgroup attitudes. This is inconsistent with the results we found in the first study and might be due to the larger number of participants.  

```{r studentModelOlsAttFreqQual, include=FALSE}
# create list to store Worker models
mdlStudent <- list()

# regression
mdlStudent$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtStudentSupp$studentContactFreq)

summ(
  mdlStudent$lmAttFreqQualX,
  confint = TRUE,
  digits = 3
)

mdlStudent$lmAttFreqQualXEta <-
  effectsize::eta_squared(mdlStudent$lmAttFreqQualX, partial = TRUE)

interactions::interact_plot(
  mdlStudent$lmAttFreqQualX,
  pred = SumContactNL_c,
  modx = AvQuality_c,
  interval = TRUE,
  partial.residuals = TRUE
)

interactions::johnson_neyman(mdlStudent$lmAttFreqQualX,
                             pred = SumContactNL_c,
                             modx = AvQuality_c,
                             alpha = .05)
```

However, we find no significant correlation between the participants' Average Interaction Quality and their Average Outgroup Attitudes (\textit{r} = `r cor(dtStudentSupp$studentContactFreq$AvQuality, dtStudentSupp$studentContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r cor.test(dtStudentSupp$studentContactFreq$AvQuality, dtStudentSupp$studentContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`). Thus, when considering the number of interactions and average interaction quality jointly in a linear regression, we find a main effect of intergroup contacts to predict outgroup attitudes (\textit{b} = `r coef(summary(mdlStudent$lmAttFreqQualX))["SumContactNL_c","Estimate"] %>% round(2) %>% format(nsmall=2)`, \textit{t}(`r mdlStudent$lmAttFreqQualX$df.residual`) = `r coef(summary(mdlStudent$lmAttFreqQualX))["SumContactNL_c","t value"] %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r coef(summary(mdlStudent$lmAttFreqQualX))["SumContactNL_c","Pr(>|t|)"] %>% round(3) %>% format(nsmall=3)`, $\eta_p^2$ = `r mdlStudent$lmAttFreqQualXEta %>% filter(Parameter == "SumContactNL_c") %>% select(Eta2_partial) %>% as.numeric %>% round(2) %>% format(nsmall=2)`). Given the missing aggregate relationship between average interaction quality and outgroup attitudes, we find no significant effect of average perceived contact quality. We also do not find that in this sample the impact of the number of interactions is moderated by the average contact quality. This is not entirely consistent with the first study, where average contact quality did have a meaningful effect on outgroup attitudes. This finding is not necessarily surprising given that the variables aggregate all within person variation and there were substantially more measurements where participants did not have an interaction (but reported their outgroup attitudes) than measurements that followed an outgroup contact.  

```{r studentModelMLAttNull, include=FALSE}
# Create and save Model
mdlStudent$lmerAttNull <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
    data = dtStudents$full
  ) # use optim if it does not converge

mdlStudent$lmeAttNull <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtStudents$full,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(mdlStudent$lmerAttNull) #or with the lme function
summ(mdlStudent$lmerAttNull, digits = 3)

# Save variances
mdlStudent$varAttNull <- 
  VarCorr(mdlStudent$lmeAttNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlStudent$tauAttNull <- 
  as.numeric(mdlStudent$varAttNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlStudent$sigmaAttNull <- 
  as.numeric(mdlStudent$varAttNull[2])
# The ICC estimate (between/between+within) is:
mdlStudent$IccAttNull <-
  (as.numeric(mdlStudent$varAttNull[1]) / (as.numeric(mdlStudent$varAttNull[1]) + as.numeric(mdlStudent$varAttNull[2])))
mdlStudent$IccPercAttNull <-
  ((as.numeric(mdlStudent$varAttNull[1]) / (as.numeric(mdlStudent$varAttNull[1]) + as.numeric(mdlStudent$varAttNull[2])))) * 100
```
```{r studentModelInterceptAttType, include = FALSE}
# Create and save Model
mdlStudent$lmeInterceptAttType <-
  lme(
    AttitudesDutch ~ OutgroupInteraction + NonOutgroupInteraction,
    random =  ~ 1 | PID,
    data = dtStudentSupp$studentInteractionType
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudent$lmerInterceptAttType <- lmer(
    AttitudesDutch ~ OutgroupInteraction + NonOutgroupInteraction + (1 | PID),
    data = dtStudentSupp$studentInteractionType
  ),
  confint = TRUE,
  digits = 3
)

mdlStudent$lmerInterceptAttTypeCI <- 
  confint(method = "Wald", mdlStudent$lmerInterceptAttType)

# Compare new model to previous step
anova(mdlStudent$lmeAttNull, 
      mdlStudent$lmeInterceptAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudent$varInterceptAttType <- 
  lme4::VarCorr(mdlStudent$lmeInterceptAttType)
```
```{r studentModelSlopesInteractionType, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudent$lmeSlopesAttType <- lme(
  AttitudesDutch ~
    OutgroupInteraction + NonOutgroupInteraction,
  random = ~ 1 + OutgroupInteraction + NonOutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  data = dtStudentSupp$studentInteractionType
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudent$lmerSlopesAttType <- lmer(
    AttitudesDutch ~
      OutgroupInteraction + NonOutgroupInteraction +
      (1 + OutgroupInteraction + NonOutgroupInteraction | PID),
    data = dtStudentSupp$studentInteractionType
  ), 
  confint = TRUE,
  digits = 3
)

mdlStudent$lmerSlopesAttTypeCI <- 
  confint(method = "Wald", mdlStudent$lmerSlopesAttType)

# Compare new model to previous step
anova(mdlStudent$lmeAttNull,
      mdlStudent$lmeInterceptAttType, 
      mdlStudent$lmeSlopesAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudent$varSlopesAttType <- 
  lme4::VarCorr(mdlStudent$lmeSlopesAttType)

# Assumption Checks:
mdlStudent$diagSlopesAttType <-
  sjPlot::plot_model(mdlStudent$lmerSlopesAttType, type = "diag")
grid.arrange(
  mdlStudent$diagSlopesAttType[[1]],
  mdlStudent$diagSlopesAttType[[2]]$`PID`,
  mdlStudent$diagSlopesAttType[[3]],
  mdlStudent$diagSlopesAttType[[4]]
)

# Plot prediction model
mdlStudent$predSlopesAttType <- 
  dtStudentSupp$studentInteractionType %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudent$lmeSlopesAttType,
                           dtStudentSupp$studentInteractionType,
                           re.form = NA
                           )
         )

(
  mdlStudent$predPltSlopesAttType <-
    ggplot(data = mdlStudent$predSlopesAttType %>% filter(PID %in% dtStudentSupp$studentPltIDs), 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Student_PredictionPlot_SlopesAttType.png",
  mdlStudent$predPltSlopesAttType,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We additionally used a multilevel regression to check whether having an interaction with an outgroup member had a situational (i.e., contemporaneous) effect within the participants. We find that having an outgroup interaction is indeed associated with significantly more positive outgroup attitudes within the participants (random slopes model; `r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttType, lmerCI = mdlStudent$lmerSlopesAttTypeCI, varName = "OutgroupInteractionYes")`), even after controlling for having an interaction with a non-Dutch person (which did not relate to outgroup attitudes independently; For full results see Online Supplementary Materials B). Thus, in our second dataset we find mixed results, outgroup contacts show a positive effect on outgroup attitudes in the moment and on average between participants. However, we find that this effect does not depend on the average perceived interaction quality. This unexpected results, might be due to the aggregation process and the following analyses will focus in on the role of the perceived interaction quality during an outgroup interaction. 

\subsubsection{Core Need}
```{r studentOutModelMLAttNull, include=FALSE}
# create empty list to organize models
mdlStudentOut <- 
  list(
    Att = list(),
    Qlt = list()
  )

# Create and save Model
mdlStudentOut$Att$lmerNull <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID), 
             data = dtStudentSupp$studentOutgroupInteraction) # use optim if it does not converge
mdlStudentOut$Att$lmeNull <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutgroupInteraction,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.ML.r) #or with the lme function
summ(mdlStudentOut$Att$lmerNull, digits = 3, center = TRUE)

# Save variances
mdlStudentOut$Att$varNull <- 
  VarCorr(mdlStudentOut$Att$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlStudentOut$Att$tauNull <- 
  as.numeric(mdlStudentOut$Att$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlStudentOut$Att$sigmaNull <- 
  as.numeric(mdlStudentOut$Att$varNull[2])
# The ICC estimate (between/between+within) is:
mdlStudentOut$Att$IccNull <-
  (as.numeric(mdlStudentOut$Att$varNull[1]) / (as.numeric(mdlStudentOut$Att$varNull[1]) + as.numeric(mdlStudentOut$Att$varNull[2])))
mdlStudentOut$Att$IccPercNull <-
  ((as.numeric(mdlStudentOut$Att$varNull[1]) / (as.numeric(mdlStudentOut$Att$varNull[1]) + as.numeric(mdlStudentOut$Att$varNull[2])))) * 100
```
```{r studentOutModelInterceptAttCore, include=FALSE}
# Create and save Model
mdlStudentOut$Att$lmeInterceptCore <-
  lme(
    AttitudesDutch ~ KeyNeedFullfillment_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudentOut$Att$lmerInterceptCore <-
    lmer(
      AttitudesDutch ~ KeyNeedFullfillment_cwc + (1 | PID),
      data = dtStudentSupp$studentOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlStudentOut$Att$lmerInterceptCoreCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerInterceptCore)

# Compare new model to previous step
anova(mdlStudentOut$Att$lmeNull, 
      mdlStudentOut$Att$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Att$varInterceptCore <-
  lme4::VarCorr(mdlStudentOut$Att$lmeInterceptCore)
```
```{r studentOutModelSlopesAttCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Att$lmeSlopesCore <-
  lme(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc,
    random = ~ 1 + KeyNeedFullfillment_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Att$lmerSlopesCore <- lmer(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc +
      (1 + KeyNeedFullfillment_cwc | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# all variables standardized within PPT
summ(
  mdlStudentOut$Att$lmerSlopesCoreZ <- lmer(
    AttitudesDutch_zwc ~
      KeyNeedFullfillment_zwc +
      (1 + KeyNeedFullfillment_zwc | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# standardized coefficients
stdCoef.merMod(mdlStudentOut$Att$lmerSlopesCore)

# 95%CIs
mdlStudentOut$Att$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerSlopesCore)

# Attempts at R^2
r2mlm::r2mlm(mdlStudentOut$Att$lmerSlopesCore, bargraph = TRUE)
mitml::multilevelR2(mdlStudentOut$Att$lmerSlopesCore)
performance::r2(mdlStudentOut$Att$lmerSlopesCore)
performance::model_performance(mdlStudentOut$Att$lmerSlopesCore)
performance::compare_performance(mdlStudentOut$Att$lmerNull, 
                                 mdlStudentOut$Att$lmerInterceptCore, 
                                 mdlStudentOut$Att$lmerSlopesCore)

# Compare new model to previous step
anova(mdlStudentOut$Att$lmeNull, 
      mdlStudentOut$Att$lmeInterceptCore, 
      mdlStudentOut$Att$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Att$varSlopesCore <- 
  lme4::VarCorr(mdlStudentOut$Att$lmeSlopesCore)

# Assumption Checks:
mdlStudentOut$Att$diagSlopesCore <- 
  sjPlot::plot_model(mdlStudentOut$Att$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlStudentOut$Att$diagSlopesCore[[1]],
  mdlStudentOut$Att$diagSlopesCore[[2]]$`PID`,
  mdlStudentOut$Att$diagSlopesCore[[3]],
  mdlStudentOut$Att$diagSlopesCore[[4]]
)

# Plot prediction model
mdlStudentOut$Att$predSlopesCore <- 
  dtStudentSupp$studentOutWithinBetween %>% 
  filter(PID %in% dtStudentSupp$studentOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudentOut$Att$lmeSlopesCore,
                           dtStudentSupp$studentOutWithinBetween %>% filter(PID %in% dtStudentSupp$studentOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudentOut$Att$predPltSlopesCore <-
    ggplot(data = mdlStudentOut$Att$predSlopesCore, 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/StudentOut_PredictionPlot_SlopesAttCore.png",
  mdlStudentOut$Att$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

```{r studentOutModelMLQltNull, include=FALSE}
# Create and save Model
mdlStudentOut$Qlt$lmerNull <-
  lme4::lmer(quality_overall ~ 1 + (1 | PID), 
             data = dtStudentSupp$studentOutWithinBetween) # use optim if it does not converge
mdlStudentOut$Qlt$lmeNull <-
  mdlStudentOut$Qlt$lmeNull <-lme(
    quality_overall ~ 1,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.Qual.ML.r) #or with the lme function
summ(mdlStudentOut$Qlt$lmerNull, digits = 3)

# Save variances
mdlStudentOut$Qlt$varNull <- 
  VarCorr(mdlStudentOut$Qlt$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlStudentOut$Qlt$tauNull <- 
  as.numeric(mdlStudentOut$Qlt$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlStudentOut$Qlt$sigmaNull <- 
  as.numeric(mdlStudentOut$Qlt$varNull[2])
# The ICC estimate (between/between+within) is:
mdlStudentOut$Qlt$IccNull <-
  (as.numeric(mdlStudentOut$Qlt$varNull[1]) / (as.numeric(mdlStudentOut$Qlt$varNull[1]) + as.numeric(mdlStudentOut$Qlt$varNull[2])))
mdlStudentOut$Qlt$IccPercNull <-
  ((as.numeric(mdlStudentOut$Qlt$varNull[1]) / (as.numeric(mdlStudentOut$Qlt$varNull[1]) + as.numeric(mdlStudentOut$Qlt$varNull[2])))) * 100
```
```{r studentOutModelInterceptQltCore, include=FALSE}
# Create and save Model
mdlStudentOut$Qlt$lmeInterceptCore <-
  lme(
    quality_overall ~ KeyNeedFullfillment_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudentOut$Qlt$lmerInterceptCore <-
    lmer(
      quality_overall ~ KeyNeedFullfillment_cwc + (1 | PID),
      data = dtStudentSupp$studentOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlStudentOut$Qlt$lmerInterceptCoreCI <- 
  confint(method = "Wald", mdlStudentOut$Qlt$lmerInterceptCore)

# Compare new model to previous step
anova(mdlStudentOut$Qlt$lmeNull, 
      mdlStudentOut$Qlt$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Qlt$varInterceptCore <-
  lme4::VarCorr(mdlStudentOut$Qlt$lmeInterceptCore)
```
```{r studentOutModelSlopesQltCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Qlt$lmeSlopesCore <-
  lme(
    quality_overall ~
      KeyNeedFullfillment_cwc,
    random = ~ 1 + KeyNeedFullfillment_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Qlt$lmerSlopesCore <-
    lmer(
      quality_overall ~
        KeyNeedFullfillment_cwc +
        (1 + KeyNeedFullfillment_cwc | PID),
      data = dtStudentSupp$studentOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlStudentOut$Qlt$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlStudentOut$Qlt$lmerSlopesCore)

# Compare new model to previous step
anova(mdlStudentOut$Qlt$lmeNull, 
      mdlStudentOut$Qlt$lmeInterceptCore, 
      mdlStudentOut$Qlt$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Qlt$varSlopesCore <- 
  lme4::VarCorr(mdlStudentOut$Qlt$lmeSlopesCore)

# Assumption Checks:
mdlStudentOut$Qlt$diagSlopesCore <-
  sjPlot::plot_model(mdlStudentOut$Qlt$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlStudentOut$Qlt$diagSlopesCore[[1]],
  mdlStudentOut$Qlt$diagSlopesCore[[2]]$`PID`,
  mdlStudentOut$Qlt$diagSlopesCore[[3]],
  mdlStudentOut$Qlt$diagSlopesCore[[4]]
)

# Plot prediction model
mdlStudentOut$Qlt$predSlopesCore <- 
  dtStudentSupp$studentOutWithinBetween %>%
  filter(PID %in% dtStudentSupp$studentOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudentOut$Qlt$lmeSlopesCore,
                           dtStudentSupp$studentOutWithinBetween %>% filter(PID %in% dtStudentSupp$studentOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudentOut$Qlt$predPltSlopesCore <-
    ggplot(data = mdlStudentOut$Qlt$predSlopesCore %>% filter(PID %in% dtStudentSupp$studentOutPltIDs), 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/StudentOut_PredictionPlot_SlopesCore.png",
  mdlStudentOut$Qlt$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

```
```{r studentOutModelInterceptAttCoreQlt, include=FALSE}
# Create and save Model
mdlStudentOut$Att$lmeInterceptCoreQlt <-
  lme(
    AttitudesDutch ~ KeyNeedFullfillment_cwc + quality_overall_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudentOut$Att$lmerInterceptCoreQlt <-
    lmer(
      AttitudesDutch ~ KeyNeedFullfillment_cwc + quality_overall_cwc + (1 | PID),
      data = dtStudentSupp$studentOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

mdlStudentOut$Att$lmerInterceptCoreQltCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerInterceptCoreQlt)

# Compare new model to previous step
anova(
  mdlStudentOut$Att$lmeNull, 
  mdlStudentOut$Att$lmeInterceptCoreQlt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Att$varInterceptCoreQlt <-
  lme4::VarCorr(mdlStudentOut$Att$lmeInterceptCoreQlt)
```
```{r studentOutModelSlopesAttCoreQlt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Att$lmeSlopesCoreQlt <-
  lme(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc + quality_overall_cwc,
    random = ~ 1 + KeyNeedFullfillment_cwc + quality_overall_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Att$lmerSlopesCoreQlt <- lmer(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc + quality_overall_cwc +
      (1 + KeyNeedFullfillment_cwc + quality_overall_cwc | PID),
    data = dtStudentSupp$studentOutWithinBetween,
    control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
  ),
  confint = TRUE,
  digits = 3
)

mdlStudentOut$Att$lmerSlopesCoreQltCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerSlopesCoreQlt)

# Compare new model to previous step
anova(
  mdlStudentOut$Att$lmeNull,
  mdlStudentOut$Att$lmeInterceptCoreQlt,
  mdlStudentOut$Att$lmeSlopesCoreQlt
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Att$varSlopesCoreQlt <- 
  lme4::VarCorr(mdlStudentOut$Att$lmeSlopesCoreQlt)

# Assumption Checks:
mdlStudentOut$Att$diagSlopesCoreQlt <- 
  sjPlot::plot_model(mdlStudentOut$Att$lmerSlopesCoreQlt, type = "diag")
grid.arrange(
  mdlStudentOut$Att$diagSlopesCoreQlt[[1]],
  mdlStudentOut$Att$diagSlopesCoreQlt[[2]]$`PID`,
  mdlStudentOut$Att$diagSlopesCoreQlt[[3]],
  mdlStudentOut$Att$diagSlopesCoreQlt[[4]]
)

# Plot prediction model
mdlStudentOut$Att$predSlopesCoreQlt <- 
  dtStudentSupp$studentOutWithinBetween %>% 
  filter(PID %in% dtStudentSupp$studentOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudentOut$Att$lmeSlopesCoreQlt,
                           dtStudentSupp$studentOutWithinBetween %>% filter(PID %in% dtStudentSupp$studentOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudentOut$Att$predPltSlopesCoreQlt <-
    ggplot(data = mdlStudentOut$Att$predSlopesCoreQlt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/StudentOut_PredictionPlot_SlopesAttCoreQlt.png",
  mdlStudentOut$Att$predPltSlopesCoreQlt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We again sequentially tested whether the fulfillment of the core need during an interaction was (1) related to more positive outgroup attitudes, (2) higher perceived interaction quality, and (3) whether the variance explained by the core need is assumed by the perceived interaction quality if considered jointly. We find that in the multilevel models, the fulfillment of core situational needs during outgroup contacts was associated with more positive outgroup attitudes (random slopes model; `r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCore, lmerCI = mdlStudentOut$Att$lmerSlopesCoreCI, varName = "KeyNeedFullfillment_cwc")`) and also predicted higher perceived interaction quality (random slopes model; `r MlCoeffLatex(lmeMdl = mdlStudentOut$Qlt$lmeSlopesCore, lmerCI = mdlStudentOut$Qlt$lmerSlopesCoreCI, varName = "KeyNeedFullfillment_cwc")`). Additionally, if we consider the influences of core need fulfillment and interaction quality on outgroup attitudes jointly, we find that virtually all variance is explained by perceived interaction quality (random slopes mode; `r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreQlt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreQltCI, varName = "quality_overall_cwc")`) and only little unique variance is still explained by core need fulfillment (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreQlt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreQltCI, varName = "KeyNeedFullfillment_cwc")`). These results are consistent with the results in study one and we thus find support for our hypotheses and can conclude that in this data set the fulfillment of core situational needs had a significant influence on outgroup attitudes and that this effect is likely explained by its effect through perceived interaction quality. 

\faQuestionCircle\ Are we sure that we don't want some sort of bootstrapped indirect effect? 

\subsubsection{Robustness}
```{r studentModelInterceptAttCoreInt, include=FALSE}
# Create and save Model
mdlStudent$lmeInterceptAttCoreInt <-
  lme(
    AttitudesDutch ~ KeyNeedFullfillment_cwc * OutgroupInteraction,
    random =  ~ 1 | PID,
    data = dtStudentSupp$studentWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudent$lmerInterceptAttCoreInt <- lmer(
    AttitudesDutch ~ KeyNeedFullfillment_cwc * OutgroupInteraction + (1 | PID),
    data = dtStudentSupp$studentWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlStudent$lmerInterceptAttCoreIntCI <- 
  confint(method = "Wald", mdlStudent$lmerInterceptAttCoreInt)

# Compare new model to previous step
anova(mdlStudent$lmeAttNull, 
      mdlStudent$lmeInterceptAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudent$varInterceptAttCoreInt <- 
  lme4::VarCorr(mdlStudent$lmeInterceptAttCoreInt)
```
```{r studentModelSlopesAttCoreIntX, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudent$lmeSlopesAttCoreInt <- lme(
  AttitudesDutch ~
    KeyNeedFullfillment_cwc * OutgroupInteraction,
  random = ~ 1 + KeyNeedFullfillment_cwc + OutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  data = dtStudentSupp$studentWithinBetween
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudent$lmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc * OutgroupInteraction +
      (1 + KeyNeedFullfillment_cwc + OutgroupInteraction | PID),
    data = dtStudentSupp$studentWithinBetween
  ), 
  confint = TRUE,
  digits = 3
)

mdlStudent$lmerSlopesAttCoreIntCI <- 
  confint(method = "Wald", mdlStudent$lmerSlopesAttCoreInt)

# Compare new model to previous step
anova(mdlStudent$lmeAttNull, 
      mdlStudent$lmeInterceptAttCoreInt,
      mdlStudent$lmeSlopesAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudent$varSlopesAttCoreInt <- 
  lme4::VarCorr(mdlStudent$lmeSlopesAttCoreInt)

# Assumption Checks:
mdlStudent$diagSlopesAttCoreInt <-
  sjPlot::plot_model(mdlStudent$lmerSlopesAttCoreInt, type = "diag")
grid.arrange(
  mdlStudent$diagSlopesAttCoreInt[[1]],
  mdlStudent$diagSlopesAttCoreInt[[2]]$`PID`,
  mdlStudent$diagSlopesAttCoreInt[[3]],
  mdlStudent$diagSlopesAttCoreInt[[4]]
)

# Plot prediction model
mdlStudent$predSlopesAttCoreInt <- 
  dtStudentSupp$studentWithinBetween %>%
  filter(PID %in% dtStudentSupp$studentPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudent$lmeSlopesAttCoreInt,
                           dtStudentSupp$studentWithinBetween %>% filter(PID %in% dtStudentSupp$studentPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudent$predPltSlopesAttCoreInt <-
    ggplot(data = mdlStudent$predSlopesAttCoreInt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Student_PredictionPlot_SlopesAttCoreInt.png",
  mdlStudent$predPltSlopesAttCoreInt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We again checked for alternative models. First, when considering generalized situational core need fulfillment together with whether an intergroup contact took place, we find that there is only a minuscule main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "KeyNeedFullfillment_cwc")`) but a stronger interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "KeyNeedFullfillment_cwc:OutgroupInteraction")`). Together with a significant main effect of having an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "OutgroupInteraction")`), this indicates that it is not key need fulfillment in general --- but key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. This finding is consistent with the results of the previous study, albeit with slightly weaker effect (likely because of the large number of measurements that did not include an outgroup interaction).

```{r studentOutModelInterceptAttCoreSdt, include=FALSE}
# Create and save Model
mdlStudentOut$Att$lmeInterceptCoreSdt <-
  lme(
    AttitudesDutch ~ KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudentOut$Att$lmerInterceptCoreSdt <- lmer(
    AttitudesDutch ~ KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# To be compared against a model with only the self determination theory needs
mdlStudentOut$Att$lmeInterceptSdt <-
  lme(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

summ(
  mdlStudentOut$Att$lmerInterceptSdt <- lmer(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous steps
anova(
  mdlStudentOut$Att$lmeInterceptSdt,
  mdlStudentOut$Att$lmeInterceptCoreSdt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")
rm(lmeInterceptCoreRed)

# Save variances
mdlStudentOut$Att$varInterceptCoreSdt <-
  lme4::VarCorr(mdlStudentOut$Att$lmeInterceptCoreSdt)
```
```{r studentOutModelSlopesAttCoreSdt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Att$lmeSlopesCoreSdt <-
  lme(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + KeyNeedFullfillment_cwc + Competence_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim", maxIter = 100, msMaxIter = 100),
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Att$lmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlStudentOut$Att$lmerSlopesCoreSdtCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerSlopesCoreSdt)

# Compare new model to previous step
anova(mdlStudentOut$Att$lmeInterceptSdt,
      mdlStudentOut$Att$lmeInterceptCoreSdt, 
      mdlStudentOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# model with SDT only
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Att$lmeSlopesSdt <-
  lme(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Att$lmerSlopesSdt <- lmer(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous step
anova(mdlStudentOut$Att$lmeInterceptSdt,
      mdlStudentOut$Att$lmeSlopesSdt, 
      mdlStudentOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")


# Save variances
mdlStudentOut$Att$varSlopesCoreSdt <- 
  lme4::VarCorr(mdlStudentOut$Att$lmeSlopesCoreSdt)

# Assumption Checks:
mdlStudentOut$Att$diagSlopesCoreSdt <- 
  sjPlot::plot_model(mdlStudentOut$Att$lmerSlopesCoreSdt, type = "diag")
grid.arrange(
  mdlStudentOut$Att$diagSlopesCoreSdt[[1]],
  mdlStudentOut$Att$diagSlopesCoreSdt[[2]]$`PID`,
  mdlStudentOut$Att$diagSlopesCoreSdt[[3]],
  mdlStudentOut$Att$diagSlopesCoreSdt[[4]]
)

# Plot prediction model
mdlStudentOut$Att$predSlopesCoreSdt <- 
  dtStudentSupp$studentOutWithinBetween %>%
  filter(PID %in% dtStudentSupp$studentOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID, Autonomy) %>% 
  mutate(measure = predict(mdlStudentOut$Att$lmeSlopesCoreSdt,
                           dtStudentSupp$studentOutWithinBetween %>% filter(PID %in% dtStudentSupp$studentOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudentOut$Att$predPltSlopesCoreSdt <-
    ggplot(data = mdlStudentOut$Att$predSlopesCoreSdt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/StudentOut_PredictionPlot_SlopesAttCoreStd.png",
  mdlStudentOut$Att$predPltSlopesCoreSdt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

# Model comparison
studentSdtComp <-
  anova(
    mdlStudentOut$Att$lmerSlopesSdt, 
    mdlStudentOut$Att$lmerSlopesCoreSdt
  ) %>%
  as.data.frame()
studentSdtCompDf <- studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Df"]
studentSdtCompN <- sapply(ranef(mdlStudentOut$Att$lmerSlopesCoreSdt), nrow)
studentSdtCompChi <- studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2)
studentSdtCompP <-
  ifelse(studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001,
         "< .001",
         paste0("= ", studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3)))

studentSdtCompChiSq <- paste0("$\\chi^2$(", studentSdtCompDf, ", \\textit{N} = ", studentSdtCompN, ") = ", studentSdtCompChi, ", \\textit{p} ", studentSdtCompP)
```

In a final step we again checked whether during the interaction the core situational need remains a meaningful predictor even when taking other fundamental psychological needs into account. We find that the core need adds significantly above a model with only the self determination theory needs (random slopes models; `r studentSdtCompChiSq`). We find that the core need explains the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "KeyNeedFullfillment_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all of the three fundamental needs. However, different from the first study, relatedness (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "Relatedness_cwc")`) and autonomy (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "Autonomy_cwc")`) also predicted positive outgroup attitudes in this larger sample. For full results see Online Supplementary Information B.

\section{Study 3}

The aim of this final study is to extend the previous studies by additionally testing Allport's conditions in an extensive longitudinal design and to compare the predictive powers of Allport's conditions and the core situational need fulfillment. We will, thus, again test the general contact hypothesis, the influence of core need fulfillment, and perceived interaction quality during intergroup contacts. However, we additionally have the opportunity to also assess the role of Allport's conditions in this and to compare the two approaches (Allport's conditions and core need fulfillment) directly. 

For this study we specifically recruited international medical students, because they represent a particular group of migrants who face structural requirements to integrate and interact with Dutch majority outgroup members on a daily basis. As part of their educational program, the migrants are required to take language courses and interact with patients as part of their medical internships and medical residency. The extensive longitudinal survey method again offers a large body of ecologically valid data on need satisfaction in real-life intergroup contact situations. Data were collected from November 8th, 2019 to January 10th, 2020.

The full surveys are available in our Online Supplementary Material A and the full data description is available in Online Supplementary Materials B. Correlations and descriptive statistics of the included variables are available in Table \ref{tab:medicalVarDescr} and Table \ref{tab:medicalOutVarDescr}.

\subsection{Methods}

```{r medicalSampleInfo, include=FALSE}
# extract demographic information from eligibility questionnaire
medicalDemographicSupp <- 
  dtMedical$raw.eligibility %>%
  filter(session %in% dtMedical$full$session) %>%
  select(session, nationality, studentBachMa)
# summarize participant characteristics

medicalSampleInfo <-
  merge(dtMedical$full, medicalDemographicSupp, by = "session") %>%
  mutate(gender = as.factor(ifelse(.$Gender == 1, "women", ifelse(.$Gender == 2, "man", ifelse(.$Gender == 3, "other", NA))))) %>%
  group_by(PID) %>%
  summarise(
    dailiesN = n(), 
    morningN = sum(periodMA=="morning"),
    afternoonN = sum(periodMA=="afternoon"),
    age = age,
    gender = gender,
    nationality = nationality
  ) %>%
  distinct

# look at frequencies of characteristics 
table(medicalSampleInfo$age)
table(medicalSampleInfo$gender)
table(as.character(medicalSampleInfo$nationality))

# divide into trait and state
dtMedicalSupp$medicalWithinBetween <- 
  MlTraitState(
    data = dtMedical$full,
    id = "PID",
    selection =
      c(
        "OutgroupInteraction",
        "NonOutgroupInteraction"
      )
  )
```

```{r medicalVarDescr, include=FALSE}
medicalMlCor <-
  MlCorMat(
    data = dtMedical$full,
    id = "PID",
    selection = c("KeyNeedFulfillment", "Competence", "Autonomy", "Relatedness", "AllportsCondition", "qualityOverall", "AttitudesDutch"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Allport", "Quality", "Attitudes NL")
  ) 

medicalMlCor %>%
  kable(
    .,
    caption = "Medical: Multilevel Core Variable Descriptives",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/medicalVarDescr.tex")
```

```{r medicalOutVarDescr, include=FALSE}
medicalOutMlCor <-
  MlCorMat(
    data = dtMedical$full %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection = c("KeyNeedFulfillment", "Competence", "Autonomy", "Relatedness", "AllportsCondition", "qualityOverall", "AttitudesDutch"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Allport", "Quality", "Attitudes NL")
  )

medicalOutMlCor %>%
  kable(
    .,
    caption = "Medical: Multilevel Core Variable Descriptives (Outgroup Contact Only)",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/medicalOutVarDescr.tex")

# misty::multilevel.descript(dtStudentsSupp$studentWithinBetween$keyMotiveFulfilled, cluster = dtStudentsSupp$studentWithinBetween$PID)
```

\subsubsection{Participants} After receiving ethical approval from the University of Groningen, we recruited `r nrow(medicalSampleInfo)` international medical students using a contacts within the University Medical Department and specifically targeted non-Dutch students, who had recently arrived in the Netherlands. Participants reported on their interactions for at least 30 days with two daily measures (capturing the morning and afternoon). With this design, we aimed at getting 50-60 measurements per participant (\textit{M} = `r format(round(mean(medicalSampleInfo$dailiesN),2), nsmall=2)`, \textit{SD} = `r format(round(sd(medicalSampleInfo$dailiesN),2), nsmall=2)`, \textit{total N} = `r sum(medicalSampleInfo$dailiesN)`). As with the previous study this should offer sufficient power to model processes within participants and will lend stronger weight to between-participant results. Participants were compensated for their participation with partial course credits --- depending on their participation. The sample consisted of relatively young migrants, who were mostly from the global north ($M_{age}$ = `r format(round(mean(medicalSampleInfo$age),2), nsmall=2)`, $SD_{age}$ = `r format(round(sd(medicalSampleInfo$age),2), nsmall=2)`, `r nrow(medicalSampleInfo %>% filter(gender == "women"))` women). The sample fairly accurately describes the local population of international students.

\subsubsection{Procedure} The study procedure mirrored the setup of studies one and two, in that it consisted of pre-, daily diary-, and post-measurement. The participants were invited for daily diary measurements twice a day (at 12 pm and 7pm) for 30 days (\textit{median duration} = `r seconds_to_period(median(difftime(dtMedical$clean$ended.daily, dtMedical$clean$created.daily, units = "secs"), na.rm=TRUE)) %>% as.character`, \textit{MAD duration} = `r seconds_to_period(round(mad(difftime(dtMedical$clean$ended.daily, dtMedical$clean$created.daily, units = "secs"), na.rm=TRUE))) %>% as.character`).  General compliance was high (`r format(round(sum(medicalSampleInfo$dailiesN)/(nrow(medicalSampleInfo)*62)*100,2), nsmall=2)`\% filled daily diary surveys for 31 days or more NEED TO RE-CHECK THIS). The response rates were approximately equal during mornings (\textit{n} = `r sum(medicalSampleInfo$morningN)`) and afternoons (\textit{n} = `r sum(medicalSampleInfo$afternoonN)`). All key variables in for this study were part of the short daily diary surveys. 

\subsubsection{Materials}

\paragraph{Intergroup Contact}The measurement of intergroup contacts was identical to study two. The participants recorded between `r dtMedicalSupp$medicalContactFreq$SumContactNL[dtMedicalSupp$medicalContactFreq$SumContactNL > 0] %>% min`--`r dtMedicalSupp$medicalContactFreq$SumContactNL %>% max` interactions with Dutch outgroup members
(`r dtMedicalSupp$medicalContactFreq$PercContactNL[dtMedicalSupp$medicalContactFreq$PercContactNL > 0] %>% min %>% round(2) %>% format(nsmall=2)`--`r dtMedicalSupp$medicalContactFreq$PercContactNL %>% max %>% round(2) %>% format(nsmall=2)`\% of individual daily diary measurements; `r (sum(dtMedicalSupp$medicalContactFreq$SumContactNL) / nrow(dtMedical$full) * 100) %>% round(2) %>% format(nsmall=2)`\% of all `r nrow(dtMedical$full)` daily diary responses). 

\paragraph{Psychological Needs}The measurement of the core situational need and its fulfillment was identical to study two. Similarly, the measurement of the self determination needs was identical to studies one and two. 

\paragraph{Allport's Conditions}To measure how much each of the interactions fulfilled Allport's conditions of optimal contact we asked participants to rate how much the interaction had equal status ("\textit{The interaction with [name interaction partner] was on equal footing (same status)}"), a common goal ("\textit{[name interaction partner] shared your goal ([free-text entry interaction key need])}"), support of authorities ("\textit{The interaction with [name interaction partner] was voluntary}"), and intergroup cooperation ("\textit{The interaction with [name interaction partner] was cooperative}"). 

\paragraph{Perceived Interaction Quality}The ratings of the perceived interaction quality was identical to study one.

\paragraph{Outgroup Attitudes}Attitudes towards the Dutch majority outgroup was again measured using the feeling thermometer, as in studies one and two. All survey details are also available in Online Supplemental Materials A and B. 

\input{Tables/medicalVarDescr}
\input{Tables/medicalOutVarDescr}

\subsection{Results}

```{r medicalFreqAttCor, include=FALSE}
dtMedicalSupp$medicalContactFreq <-
  dtMedicalSupp$medicalContactFreq %>%
  mutate(
    SumContactNL_c = SumContactNL - mean(SumContactNL, na.rm = TRUE),
    SumContactNLAll_c = SumContactNLAll - mean(SumContactNLAll, na.rm = TRUE),
    AvAttitude_c = AvAttitude - mean(AvAttitude, na.rm = TRUE),
    AvQuality_c = AvQuality - mean(AvQuality, na.rm = TRUE)
  )

# correlation panel
pairs.panels.new(
  dtMedicalSupp$medicalContactFreq %>% select(SumContactNL, SumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)",
    "Sum:\nNumber of Outgroup Contacts (NL)",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)

# correlation panel with interaction sums winsorized
pairs.panels.new(
  dtMedicalSupp$medicalContactFreq %>% select(WinSumContactNL, WinSumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)\n[Winsorized]",
    "Sum:\nNumber of Outgroup Contacts (NL)\n[Winsorized]",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)
```

\subsubsection{Contact Hypothesis}We tested the most general contact hypothesis in two steps. First, we assessed whether more intergroup interactions were related to to more positive outgroup attitudes. Second, we tested whether a potential positive effect on outgroup attitudes depended on the interaction quality (jointly with the number of interactions). We find no significant correlation between intergroup contact and average outgroup attitudes --- for neither the total number of outgroup interactions (\textit{r} = `r cor(dtMedicalSupp$medicalContactFreq$SumContactNLAll, dtMedicalSupp$medicalContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r cor.test(dtMedicalSupp$medicalContactFreq$SumContactNLAll, dtMedicalSupp$medicalContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`) and the number of measurement beeps with an interaction (\textit{r} = `r cor(dtMedicalSupp$medicalContactFreq$SumContactNL, dtMedicalSupp$medicalContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r cor.test(dtMedicalSupp$medicalContactFreq$SumContactNL, dtMedicalSupp$medicalContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`). This is to say that within our data, participants with more outgroup interactions did not have significantly more positive or negative outgroup attitudes. This is again consistent with the results we found in the first study but inconsitent with the significant relationship we find in the second study. 

```{r medicalModelOlsAttFreqQual, include=FALSE}
# create list to store Worker models
mdlMedical <- list()

# regression
mdlMedical$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtMedicalSupp$medicalContactFreq)

summ(
  mdlMedical$lmAttFreqQualX,
  confint = TRUE,
  digits = 3
)

mdlMedical$lmAttFreqQualXEta <-
  effectsize::eta_squared(mdlMedical$lmAttFreqQualX, partial = TRUE)

interactions::interact_plot(
  mdlMedical$lmAttFreqQualX,
  pred = SumContactNL_c,
  modx = AvQuality_c,
  interval = TRUE,
  partial.residuals = TRUE
)

interactions::johnson_neyman(mdlMedical$lmAttFreqQualX,
                             pred = SumContactNL_c,
                             modx = AvQuality_c,
                             alpha = .05)
```

However, we do find a significant correlation between the participants' Average Interaction Quality and their Average Outgroup Attitudes (\textit{r} = `r cor(dtMedicalSupp$medicalContactFreq$AvQuality, dtMedicalSupp$medicalContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r cor.test(dtMedicalSupp$medicalContactFreq$AvQuality, dtMedicalSupp$medicalContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`). Thus, when considering the number of interactions and average interaction quality jointly in a linear regression, we only find a main effect of average perceived interaction quality on predict outgroup attitudes (\textit{b} = `r coef(summary(mdlMedical$lmAttFreqQualX))["AvQuality_c","Estimate"] %>% round(2) %>% format(nsmall=2)`, \textit{t}(`r mdlMedical$lmAttFreqQualX$df.residual`) = `r coef(summary(mdlMedical$lmAttFreqQualX))["AvQuality_c","t value"] %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r coef(summary(mdlMedical$lmAttFreqQualX))["AvQuality_c","Pr(>|t|)"] %>% round(3) %>% format(nsmall=3)`, $\eta_p^2$ = `r mdlMedical$lmAttFreqQualXEta %>% filter(Parameter == "AvQuality_c") %>% select(Eta2_partial) %>% as.numeric %>% round(2) %>% format(nsmall=2)`). Given the missing aggregate relationship between number of interactions and outgroup attitudes, we find no significant effect of interactions themselves nor do we find a significant interaction effect. This result mirrors that of study one but is inconsistent with the second study. But again this inconsistency is not necessarily surprising given that the variables aggregate all within person variation and there were substantially more measurements where participants did not have an interaction (but reported their outgroup attitudes) than measurements that followed an outgroup contact.  

```{r medicalModelMLAttNull, include=FALSE}
# Create and save Model
mdlMedical$lmerAttNullType <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
             data = dtMedical$full %>%
               filter(complete.cases(
                 OutgroupInteraction, NonOutgroupInteraction
               ))) # use optim if it does not converge

mdlMedical$lmeAttNullType <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtMedical$full %>%
      filter(complete.cases(
        OutgroupInteraction, NonOutgroupInteraction
      )),
    na.action = na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(mdlMedical$lmerAttNull) #or with the lme function
summ(mdlMedical$lmerAttNullType, digits = 3)

# Save variances
mdlMedical$varAttNullType <- 
  VarCorr(mdlMedical$lmeAttNullType) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlMedical$tauAttNullType <- 
  as.numeric(mdlMedical$varAttNullType[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlMedical$sigmaAttNullType <- 
  as.numeric(mdlMedical$varAttNullType[2])
# The ICC estimate (between/between+within) is:
mdlMedical$IccAttNullType <-
  (as.numeric(mdlMedical$varAttNullType[1]) / (as.numeric(mdlMedical$varAttNullType[1]) + as.numeric(mdlMedical$varAttNullType[2])))
mdlMedical$IccPercAttNull <-
  ((as.numeric(mdlMedical$varAttNullType[1]) / (as.numeric(mdlMedical$varAttNullType[1]) + as.numeric(mdlMedical$varAttNullType[2])))) * 100
```

```{r medicalModelInterceptAttType, include = FALSE}
# Create and save Model
mdlMedical$lmeInterceptAttType <-
  lme(
    AttitudesDutch ~ OutgroupInteraction + NonOutgroupInteraction,
    random =  ~ 1 | PID,
    na.action=na.omit,
    data = dtMedical$full
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedical$lmerInterceptAttType <- lmer(
    AttitudesDutch ~ OutgroupInteraction + NonOutgroupInteraction + (1 | PID),
    data = dtMedical$full
  ),
  confint = TRUE,
  digits = 3
)

mdlMedical$lmerInterceptAttTypeCI <- 
  confint(method = "Wald", mdlMedical$lmerInterceptAttType)

# Compare new model to previous step
anova(mdlMedical$lmeAttNullType, 
      mdlMedical$lmeInterceptAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedical$varInterceptAttType <- 
  lme4::VarCorr(mdlMedical$lmeInterceptAttType)
```

```{r medicalModelSlopesInteractionType, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedical$lmeSlopesAttType <- lme(
  AttitudesDutch ~
    OutgroupInteraction + NonOutgroupInteraction,
  random = ~ 1 + OutgroupInteraction + NonOutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  na.action = na.omit,
  data = dtMedical$full
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedical$lmerSlopesAttType <- lmer(
    AttitudesDutch ~
      OutgroupInteraction + NonOutgroupInteraction +
      (1 + OutgroupInteraction + NonOutgroupInteraction | PID),
    data = dtMedical$full
  ), 
  confint = TRUE,
  digits = 3
)

mdlMedical$lmerSlopesAttTypeCI <- 
  confint(method = "Wald", mdlMedical$lmerSlopesAttType)

# Compare new model to previous step
anova(mdlMedical$lmeAttNullType,
      mdlMedical$lmeInterceptAttType, 
      mdlMedical$lmeSlopesAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedical$varSlopesAttType <- 
  lme4::VarCorr(mdlMedical$lmeSlopesAttType)

# Assumption Checks:
mdlMedical$diagSlopesAttType <-
  sjPlot::plot_model(mdlMedical$lmerSlopesAttType, type = "diag")
grid.arrange(
  mdlMedical$diagSlopesAttType[[1]],
  mdlMedical$diagSlopesAttType[[2]]$`PID`,
  mdlMedical$diagSlopesAttType[[3]],
  mdlMedical$diagSlopesAttType[[4]]
)

# Plot prediction model
mdlMedical$predSlopesAttType <-
  dtMedical$full %>%
  filter(complete.cases(OutgroupInteraction, NonOutgroupInteraction)) %>%
  select(AttitudesDutch, TIDnum, PID) %>%
  mutate(measure = predict(
    mdlMedical$lmeSlopesAttType,
    dtMedical$full %>%
      filter(complete.cases(
        OutgroupInteraction, NonOutgroupInteraction
      )),
    re.form = NA
  ))

(
  mdlMedical$predPltSlopesAttType <-
    ggplot(data = mdlMedical$predSlopesAttType %>% filter(PID %in% dtMedicalSupp$medicalPltIDs), 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Medical_PredictionPlot_SlopesAttType.png",
  mdlMedical$predPltSlopesAttType,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We additionally used a multilevel regression to check whether having an interaction with an outgroup member had a situational (i.e., contemporaneous) effect within the participants. We find that having an outgroup interaction is indeed associated with significantly more positive outgroup attitudes within the participants (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttType, lmerCI = mdlMedical$lmerSlopesAttTypeCI, varName = "OutgroupInteractionYes")`), even after controlling for having an interaction with a non-Dutch (which did not relate to outgroup attitudes independently; For full results see Online Supplementary Materials B). Thus, in our third dataset we find some mixed results, outgroup contacts are not significantly related to outgroup attitudes on aggregate between participants and this effect is also not suppressed by a average interaction quality (i.e., no interaction effect). However, while the aggregate data is partly inconsistent with the first two studies, the within person contemoranous effect of intergroup contact is consistent across all three studies.  

\subsubsection{Allport's Conditions}

```{r medicalOutModelMLAttNull, include=FALSE}
# create empty list to organize models
mdlMedicalOut <- 
  list(
    Att = list(),
    Qlt = list()
  )

# Create and save Model
mdlMedicalOut$Att$lmerNull <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
             data = dtMedicalSupp$medicalOutWithinBetween) # use optim if it does not converge
mdlMedicalOut$Att$lmeNull <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.ML.r) #or with the lme function
summ(mdlMedicalOut$Att$lmerNull, digits = 3, center = TRUE)

# Save variances
mdlMedicalOut$Att$varNull <- 
  VarCorr(mdlMedicalOut$Att$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlMedicalOut$Att$tauNull <- 
  as.numeric(mdlMedicalOut$Att$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlMedicalOut$Att$sigmaNull <- 
  as.numeric(mdlMedicalOut$Att$varNull[2])
# The ICC estimate (between/between+within) is:
mdlMedicalOut$Att$IccNull <-
  (as.numeric(mdlMedicalOut$Att$varNull[1]) / (as.numeric(mdlMedicalOut$Att$varNull[1]) + as.numeric(mdlMedicalOut$Att$varNull[2])))
mdlMedicalOut$Att$IccPercNull <-
  ((as.numeric(mdlMedicalOut$Att$varNull[1]) / (as.numeric(mdlMedicalOut$Att$varNull[1]) + as.numeric(mdlMedicalOut$Att$varNull[2])))) * 100
```

```{r medicalOutModelInterceptAttAllport, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptAllport <-
  lme(
    AttitudesDutch ~ AllportsCondition_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptAllport <-
    lmer(
      AttitudesDutch ~ AllportsCondition_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Att$lmerInterceptAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerInterceptAllport)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeNull, 
      mdlMedicalOut$Att$lmeInterceptAllport) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptAllport <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptAllport)
```

```{r medicalOutModelSlopesAttAllport, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesAllport <-
  lme(
    AttitudesDutch ~
      AllportsCondition_cwc,
    random = ~ 1 + AllportsCondition_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesAllport <- lmer(
    AttitudesDutch ~
      AllportsCondition_cwc +
      (1 + AllportsCondition_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# all variables standardized within PPT
summ(
  mdlMedicalOut$Att$lmerSlopesAllportZ <- lmer(
    AttitudesDutch_zwc ~
      AllportsCondition_zwc +
      (1 + AllportsCondition_zwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# standardized coefficients
stdCoef.merMod(mdlMedicalOut$Att$lmerSlopesAllport)

# 95%CIs
mdlMedicalOut$Att$lmerSlopesAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesAllport)

# Attempts at R^2
#r2mlm::r2mlm(mdlMedicalOut$Att$lmerSlopesAllport, bargraph = TRUE)
mitml::multilevelR2(mdlMedicalOut$Att$lmerSlopesAllport)
performance::r2(mdlMedicalOut$Att$lmerSlopesAllport)
performance::model_performance(mdlMedicalOut$Att$lmerSlopesAllport)
performance::compare_performance(mdlMedicalOut$Att$lmerNull, 
                                 mdlMedicalOut$Att$lmerInterceptAllport, 
                                 mdlMedicalOut$Att$lmerSlopesAllport)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeNull, 
      mdlMedicalOut$Att$lmeInterceptAllport, 
      mdlMedicalOut$Att$lmeSlopesAllport) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varSlopesAllport <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesAllport)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesAllport <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesAllport, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesAllport[[1]],
  mdlMedicalOut$Att$diagSlopesAllport[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesAllport[[3]],
  mdlMedicalOut$Att$diagSlopesAllport[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesAllport <- 
  dtMedicalSupp$medicalOutWithinBetween %>% 
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesAllport,
                           dtMedicalSupp$medicalOutWithinBetween %>% filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesAllport <-
    ggplot(data = mdlMedicalOut$Att$predSlopesAllport, 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttAllport.png",
  mdlMedicalOut$Att$predPltSlopesAllport,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

```{r medicalOutModelMLQltNull, include=FALSE}
# Create and save Model
mdlMedicalOut$Qlt$lmerNull <-
  lme4::lmer(qualityOverall ~ 1 + (1 | PID), 
             data = dtMedicalSupp$medicalOutWithinBetween) # use optim if it does not converge
mdlMedicalOut$Qlt$lmeNull <-
  mdlMedicalOut$Qlt$lmeNull <-lme(
    qualityOverall ~ 1,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.Qual.ML.r) #or with the lme function
summ(mdlMedicalOut$Qlt$lmerNull, digits = 3)

# Save variances
mdlMedicalOut$Qlt$varNull <- 
  VarCorr(mdlMedicalOut$Qlt$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlMedicalOut$Qlt$tauNull <- 
  as.numeric(mdlMedicalOut$Qlt$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlMedicalOut$Qlt$sigmaNull <- 
  as.numeric(mdlMedicalOut$Qlt$varNull[2])
# The ICC estimate (between/between+within) is:
mdlMedicalOut$Qlt$IccNull <-
  (as.numeric(mdlMedicalOut$Qlt$varNull[1]) / (as.numeric(mdlMedicalOut$Qlt$varNull[1]) + as.numeric(mdlMedicalOut$Qlt$varNull[2])))
mdlMedicalOut$Qlt$IccPercNull <-
  ((as.numeric(mdlMedicalOut$Qlt$varNull[1]) / (as.numeric(mdlMedicalOut$Qlt$varNull[1]) + as.numeric(mdlMedicalOut$Qlt$varNull[2])))) * 100
```

```{r medicalOutModelInterceptQltAllport, include=FALSE}
# Create and save Model
mdlMedicalOut$Qlt$lmeInterceptAllport <-
  lme(
    qualityOverall ~ AllportsCondition_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Qlt$lmerInterceptAllport <-
    lmer(
      qualityOverall ~ AllportsCondition_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Qlt$lmerInterceptAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Qlt$lmerInterceptAllport)

# Compare new model to previous step
anova(mdlMedicalOut$Qlt$lmeNull, 
      mdlMedicalOut$Qlt$lmeInterceptAllport) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Qlt$varInterceptAllport <-
  lme4::VarCorr(mdlMedicalOut$Qlt$lmeInterceptAllport)
```

```{r medicalOutModelSlopesQltAllport, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Qlt$lmeSlopesAllport <-
  lme(
    qualityOverall ~
      AllportsCondition_cwc,
    random = ~ 1 + AllportsCondition_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Qlt$lmerSlopesAllport <-
    lmer(
      qualityOverall ~
        AllportsCondition_cwc +
        (1 + AllportsCondition_cwc | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Qlt$lmerSlopesAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Qlt$lmerSlopesAllport)

# Compare new model to previous step
anova(mdlMedicalOut$Qlt$lmeNull, 
      mdlMedicalOut$Qlt$lmeInterceptAllport, 
      mdlMedicalOut$Qlt$lmeSlopesAllport) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Qlt$varSlopesAllport <- 
  lme4::VarCorr(mdlMedicalOut$Qlt$lmeSlopesAllport)

# Assumption Checks:
mdlMedicalOut$Qlt$diagSlopesAllport <-
  sjPlot::plot_model(mdlMedicalOut$Qlt$lmerSlopesAllport, type = "diag")
grid.arrange(
  mdlMedicalOut$Qlt$diagSlopesAllport[[1]],
  mdlMedicalOut$Qlt$diagSlopesAllport[[2]]$`PID`,
  mdlMedicalOut$Qlt$diagSlopesAllport[[3]],
  mdlMedicalOut$Qlt$diagSlopesAllport[[4]]
)

# Plot prediction model
mdlMedicalOut$Qlt$predSlopesAllport <- 
  dtMedicalSupp$medicalOutWithinBetween %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Qlt$lmeSlopesAllport,
                           dtMedicalSupp$medicalOutWithinBetween %>% filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Qlt$predPltSlopesAllport <-
    ggplot(data = mdlMedicalOut$Qlt$predSlopesAllport %>% filter(PID %in% dtMedicalSupp$medicalOutPltIDs), 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAllport.png",
  mdlMedicalOut$Qlt$predPltSlopesAllport,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

```

```{r medicalOutModelInterceptAttAllportQlt, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptAllportQlt <-
  lme(
    AttitudesDutch ~ AllportsCondition_cwc + qualityOverall_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptAllportQlt <-
    lmer(
      AttitudesDutch ~ AllportsCondition_cwc + qualityOverall_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerInterceptAllportQltCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerInterceptAllportQlt)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull, 
  mdlMedicalOut$Att$lmeInterceptAllportQlt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptAllportQlt <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptAllportQlt)
```

```{r medicalOutModelSlopesAttAllportQlt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesAllportQlt <-
  lme(
    AttitudesDutch ~
      AllportsCondition_cwc + qualityOverall_cwc,
    random = ~ 1 + AllportsCondition_cwc + qualityOverall_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesAllportQlt <- lmer(
    AttitudesDutch ~
      AllportsCondition_cwc + qualityOverall_cwc +
      (1 + AllportsCondition_cwc + qualityOverall_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween,
    control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
  ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerSlopesAllportQltCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesAllportQlt)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull,
  mdlMedicalOut$Att$lmeInterceptAllportQlt,
  mdlMedicalOut$Att$lmeSlopesAllportQlt
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varSlopesAllportQlt <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesAllportQlt)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesAllportQlt <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesAllportQlt, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesAllportQlt[[1]],
  mdlMedicalOut$Att$diagSlopesAllportQlt[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesAllportQlt[[3]],
  mdlMedicalOut$Att$diagSlopesAllportQlt[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesAllportQlt <- 
  dtMedicalSupp$medicalOutWithinBetween %>% 
  filter(complete.cases(AllportsCondition, qualityOverall)) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesAllportQlt,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(AllportsCondition, qualityOverall)) %>%
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesAllportQlt <-
    ggplot(data = mdlMedicalOut$Att$predSlopesAllportQlt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttAllportQlt.png",
  mdlMedicalOut$Att$predPltSlopesAllportQlt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We sequentially tested whether the fulfillment of Allport's Contact Conditions was (1) related to more positive outgroup attitudes, (2) higher perceived interaction quality, and (3) whether the variance explained by Allport's Conditions is assumed by the perceived interaction quality if considered jointly. We find that in the multilevel models, the fulfillment of Allport's Conditions during outgroup contacts was associated with more positive outgroup attitudes (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesAllport, lmerCI = mdlMedicalOut$Att$lmerSlopesAllportCI, varName = "AllportsCondition_cwc")`) and also predicted higher perceived interaction quality (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Qlt$lmeSlopesAllport, lmerCI = mdlMedicalOut$Qlt$lmerSlopesAllportCI, varName = "AllportsCondition_cwc")`). Moreover, when we consider the influences of Allport's Conditions and interaction quality on outgroup attitudes jointly, we find that perceived interaction quality is a substantially stronger predictor (random slopes mode; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesAllportQlt, lmerCI = mdlMedicalOut$Att$lmerSlopesAllportQltCI, varName = "qualityOverall_cwc")`) and the unique variance explained by Allport's Conditions was less than half of its original effect size (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesAllportQlt, lmerCI = mdlMedicalOut$Att$lmerSlopesAllportQltCI, varName = "AllportsCondition_cwc")`). These results indicate that in this dataset the the fulfillment of Allport's conditions had a significant influence on outgroup attitudes and this effect is likely in parts explained by its effect through perceived interaction quality. 

\faQuestionCircle\ Are we sure that we don't want some sort of bootstrapped indirect effect? 

\subsubsection{Core Need}

```{r medicalOutModelInterceptAttCore, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptCore <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptCore <-
    lmer(
      AttitudesDutch ~ KeyNeedFulfillment_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Att$lmerInterceptCoreCI <-
  confint(method = "Wald", mdlMedicalOut$Att$lmerInterceptCore)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeNull,
      mdlMedicalOut$Att$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptCore <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptCore)
```

```{r medicalOutModelSlopesAttCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesCore <-
  lme(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesCore <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc +
      (1 + KeyNeedFulfillment_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# all variables standardized within PPT
summ(
  mdlMedicalOut$Att$lmerSlopesCoreZ <- lmer(
    AttitudesDutch_zwc ~
      KeyNeedFulfillment_zwc +
      (1 + KeyNeedFulfillment_zwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# standardized coefficients
stdCoef.merMod(mdlMedicalOut$Att$lmerSlopesCore)

# 95%CIs
mdlMedicalOut$Att$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesCore)

# Attempts at R^2
r2mlm::r2mlm(mdlMedicalOut$Att$lmerSlopesCore, bargraph = TRUE)
mitml::multilevelR2(mdlMedicalOut$Att$lmerSlopesCore)
performance::r2(mdlMedicalOut$Att$lmerSlopesCore)
performance::model_performance(mdlMedicalOut$Att$lmerSlopesCore)
performance::compare_performance(mdlMedicalOut$Att$lmerNull, 
                                 mdlMedicalOut$Att$lmerInterceptCore, 
                                 mdlMedicalOut$Att$lmerSlopesCore)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeNull, 
      mdlMedicalOut$Att$lmeInterceptCore, 
      mdlMedicalOut$Att$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varSlopesCore <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesCore)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesCore <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesCore[[1]],
  mdlMedicalOut$Att$diagSlopesCore[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesCore[[3]],
  mdlMedicalOut$Att$diagSlopesCore[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesCore <- 
  dtMedicalSupp$medicalOutWithinBetween %>% 
  filter(complete.cases(KeyNeedFulfillment)) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesCore,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(KeyNeedFulfillment)) %>% 
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesCore <-
    ggplot(data = mdlMedicalOut$Att$predSlopesCore, 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttCore.png",
  mdlMedicalOut$Att$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

```{r medicalOutModelInterceptQltCore, include=FALSE}
# Create and save Model
mdlMedicalOut$Qlt$lmeInterceptCore <-
  lme(
    qualityOverall ~ KeyNeedFulfillment_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Qlt$lmerInterceptCore <-
    lmer(
      qualityOverall ~ KeyNeedFulfillment_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Qlt$lmerInterceptCoreCI <- 
  confint(method = "Wald", mdlMedicalOut$Qlt$lmerInterceptCore)

# Compare new model to previous step
anova(mdlMedicalOut$Qlt$lmeNull, 
      mdlMedicalOut$Qlt$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Qlt$varInterceptCore <-
  lme4::VarCorr(mdlMedicalOut$Qlt$lmeInterceptCore)
```

```{r medicalOutModelSlopesQltCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Qlt$lmeSlopesCore <-
  lme(
    qualityOverall ~
      KeyNeedFulfillment_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Qlt$lmerSlopesCore <-
    lmer(
      qualityOverall ~
        KeyNeedFulfillment_cwc +
        (1 + KeyNeedFulfillment_cwc | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Qlt$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlMedicalOut$Qlt$lmerSlopesCore)

# Compare new model to previous step
anova(mdlMedicalOut$Qlt$lmeNull, 
      mdlMedicalOut$Qlt$lmeInterceptCore, 
      mdlMedicalOut$Qlt$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Qlt$varSlopesCore <- 
  lme4::VarCorr(mdlMedicalOut$Qlt$lmeSlopesCore)

# Assumption Checks:
mdlMedicalOut$Qlt$diagSlopesCore <-
  sjPlot::plot_model(mdlMedicalOut$Qlt$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlMedicalOut$Qlt$diagSlopesCore[[1]],
  mdlMedicalOut$Qlt$diagSlopesCore[[2]]$`PID`,
  mdlMedicalOut$Qlt$diagSlopesCore[[3]],
  mdlMedicalOut$Qlt$diagSlopesCore[[4]]
)

# Plot prediction model
mdlMedicalOut$Qlt$predSlopesCore <- 
  dtMedicalSupp$medicalOutWithinBetween %>%
  filter(complete.cases(KeyNeedFulfillment)) %>% 
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Qlt$lmeSlopesCore,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(KeyNeedFulfillment)) %>% 
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Qlt$predPltSlopesCore <-
    ggplot(data = mdlMedicalOut$Qlt$predSlopesCore %>% filter(PID %in% dtMedicalSupp$medicalOutPltIDs), 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesCore.png",
  mdlMedicalOut$Qlt$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

```

```{r medicalOutModelInterceptAttCoreQlt, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptCoreQlt <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc + qualityOverall_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptCoreQlt <-
    lmer(
      AttitudesDutch ~ KeyNeedFulfillment_cwc + qualityOverall_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerInterceptCoreQltCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerInterceptCoreQlt)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull, 
  mdlMedicalOut$Att$lmeInterceptCoreQlt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptCoreQlt <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptCoreQlt)
```

```{r medicalOutModelSlopesAttCoreQlt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesCoreQlt <-
  lme(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + qualityOverall_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc + qualityOverall_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesCoreQlt <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + qualityOverall_cwc +
      (1 + KeyNeedFulfillment_cwc + qualityOverall_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween,
    control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
  ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerSlopesCoreQltCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesCoreQlt)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull,
  mdlMedicalOut$Att$lmeInterceptCoreQlt,
  mdlMedicalOut$Att$lmeSlopesCoreQlt
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varSlopesCoreQlt <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesCoreQlt)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesCoreQlt <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesCoreQlt, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesCoreQlt[[1]],
  mdlMedicalOut$Att$diagSlopesCoreQlt[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesCoreQlt[[3]],
  mdlMedicalOut$Att$diagSlopesCoreQlt[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesCoreQlt <- 
  dtMedicalSupp$medicalOutWithinBetween %>% 
  filter(complete.cases(KeyNeedFulfillment, qualityOverall)) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesCoreQlt,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(KeyNeedFulfillment, qualityOverall)) %>%
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesCoreQlt <-
    ggplot(data = mdlMedicalOut$Att$predSlopesCoreQlt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttCoreQlt.png",
  mdlMedicalOut$Att$predPltSlopesCoreQlt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We again sequentially tested whether the fulfillment of the core need during an interaction was (1) related to more positive outgroup attitudes, (2) higher perceived interaction quality, and (3) whether the variance explained by the core need is assumed by the perceived interaction quality if considered jointly. We find that in the multilevel models, the fulfillment of core need fulfillment during outgroup contacts was associated with more positive outgroup attitudes (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCore, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreCI, varName = "KeyNeedFulfillment_cwc")`) and also predicted higher perceived interaction quality (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Qlt$lmeSlopesCore, lmerCI = mdlMedicalOut$Qlt$lmerSlopesCoreCI, varName = "KeyNeedFulfillment_cwc")`). Additionally, once we consider the influences of core need fulfillment and interaction quality on outgroup attitudes jointly, we find that perceived interaction quality is a substantially stronger predictor (random slopes mode; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreQlt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreQltCI, varName = "qualityOverall_cwc")`) and the unique variance explained by core need fulfillment was roughly half of its original effect size (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreQlt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreQltCI, varName = "KeyNeedFulfillment_cwc")`). These results indicate that in this dataset the the fulfillment of core situational needs had a significant influence on outgroup attitudes and this effect is likely in parts explained by its effect through perceived interaction quality. 

\faQuestionCircle\ Are we sure that we don't want some sort of bootstrapped indirect effect? 

\subsubsection{Compare Fulfillment of Core Need and Allport's Conditions}

```{r AllportVsCore, include=FALSE}

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeSlopesAllport, 
      mdlMedicalOut$Att$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  kbl(
    .,
    caption = "Medical: Comparison of Allport's Conditions to Core Situational Need",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

AIC(
  mdlMedicalOut$Att$lmerSlopesAllport,
  mdlMedicalOut$Att$lmerSlopesCore
)

BIC(
  mdlMedicalOut$Att$lmerSlopesAllport,
  mdlMedicalOut$Att$lmerSlopesCore
)

performance::compare_performance(
  mdlMedicalOut$Att$lmerSlopesAllport,
  mdlMedicalOut$Att$lmerSlopesCore
)
```

```{r medicalOutModelInterceptAttCoreAllport, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptCoreAllport <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc + AllportsCondition_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptCoreAllport <-
    lmer(
      AttitudesDutch ~ KeyNeedFulfillment_cwc + AllportsCondition_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerInterceptCoreAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerInterceptCoreAllport)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull, 
  mdlMedicalOut$Att$lmeInterceptAllport,
  mdlMedicalOut$Att$lmeInterceptCoreAllport
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptCoreAllport <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptCoreAllport)
```

```{r medicalOutModelSlopesAttCoreAllport, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesCoreAllport <-
  lme(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + AllportsCondition_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc + AllportsCondition_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesCoreAllport <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + AllportsCondition_cwc +
      (1 + KeyNeedFulfillment_cwc + AllportsCondition_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerSlopesCoreAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesCoreAllport)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull,
  mdlMedicalOut$Att$lmeInterceptCoreAllport,
  mdlMedicalOut$Att$lmeSlopesCoreAllport
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varSlopesCoreAllport <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesCoreAllport)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesCoreAllport <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesCoreAllport, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesCoreQlt[[1]],
  mdlMedicalOut$Att$diagSlopesCoreQlt[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesCoreQlt[[3]],
  mdlMedicalOut$Att$diagSlopesCoreQlt[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesCoreAllport <- 
  dtMedicalSupp$medicalOutWithinBetween %>% 
  filter(complete.cases(KeyNeedFulfillment, AllportsCondition)) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesCoreAllport,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(KeyNeedFulfillment, AllportsCondition)) %>%
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesCoreAllport <-
    ggplot(data = mdlMedicalOut$Att$predSlopesCoreQlt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttCoreAllport.png",
  mdlMedicalOut$Att$predPltSlopesCoreAllport,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

To compare the models using either Allport's conditions or the core need fulfillment to predict outgroup attitudes, we first assess relative model performance indices (i.e., Akaike information criterion, and Bayesian information criterion), and then consider the two predictors in a joint model to see whether the two approaches predict the same variance in outgroup attitudes. When comparing the model selection indices we find that the fulfillment of the situation core need, indeed performs slightly better than the model using Allport's conditions ($AIC_{CoreNeed}$ `r format(round(AIC(mdlMedicalOut$Att$lmerSlopesCore), 2), nsmall = 2)` < `r format(round(AIC(mdlMedicalOut$Att$lmerSlopesAllport), 2), nsmall = 2)` $AIC_{Allport}$, and $BIC_{CoreNeed}$ `r format(round(BIC(mdlMedicalOut$Att$lmerSlopesCore), 2), nsmall = 2)` < `r format(round(BIC(mdlMedicalOut$Att$lmerSlopesAllport), 2), nsmall = 2)` $BIC_{Allport}$). Additionally, when considering the predictors jointly, we find that both significantly predict outgroup attitudes with similar sized regression parameters (random slopes model; Allport's Conditions: `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreAllport, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreAllportCI, varName = "AllportsCondition_cwc")`, Core Need: `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreAllport, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreAllportCI, varName = "KeyNeedFulfillment_cwc")`). This indicates that, although both Allport's conditions and the core need fulfillment seem to (in part) work through perceived interaction quality, they explain different aspects of the variance in outgroup attitudes and do not constitute one another.  

\subsubsection{Robustness}

```{r medicalModelAttNullInt, include=FALSE}
# Create and save Model
mdlMedical$lmerAttNullInt <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
             data = dtMedical$full %>%
               filter(complete.cases(
                 OutgroupInteraction
               ))) # use optim if it does not converge

mdlMedical$lmeAttNullInt <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtMedical$full %>%
      filter(complete.cases(
        OutgroupInteraction
      )),
    na.action = na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(mdlMedical$lmerAttNull) #or with the lme function
summ(mdlMedical$lmerAttNullInt, digits = 3)
```

```{r medicalModelInterceptAttCoreInt, include=FALSE}
# Create and save Model
mdlMedical$lmeInterceptAttCoreInt <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc * OutgroupInteraction,
    random =  ~ 1 | PID,
    na.action = na.omit,
    data = dtMedical$full
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedical$lmerInterceptAttCoreInt <- lmer(
    AttitudesDutch ~ KeyNeedFulfillment_cwc * OutgroupInteraction + (1 | PID),
    data = dtMedical$full
  ),
  confint = TRUE,
  digits = 3
)

mdlMedical$lmerInterceptAttCoreIntCI <- 
  confint(method = "Wald", mdlMedical$lmerInterceptAttCoreInt)

# Compare new model to previous step
anova(mdlMedical$lmeAttNullInt, 
      mdlMedical$lmeInterceptAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedical$varInterceptAttCoreInt <- 
  lme4::VarCorr(mdlMedical$lmeInterceptAttCoreInt)
```
```{r medicalModelSlopesAttCoreIntX, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedical$lmeSlopesAttCoreInt <- lme(
  AttitudesDutch ~
    KeyNeedFulfillment_cwc * OutgroupInteraction,
  random = ~ 1 + KeyNeedFulfillment_cwc + OutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  na.action = na.omit,
  data = dtMedical$full
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedical$lmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc * OutgroupInteraction +
      (1 + KeyNeedFulfillment_cwc + OutgroupInteraction | PID),
    data = dtMedical$full
  ), 
  confint = TRUE,
  digits = 3
)

mdlMedical$lmerSlopesAttCoreIntCI <- 
  confint(method = "Wald", mdlMedical$lmerSlopesAttCoreInt)

# Compare new model to previous step
anova(mdlMedical$lmeAttNullInt, 
      mdlMedical$lmeInterceptAttCoreInt,
      mdlMedical$lmeSlopesAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedical$varSlopesAttCoreInt <- 
  lme4::VarCorr(mdlMedical$lmeSlopesAttCoreInt)

# Assumption Checks:
mdlMedical$diagSlopesAttCoreInt <-
  sjPlot::plot_model(mdlMedical$lmerSlopesAttCoreInt, type = "diag")
grid.arrange(
  mdlMedical$diagSlopesAttCoreInt[[1]],
  mdlMedical$diagSlopesAttCoreInt[[2]]$`PID`,
  mdlMedical$diagSlopesAttCoreInt[[3]],
  mdlMedical$diagSlopesAttCoreInt[[4]]
)

# Plot prediction model
mdlMedical$predSlopesAttCoreInt <- 
  dtMedical$full %>%
  filter(complete.cases(KeyNeedFulfillment, OutgroupInteraction)) %>%
  filter(PID %in% dtMedicalSupp$medicalPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedical$lmeSlopesAttCoreInt,
                           dtMedical$full %>% 
                             filter(complete.cases(KeyNeedFulfillment, OutgroupInteraction)) %>%
                             filter(PID %in% dtMedicalSupp$medicalPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedical$predPltSlopesAttCoreInt <-
    ggplot(data = mdlMedical$predSlopesAttCoreInt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Medical_PredictionPlot_SlopesAttCoreInt.png",
  mdlMedical$predPltSlopesAttCoreInt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We again checked for alternative models to the core need fulfillment. First, when considering generalized situational core need fulfillment together with whether an intergroup contact took place, we find that there is no significant main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "KeyNeedFulfillment_cwc")`) but a stronger interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "KeyNeedFulfillment_cwc:OutgroupInteractionYes")`). Together with a significant main effect of having an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "OutgroupInteractionYes")`), this indicates that it is not key need fulfillment in general --- but key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. This finding is consistent with the results of the previous studies.

```{r medicalOutModelInterceptAttCoreSdt, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptCoreSdt <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptCoreSdt <- lmer(
    AttitudesDutch ~ KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# To be compared against a model with only the self determination theory needs
mdlMedicalOut$Att$lmeInterceptSdt <-
  lme(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

summ(
  mdlMedicalOut$Att$lmerInterceptSdt <- lmer(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous steps
anova(
  mdlMedicalOut$Att$lmeInterceptSdt,
  mdlMedicalOut$Att$lmeInterceptCoreSdt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptCoreSdt <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptCoreSdt)
```

```{r medicalOutModelSlopesAttCoreSdt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesCoreSdt <-
  lme(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc + Competence_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim", maxIter = 100, msMaxIter = 100),
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerSlopesCoreSdtCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesCoreSdt)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeInterceptSdt,
      mdlMedicalOut$Att$lmeInterceptCoreSdt, 
      mdlMedicalOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# model with SDT only
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesSdt <-
  lme(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesSdt <- lmer(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeInterceptSdt,
      mdlMedicalOut$Att$lmeSlopesSdt, 
      mdlMedicalOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")


# Save variances
mdlMedicalOut$Att$varSlopesCoreSdt <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesCoreSdt)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesCoreSdt <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesCoreSdt, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesCoreSdt[[1]],
  mdlMedicalOut$Att$diagSlopesCoreSdt[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesCoreSdt[[3]],
  mdlMedicalOut$Att$diagSlopesCoreSdt[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesCoreSdt <- 
  dtMedicalSupp$medicalOutWithinBetween %>%
  filter(complete.cases(
    KeyNeedFulfillment,
    Autonomy, Competence, Relatedness
    )) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID, Autonomy, Competence, Relatedness) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesCoreSdt,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(
                               KeyNeedFulfillment,
                               Autonomy, Competence, Relatedness
                             )) %>%
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesCoreSdt <-
    ggplot(data = mdlMedicalOut$Att$predSlopesCoreSdt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttCoreStd.png",
  mdlMedicalOut$Att$predPltSlopesCoreSdt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

# Model comparison
medicalSdtComp <-
  anova(
    mdlMedicalOut$Att$lmerSlopesSdt, 
    mdlMedicalOut$Att$lmerSlopesCoreSdt
  ) %>%
  as.data.frame()
medicalSdtCompDf <- medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Df"]
medicalSdtCompN <- sapply(ranef(mdlMedicalOut$Att$lmerSlopesCoreSdt), nrow)
medicalSdtCompChi <- medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2)
medicalSdtCompP <-
  ifelse(medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001,
         "< .001",
         paste0("= ", medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3)))

medicalSdtCompChiSq <- paste0("$\\chi^2$(", medicalSdtCompDf, ", \\textit{N} = ", medicalSdtCompN, ") = ", medicalSdtCompChi, ", \\textit{p} ", medicalSdtCompP)
```

In a final step we again checked whether during the interaction the core situational need remains a meaningful predictor even when taking other fundamental psychological needs into account. We find that the core need adds significantly above a model with only the self determination theory needs (random slopes models; `r medicalSdtCompChiSq`). We find that the core need explains the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "KeyNeedFulfillment_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all of the three fundamental needs. However, similar to the previous study, in this large sample relatedness (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Relatedness_cwc")`), competence (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Competence_cwc")`) and autonomy (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Autonomy_cwc")`) each also predicted positive outgroup attitudes independently. However, the regression coefficient is three times as large for the core need fulfillment (with all scaling being equal). For full results see Online Supplementary Information B.

```{r intergroupGeneralTbl, include=FALSE}
# Table of intergroup contact in ESM data:
# lm
#    #Contact
#     AvQual
#     #Contact*AvQual
# lme
#     OutgroupInteraction
#     NonOutgroupInteraction

# OLS 
# Study 1:
mdlWorker$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtWorkerSupp$workerAvFreQual)
# Study 2:
mdlStudent$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtStudentSupp$studentContactFreq)
# Study 3: 
mdlMedical$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtMedicalSupp$medicalContactFreq)

# tabModelTest <- tab_model(mdlWorker$lmAttFreqQualX,
#                           mdlStudent$lmAttFreqQualX,
#                           mdlMedical$lmAttFreqQualX)

summ(mdlWorker$lmAttFreqQualX)

mdlTblElementsGeneralLm <- list(mdlWorker$lmAttFreqQualX,
                                mdlStudent$lmAttFreqQualX,
                                mdlMedical$lmAttFreqQualX)

mdlPrepLmGeneral <- list()
for (i in 1:length(mdlTblElementsGeneralLm)) {
  mdlPrepLmGeneral[[i]] <- lmTblPrep(mdlTblElementsGeneralLm[[i]])
}
mdlTblGeneralLm <- data.frame(
  coef = c(
    sapply(mdlPrepLmGeneral, function(x) x[1]$coeficients$coef) %>% as.character %>% unique,
    names(mdlPrepLmGeneral[[1]]$fit)
  )
)
for (i in 1:length(mdlPrepLmGeneral)){
  mdlTblGeneralLm <- join(mdlTblGeneralLm, mdlPrepLmGeneral[[i]]$mdlTbl, by = "coef")
}

# lme
# Study 1: 
dtWorkerSupp$workerWithinBetween$AttitudesDutch <- dtWorkerSupp$workerWithinBetween$thermometerDutch_1
mdlWorker$lmerInterceptAttTypeTbl <- lmer(
    AttitudesDutch ~ OutgroupInteraction + NonOutgroupInteraction + (1 | PID),
    data = dtWorkerSupp$workerWithinBetween
  )
dtWorkerSupp$workerWithinBetween$AttitudesDutch_zwc <- dtWorkerSupp$workerWithinBetween$thermometerDutch_1
mdlWorker$lmerInterceptAttTypeTblZ <- lmer(
    AttitudesDutch_zwc ~ OutgroupInteraction_zwc + NonOutgroupInteraction_zwc + (1 | PID),
    data = dtWorkerSupp$workerWithinBetween
  )
# Study 2:
mdlStudent$lmerSlopesAttType <- lmer(
    AttitudesDutch ~
      OutgroupInteraction + NonOutgroupInteraction +
      (1 + OutgroupInteraction + NonOutgroupInteraction | PID),
    data = dtStudentSupp$studentWithinBetween
  )
mdlStudent$lmerSlopesAttTypeZ <- lmer(
    AttitudesDutch_zwc ~
      OutgroupInteraction_zwc + NonOutgroupInteraction_zwc +
      (1 + OutgroupInteraction_zwc + NonOutgroupInteraction_zwc | PID),
    data = dtStudentSupp$studentWithinBetween
  )
# Study 3:
mdlMedical$lmerSlopesAttType <- lmer(
    AttitudesDutch ~
      OutgroupInteraction + NonOutgroupInteraction +
      (1 + OutgroupInteraction + NonOutgroupInteraction | PID),
    data = dtMedicalSupp$medicalWithinBetween
  )
mdlMedical$lmerSlopesAttTypeZ <- lmer(
    AttitudesDutch_zwc ~
      OutgroupInteraction_zwc + NonOutgroupInteraction_zwc +
      (1 + OutgroupInteraction_zwc + NonOutgroupInteraction_zwc | PID),
    data = dtMedicalSupp$medicalWithinBetween
  )


mdlTblElementsGeneralLmer <- list(
  c(mdlWorker$lmerInterceptAttTypeTbl, mdlWorker$lmerInterceptAttTypeTblZ),
  c(mdlStudent$lmerSlopesAttType, mdlStudent$lmerSlopesAttTypeZ),
  c(mdlMedical$lmerSlopesAttType, mdlMedical$lmerSlopesAttTypeZ)
  )

mdlPrepGeneral <- list()
for (i in 1:length(mdlTblElementsGeneralLmer)) {
  mdlPrepGeneral[[i]] <- lmerTblPrep(mdlTblElementsGeneralLmer[[i]][[1]], mdlTblElementsGeneralLmer[[i]][[2]])
}

mdlTblGeneralLmer <- data.frame(
  coef = c(
    sapply(mdlPrepGeneral, function(x) x[1]$coeficients$coef) %>% as.character %>% unique,
    names(mdlPrepGeneral[[1]]$random),
    names(mdlPrepGeneral[[1]]$fit)
  )
)
for (i in 1:length(mdlPrepGeneral)){
  mdlTblGeneralLmer <- join(mdlTblGeneralLmer, mdlPrepGeneral[[i]]$mdlTbl, by = "coef")
}

names(mdlTblGeneralLmer) <- make.unique(names(mdlTblGeneralLmer))
mdlTblGeneral <-
  merge(mdlTblGeneralLm,
        mdlTblGeneralLmer %>% 
          mutate(coef = gsub("R2Marg_R2Cond", "R2_R2_adjusted", coef)),
        by = "coef",
        all = TRUE) 
names(mdlTblGeneral) <- make.unique(names(mdlTblGeneral))
mdlTblGeneral <- mdlTblGeneral %>%
  arrange(match(coef, c(
    sapply(mdlPrepLmGeneral, function(x) x[1]$coeficients$coef) %>% as.character %>% unique,
    sapply(mdlPrepGeneral, function(x) x[1]$coeficients$coef) %>% as.character %>% unique %>% setdiff(., "(Intercept)"),
    names(mdlPrepGeneral[[1]]$random),
    "Groups",
    names(mdlPrepLmGeneral[[1]]$fit),
    setdiff(names(mdlPrepGeneral[[1]]$fit), c(names(mdlPrepLmGeneral[[1]]$fit), "Groups"))
  ))) %>%
  replace(is.na(.), "")

mdlTblGeneral$coef <- mapvalues(
  mdlTblGeneral$coef,
  from = c(
    "sigmaSq",
    "tau00",
    "tau11",
    "rho01",
    "rho00",
    "fTest",
    "R2",
    "R2_adjusted",
    "R2_R2_adjusted",
    "R2_marginal",
    "R2_conditional",
    "R2Marg_R2Cond"
  ),
  to = c(
    "$\\sigma^2$",
    "$\\tau_{00}$",
    "$\\tau_{11}$",
    "$\\rho_{01}$",
    "$\\rho_{00}$",
    "F Test",
    "$R^2$",
    "$R^2_{adjusted}$",
    "$R^{2 (a)}$",
    "$R^2_{marginal}$",
    "$R^2_{conditional}$",
    "$R^2_{marginal} / R^2_{conditional}$"
  )
)

# Headers
mdlTblGeneralHeader <- data.frame(
  data = as.character(mdlTblGeneral[mdlTblGeneral$coef == "data",]),
  formula = as.character(mdlTblGeneral[mdlTblGeneral$coef == "formula",])
) %>%
  filter(data != "",
         data != "data") %>%
  mutate(study = str_extract(data, "Worker|Student|Medical")) %>%
  mutate(study = gsub("Worker", "Study 1", study)) %>%
  mutate(study = gsub("Student", "Study 2", study)) %>%
  mutate(study = gsub("Medical", "Study 3", study)) %>%
  mutate(dv = sub(" ~.*", "", formula)) %>%
  mutate(dv = gsub("Raw", " ", dv))

mdlTblGeneralHeaderDv <- data.frame(names = mdlTblGeneralHeader$dv, span = 2) %>% 
  mutate(names = as.character(names)) %>%
  rbind(c("", 1), .) %>%
  mutate(span = as.numeric(span))

mdlTblGeneralHeaderStudy <- rbind.data.frame(rle(mdlTblGeneralHeader$study)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)


# Long Table
mdlTblGeneralLong <- mdlTblGeneral %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    #format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  ) %>%
  kable_classic() %>%
  add_header_above(., mdlTblGeneralHeaderStudy) %>%
  add_header_above(
    .,
    c(
      "",
      "Contact [Full Sample]" = 6,
      "Self-Determination Theory [Outgroup Interactions only]" = 6
    )
  ) %>%
  pack_rows("Random", 7, 11) %>%
  pack_rows("Fit", 12, 27) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    )
  ) %>%
  gsub("_cwc", "", ., fixed = TRUE) 

# shortened Table
mdlTblGeneralShort <- mdlTblGeneral %>%
  filter(
    !coef %in% c(
      "data",
      "formula",
      "groupId",
      "$R^2$",
      "$R^2_{adjusted}$",
      "$R^2_{marginal}$",
      "$R^2_{conditional}$",
      "logLik",
      "deviance"
    )
  ) %>%
  kbl(
    .,
    caption = "Intergroup General",
    format = "latex",
    linesep = "",
    booktabs = TRUE,
    col.names = c("", rep(c("$B$", "$\\eta_p$"), (ncol(.)-1)/4), rep(c("$B$", "$\\beta$"), (ncol(.)-1)/4)),
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  )  %>%
  kable_classic() %>%
  add_header_above(., mdlTblGeneralHeaderStudy) %>%
  add_header_above(
    .,
    c(
      "",
      "Aggregated [across participants]" = 6,
      "Contemporaneous [within participants]" = 6
    )
  ) %>%
  pack_rows("Random", 7, 11) %>%
  pack_rows("Fit", 12, 18) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    ),
    alphabet = c("For linear regression: $R^2 / R^2_{adjusted}$, for multilevel regression: $R^2_{marginal} / R^2_{conditional}$ ")
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("_cwc", "", ., fixed = TRUE)   %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  kableExtra::landscape() 
  save_kable("Tables/mdlContactGeneral.tex")
mdlTblGeneralShort
```

```{r intergroupNeedsTbl, include=FALSE}
# Table of core need and Allports Conditions (potentially two tables — e.g., needs + allport)
# all lmer models :-)
# make different options

# collect relevant models
# Study 1:
# Rename variables for consistency
tblDtS1Needs <- dtWorkerSupp$workerOutWithinBetween %>%
  select(
    Attitude = thermometerDutch_1,
    AttitudeZ = thermometerDutch_1_zwc,
    CoreNeed = keymotive_fulfillemt_1_cwc,
    CoreNeedZ = keymotive_fulfillemt_1_zwc,
    QualityRaw = quality_overall_1,
    Quality = quality_overall_1_cwc,
    QualityZ = quality_overall_1_zwc,
    PID = PID
  )
# Quality ~ CoreNeed
tblLmerS1QltInterceptCore <- lmer(
  QualityRaw ~ CoreNeed + (1 | PID),
  data = tblDtS1Needs
)
tblLmerS1QltInterceptCoreZ <- lmer(
  QualityZ ~ CoreNeedZ + (1 | PID),
  data = tblDtS1Needs
)
# Attitude ~ CoreNeed
tblLmerS1AttSlopeCore <- lmer(
  Attitude ~ CoreNeed + (1 + CoreNeed | PID),
  data = tblDtS1Needs
)
tblLmerS1AttSlopeCoreZ <- lmer(
  AttitudeZ ~ CoreNeedZ + (1 + CoreNeedZ | PID),
  data = tblDtS1Needs
)
# Attitude ~ CoreNeed + Quality
tblLmerS1AttSlopeCoreQlt <- lmer(
  Attitude ~ CoreNeed + Quality + (1 + CoreNeed + Quality | PID),
  data = tblDtS1Needs
)
tblLmerS1AttSlopeCoreQltZ <- lmer(
  AttitudeZ ~ CoreNeedZ + QualityZ + (1 + CoreNeedZ + QualityZ | PID),
  data = tblDtS1Needs
)


# Study 2:
# Rename variables for consistency
tblDtS2Needs <- dtStudentSupp$studentOutWithinBetween %>%
  select(
    Attitude = AttitudesDutch,
    AttitudeZ = AttitudesDutch_zwc,
    CoreNeed = KeyNeedFullfillment_cwc,
    CoreNeedZ = KeyNeedFullfillment_zwc,
    QualityRaw = quality_overall,
    Quality = quality_overall_cwc,
    QualityZ = quality_overall_zwc,
    PID = PID
  )
# Quality ~ CoreNeed
tblLmerS2QltSlopesCore <- lmer(
  QualityRaw ~ CoreNeed + (1 + CoreNeed | PID),
  data = tblDtS2Needs
)
tblLmerS2QltSlopesCoreZ <- lmer(
  QualityZ~ CoreNeedZ + (1 + CoreNeedZ | PID),
  data = tblDtS2Needs
)
# Attitude ~ CoreNeed
tblLmerS2AttSlopesCore <- lmer(
  Attitude ~ CoreNeed + (1 + CoreNeed | PID),
  data = tblDtS2Needs
)
tblLmerS2AttSlopesCoreZ <- lmer(
  AttitudeZ ~ CoreNeedZ + (1 + CoreNeedZ | PID),
  data = tblDtS2Needs
)
# Attitude ~ CoreNeed + Quality
tblLmerS2AttSlopesCoreQlt <- lmer(
  Attitude ~ CoreNeed + Quality + (1 + CoreNeed + Quality | PID),
  data = tblDtS2Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
tblLmerS2AttSlopesCoreQltZ <- lmer(
  AttitudeZ ~ CoreNeedZ + QualityZ + (1 + CoreNeedZ + QualityZ | PID),
  data = tblDtS2Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)


# Study 3:
# Rename variables for consistency
tblDtS3Needs <- dtMedicalSupp$medicalOutWithinBetween %>%
  select(
    Attitude = AttitudesDutch,
    AttitudeZ = AttitudesDutch_zwc,
    CoreNeed = KeyNeedFulfillment_cwc,
    CoreNeedZ = KeyNeedFulfillment_zwc,
    Allport = AllportsCondition_cwc,
    AllportZ = AllportsCondition_zwc,
    QualityRaw = qualityOverall,
    Quality = qualityOverall_cwc,
    QualityZ = qualityOverall_zwc,
    PID = PID
  )
# Quality ~ CoreNeed
tblLmerS3QltSlopesCore <- lmer(
  QualityRaw ~ CoreNeed + (1 + CoreNeed | PID),
  data = tblDtS3Needs
)
tblLmerS3QltSlopesCoreZ <- lmer(
  QualityZ ~ CoreNeedZ + (1 + CoreNeedZ | PID),
  data = tblDtS3Needs
)
# Attitude ~ CoreNeed
tblLmerS3AttSlopesCore <- lmer(
  Attitude ~ CoreNeed + (1 + CoreNeed | PID),
  data = tblDtS3Needs
)
tblLmerS3AttSlopesCoreZ <- lmer(
  AttitudeZ ~ CoreNeedZ + (1 + CoreNeedZ | PID),
  data = tblDtS3Needs
)
# Attitude ~ CoreNeed + Quality
tblLmerS3AttSlopesCoreQlt <- lmer(
  Attitude ~ CoreNeed + Quality + (1 + CoreNeed + Quality | PID),
  data = tblDtS3Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
tblLmerS3AttSlopesCoreQltZ <- lmer(
  AttitudeZ ~ CoreNeedZ + QualityZ + (1 + CoreNeedZ + QualityZ | PID),
  data = tblDtS3Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
# Quality ~ Allport
tblLmerS3QltSlopesAllport <- lmer(
  QualityRaw ~ Allport + (1 + Allport | PID),
  data = tblDtS3Needs
)
tblLmerS3QltSlopesAllportZ <- lmer(
  QualityZ ~ AllportZ + (1 + AllportZ | PID),
  data = tblDtS3Needs
)
# Attitude ~ Allport
tblLmerS3AttSlopesAllport <- lmer(
  Attitude ~ Allport + (1 + Allport | PID),
  data = tblDtS3Needs
)
tblLmerS3AttSlopesAllportZ <- lmer(
  AttitudeZ ~ AllportZ + (1 + AllportZ | PID),
  data = tblDtS3Needs
)
# Attitude ~ Allport + Quality
tblLmerS3AttSlopesAllportQlt <- lmer(
  Attitude ~ Allport + Quality + (1 + Allport + Quality | PID),
  data = tblDtS3Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
tblLmerS3AttSlopesAllportQltZ <- lmer(
  AttitudeZ ~ AllportZ + QualityZ + (1 + AllportZ + QualityZ | PID),
  data = tblDtS3Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
# Attitude ~ Allport + CoreNeed
tblLmerS3AttSlopesAllportCore <- lmer(
  Attitude ~ CoreNeed + Allport + (1 + CoreNeed + Allport | PID),
  data = tblDtS3Needs
)
tblLmerS3AttSlopesAllportCoreZ <- lmer(
  AttitudeZ ~ CoreNeedZ + AllportZ + (1 + CoreNeedZ + AllportZ | PID),
  data = tblDtS3Needs
)


mdlTblElements <- list(
  # Study 1:
  c(tblLmerS1QltInterceptCore, tblLmerS1QltInterceptCoreZ),
  c(tblLmerS1AttSlopeCore, tblLmerS1AttSlopeCoreZ),
  c(tblLmerS1AttSlopeCoreQlt, tblLmerS1AttSlopeCoreQltZ),
  # Study 2:
  c(tblLmerS2QltSlopesCore, tblLmerS2QltSlopesCoreZ),
  c(tblLmerS2AttSlopesCore, tblLmerS2AttSlopesCoreZ),
  c(tblLmerS2AttSlopesCoreQlt, tblLmerS2AttSlopesCoreQltZ),
  # Study 3:
  c(tblLmerS3QltSlopesCore, tblLmerS3QltSlopesCoreZ),
  c(tblLmerS3AttSlopesCore, tblLmerS3AttSlopesCoreZ),
  c(tblLmerS3AttSlopesCoreQlt, tblLmerS3AttSlopesCoreQlt),
  c(tblLmerS3QltSlopesAllport, tblLmerS3QltSlopesAllportZ),
  c(tblLmerS3AttSlopesAllport, tblLmerS3AttSlopesAllportZ),
  c(tblLmerS3AttSlopesAllportQlt, tblLmerS3AttSlopesAllportQltZ),
  c(tblLmerS3AttSlopesAllportCore, tblLmerS3AttSlopesAllportCoreZ)
  )

# lmerTblPrep(mdlTblElements[[1]][[1]], mdlTblElements[[1]][[2]])

mdlPrep <- list()
for (i in 1:length(mdlTblElements)) {
  mdlPrep[[i]] <- lmerTblPrep(mdlTblElements[[i]][[1]], mdlTblElements[[i]][[2]])
}

mdlTbl <- data.frame(
  coef = c(
    sapply(mdlPrep, function(x) x[1]$coeficients$coef) %>% unlist %>% unique,
    names(mdlPrep[[1]]$random),
    names(mdlPrep[[1]]$fit)
  )
)
for (i in 1:length(mdlPrep)){
  mdlTbl <- join(mdlTbl, mdlPrep[[i]]$mdlTbl, by = "coef")
  #mdlTbl <- merge(mdlTbl, mdlPrep[[i]]$mdlTbl, by = "coef", all = TRUE, sort = FALSE, no.dups = TRUE, suffixes=c("", ""))
}

mdlTblHeader <- data.frame(
  data = as.character(mdlTbl[mdlTbl$coef == "data",]),
  formula = as.character(mdlTbl[mdlTbl$coef == "formula",])
) %>%
  filter(data != "",
         data != "data") %>%
  mutate(study = str_extract(data, "S1|S2|S3")) %>%
  mutate(study = gsub("S", "Study ", study)) %>%
  mutate(dv = sub(" ~.*", "", formula)) %>%
  mutate(dv = gsub("Raw", " ", dv)) %>%
  mutate(pred = str_extract(formula, "(CoreNeed \\+ Allport)|CoreNeed|Allport")) %>%
  mutate(header = paste(study, pred, sep = " - "))

mdlTblHeaderFreq <- rbind.data.frame(rle(mdlTblHeader$header)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)

mdlTblHeader2 <- data.frame(names = mdlTblHeader$dv, span = 2) %>% 
  mutate(names = as.character(names)) %>%
  rbind(c("", 1), .) %>%
  mutate(span = as.numeric(span))

mdlTblHeader2.2 <- rbind.data.frame(rle(mdlTblHeader$dv)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)

mdlTbl$coef <- mapvalues(
  mdlTbl$coef,
  from = c(
    "sigmaSq",
    "tau00",
    "tau11",
    "rho01",
    "rho00",
    "R2_marginal",
    "R2_conditional", 
    "R2Marg_R2Cond"
  ),
  to = c(
    "$\\sigma^2$",
    "$\\tau_{00}$",
    "$\\tau_{11}$",
    "$\\rho_{01}$",
    "$\\rho_{00}$",
    "$R^2_{marginal}$",
    "$R^2_{conditional}$",
    "$R^2_{marginal}$ / $R^2_{conditional}$"
  )
)

# Full Table
mdlTblTheoreticalLong <- mdlTbl %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Theoretical Test: Core Need Fulfillment and Allport's Conditions",
    #format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    escape = FALSE,
    digits = 3
  ) %>%
  kable_classic() %>%
  add_header_above(., mdlTblHeader2) %>%
  add_header_above(., mdlTblHeaderFreq) %>%
  pack_rows("Fixed", 1, 4) %>%
  pack_rows("Random", 5, 9) %>%
  pack_rows("Fit", 10, 21)

# shortened Table
mdlTblTheoreticalShort <- mdlTbl %>%
  replace(is.na(.), "")
names(mdlTblTheoreticalShort) <- make.unique(names(mdlTblTheoreticalShort))
mdlTblTheoreticalShort <- mdlTblTheoreticalShort %>%
  filter(
    !coef %in% c(
      "data",
      "formula",
      "groupId",
      "$R^2_{marginal}$",
      "$R^2_{conditional}$",
      "logLik",
      "deviance"
    )
  ) %>%
  kbl(
    .,
    caption = "Core Need Fulfillment and Allport's Conditions",
    format = "latex",
    linesep = "",
    booktabs = TRUE,
    col.names = c("", rep(c("$B$", "$\\beta$"), (ncol(.)-1)/2)),
    align = rep("c", ncol(.)),
    escape = FALSE,
    digits = 3
  ) %>%
  kable_classic() %>%
  add_header_above(., mdlTblHeader2) %>%
  add_header_above(., mdlTblHeaderFreq) %>%
  pack_rows("Fixed", 1, 4) %>%
  pack_rows("Random", 5, 9) %>%
  pack_rows("Fit", 10, 15) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/mdlTheory.tex")
mdlTblTheoreticalShort
```

```{r robustnessTbl, include=FALSE}
# Table of all robustness checks (w/ and w/out SDT only)

# Full Sample
# Study 1:
robustTblWorkerFull <- 
  dtWorkerSupp$workerWithinBetween %>%
  select(
    AttitudesDutch = thermometerDutch_1,
    AttitudesDutch_zwc = thermometerDutch_1_zwc,
    CoreNeed_cwc = keyMotiveFulfilled_cwc,
    CoreNeed_zwc = keyMotiveFulfilled_zwc,
    OutgroupInteraction = OutgroupInteraction,
    OutgroupInteraction_zwc = OutgroupInteraction_zwc,
    PID = PID
  )
mdlWorkerLmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc * OutgroupInteraction +
      (1 + CoreNeed_cwc + OutgroupInteraction | PID),
    data = robustTblWorkerFull
  )
mdlWorkerLmerSlopesAttCoreIntZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc * OutgroupInteraction_zwc +
      (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID),
    data = robustTblWorkerFull
  )
#Study 2:
robustTblStudentFull <- 
  dtStudentSupp$studentWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFullfillment_cwc,
    CoreNeed_zwc = KeyNeedFullfillment_zwc,
    OutgroupInteraction = OutgroupInteraction,
    OutgroupInteraction_zwc = OutgroupInteraction_zwc, 
    PID = PID
  )
mdlStudentLmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc * OutgroupInteraction +
      (1 + CoreNeed_cwc + OutgroupInteraction | PID),
    data = robustTblStudentFull
  )
mdlStudentLmerSlopesAttCoreIntZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc * OutgroupInteraction_zwc +
      (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID),
    data = robustTblStudentFull
  )
#Study 3:
robustTblMedicalFull <- 
  dtMedicalSupp$medicalWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFulfillment_cwc,
    CoreNeed_zwc = KeyNeedFulfillment_zwc,
    OutgroupInteraction = OutgroupInteraction,
    OutgroupInteraction_zwc = OutgroupInteraction_zwc, 
    PID = PID
  )
mdlMedicalLmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc * OutgroupInteraction +
      (1 + CoreNeed_cwc + OutgroupInteraction | PID),
    #data = dtMedical$full
    data = robustTblMedicalFull
  )
mdlMedicalLmerSlopesAttCoreIntZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc * OutgroupInteraction_zwc +
      (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID),
    #data = dtMedical$full
    data = robustTblMedicalFull
  )

# SDT
# Study 1:
robustTblWorkerOut <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  select(
    AttitudesDutch = thermometerDutch_1,
    AttitudesDutch_zwc = thermometerDutch_1_zwc,
    CoreNeed_cwc = keymotive_fulfillemt_1_cwc,
    CoreNeed_zwc = keymotive_fulfillemt_1_zwc,
    Competence_cwc = competence_1_cwc,
    Competence_zwc = competence_1_zwc,
    Autonomy_cwc = autonomy_1_cwc,
    Autonomy_zwc = autonomy_1_zwc,
    Relatedness_cwc = relatedness_1_cwc,
    Relatedness_zwc = relatedness_1_zwc,
    PID = PID
  )
mdlWorkerOutLmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = robustTblWorkerOut
  )
mdlWorkerOutLmerSlopesCoreSdtZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc +
      (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID),
    data = robustTblWorkerOut
  )
# Study 2:
robustTblStudentOut <- 
  dtStudentSupp$studentOutWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFullfillment_cwc,
    CoreNeed_zwc = KeyNeedFullfillment_zwc,
    Competence_cwc = Competence_cwc,
    Competence_zwc = Competence_zwc,
    Autonomy_cwc = Autonomy_cwc,
    Autonomy_zwc = Autonomy_zwc,
    Relatedness_cwc = Relatedness_cwc,
    Relatedness_zwc = Relatedness_zwc,
    PID = PID
  )
mdlStudentOutLmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = robustTblStudentOut
  )
mdlStudentOutLmerSlopesCoreSdtZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc +
      (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID),
    data = robustTblStudentOut
  )
# Study 3:
robustTblMedicalOut <- 
  dtMedicalSupp$medicalOutWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFulfillment_cwc,
    CoreNeed_zwc = KeyNeedFulfillment_zwc,
    Competence_cwc = Competence_cwc,
    Competence_zwc = Competence_zwc,
    Autonomy_cwc = Autonomy_cwc,
    Autonomy_zwc = Autonomy_zwc,
    Relatedness_cwc = Relatedness_cwc,
    Relatedness_zwc = Relatedness_zwc,
    PID = PID
  )
mdlMedicalOutLmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = robustTblMedicalOut
  )
mdlMedicalOutLmerSlopesCoreSdtZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc +
      (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID),
    data = robustTblMedicalOut
  )

# collect models for table
mdlRobustTblElements <- list(
  # full
  c(mdlWorkerLmerSlopesAttCoreInt, mdlWorkerLmerSlopesAttCoreIntZ),
  c(mdlStudentLmerSlopesAttCoreInt, mdlStudentLmerSlopesAttCoreIntZ),
  c(mdlMedicalLmerSlopesAttCoreInt, mdlMedicalLmerSlopesAttCoreIntZ),
  # outgroup
  c(mdlWorkerOutLmerSlopesCoreSdt, mdlWorkerOutLmerSlopesCoreSdtZ),
  c(mdlStudentOutLmerSlopesCoreSdt, mdlStudentOutLmerSlopesCoreSdtZ),
  c(mdlMedicalOutLmerSlopesCoreSdt, mdlMedicalOutLmerSlopesCoreSdtZ)
  )

mdlRobustPrep <- list()
for (i in 1:length(mdlRobustTblElements)) {
  mdlRobustPrep[[i]] <- lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])
}

mdlRobustTbl <- data.frame(
  coef = c(
    sapply(mdlRobustPrep, function(x) x[1]$coeficients$coef) %>% unlist %>% unique,
    names(mdlRobustPrep[[1]]$random),
    names(mdlRobustPrep[[1]]$fit)
  )
)
for (i in 1:length(mdlRobustPrep)){
  mdlRobustTbl <- join(mdlRobustTbl, mdlRobustPrep[[i]]$mdlTbl, by = "coef")
  #mdlTbl <- merge(mdlRobustTbl, mdlRobustPrep[[i]]$mdlTbl, by = "coef", all = TRUE, sort = FALSE, no.dups = TRUE, suffixes=c("", ""))
}

mdlRobustTblHeader <- data.frame(
  data = as.character(mdlRobustTbl[mdlRobustTbl$coef == "data",]),
  formula = as.character(mdlRobustTbl[mdlRobustTbl$coef == "formula",])
) %>%
  filter(data != "",
         data != "data") %>%
  mutate(study = str_extract(data, "Worker|Student|Medical")) %>%
  mutate(study = gsub("Worker", "Study 1", study)) %>%
  mutate(study = gsub("Student", "Study 2", study)) %>%
  mutate(study = gsub("Medical", "Study 3", study)) %>%
  mutate(dv = sub(" ~.*", "", formula)) %>%
  mutate(dv = gsub("Raw", " ", dv)) %>%
  mutate(pred = str_extract(formula, "CoreNeed|Allport")) %>%
  mutate(header = paste(study, pred, sep = " - "))

mdlRobustTblHeaderFreq <- rbind.data.frame(rle(mdlRobustTblHeader$header)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)

mdlRobustTblHeaderDv <- data.frame(names = mdlRobustTblHeader$dv, span = 2) %>% 
  mutate(names = as.character(names)) %>%
  rbind(c("", 1), .) %>%
  mutate(span = as.numeric(span))

mdlRobustTblHeaderStudy <- rbind.data.frame(rle(mdlRobustTblHeader$study)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)

mdlRobustTbl$coef <- mapvalues(
  mdlRobustTbl$coef,
  from = c(
    "sigmaSq",
    "tau00",
    "tau11",
    "rho01",
    "rho00",
    "R2_marginal",
    "R2_conditional", 
    "R2Marg_R2Cond"
  ),
  to = c(
    "$\\sigma^2$",
    "$\\tau_{00}$",
    "$\\tau_{11}$",
    "$\\rho_{01}$",
    "$\\rho_{00}$",
    "$R^2_{marginal}$",
    "$R^2_{conditional}$",
    "$R^2_{marginal}$ / $R^2_{conditional}$"
  )
)

# Long Table
mdlTblRobustLong <- mdlRobustTbl %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    #format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  ) %>%
  kable_classic() %>%
  add_header_above(., mdlRobustTblHeaderStudy) %>%
  add_header_above(
    .,
    c(
      "",
      "Contact [Full Sample]" = 6,
      "Self-Determination Theory [Outgroup Interactions only]" = 6
    )
  ) %>%
  pack_rows("Fixed", 1, 7) %>%
  pack_rows("Random", 8, 12) %>%
  pack_rows("Fit", 13, 25) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    )
  ) %>%
  gsub("_cwc", "", ., fixed = TRUE) 

# shortened Table
mdlTblRobustShort <- mdlRobustTbl %>%
  replace(is.na(.), "")
names(mdlTblRobustShort) <- make.unique(names(mdlTblRobustShort))
mdlTblRobustShort <- mdlTblRobustShort %>%
  filter(
    !coef %in% c(
      "data",
      "formula",
      "groupId",
      "$R^2_{marginal}$",
      "$R^2_{conditional}$",
      "logLik",
      "deviance"
    )
  ) %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    format = "latex",
    linesep = "",
    booktabs = TRUE,
    col.names = c("", rep(c("$B$", "$\\beta$"), (ncol(.)-1)/2)),
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  )  %>%
  kable_classic() %>%
  add_header_above(., mdlRobustTblHeaderStudy) %>%
  add_header_above(
    .,
    c(
      "",
      "Contact [Full Sample]" = 6,
      "Self-Determination Theory [Outgroup Interactions only]" = 6
    )
  ) %>%
  pack_rows("Fixed", 1, 7) %>%
  pack_rows("Random", 8, 12) %>%
  pack_rows("Fit", 13, 18) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("_cwc", "", ., fixed = TRUE)  %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/mdlRobustness.tex")
mdlTblRobustShort
```

\input{Tables/mdlContactGeneral}
\input{Tables/mdlTheory}
\input{Tables/mdlRobustness}

<!-- \begin{figure}[h] -->

<!-- \centering -->

<!-- \caption{PRISMA Diagrams for the Theoretical, Methodological, and Empirical Literature.} -->

<!-- \makebox[\textwidth]{\includegraphics[width=\paperwidth]{Figures/PrismaCombined}} -->

<!-- \label{fig:PrismaCombined} -->

<!-- \end{figure} -->

<!-- \input{Tables/ExclusionsCombined} -->

<!-- \input{Tables/TheoreticalExclusion} -->

<!-- \begin{figure}[h] -->

<!-- \centering -->

<!-- \caption{Literature Levels: (A) Bar graph of the experience aspect frequencies for theoretical, methodological, and broader empirical literature. (B) Bar graph of the number of experience aspects used for theoretical, methodological, and broader empirical literature. (C) Average number of additional aspects included when the aspect was considered for theoretical, methodological, and broader empirical literature [Mean ± 95\%CI].} -->

<!-- \includegraphics[width=\textwidth]{Figures/LiteratureComparison-1} -->

<!-- \caption*{Note that in (C) within each literature body the aspects are not mutually exclusive (and thus not independent) because scales can include multiple experience aspects.} -->

<!-- \label{fig:LiteratureComparison} -->

<!-- \end{figure} -->
