---
output: latex_fragment
editor_options:
  chunk_output_type: console
bibliography: references.bib
csl: apa.csl
---

```{r setup, include=FALSE}
# R Studio Clean-Up
cat("\014") # clear console
# rm(list=ls()) # clear workspace - use restart R instead [cmd/alt + shift + F10]
gc() # garbage collector

# Install and Load Packages
# !IMPORTANT!
# BEFORE FIRST RENDER:
# To install all relevant packages please run "renv::restore()" (or renv::init() and then initiate from lockfile) in the console before the first use to ensure that all packages are using the correct version.
# to store the packages in a contained library within the project folder: renv::settings$use.cache(FALSE) and add 'RENV_CONFIG_SANDBOX_ENABLED = FALSE' to an '.Renviron' file
lib <- c(
  "rmarkdown",
  "knitr",
  "berryFunctions",
  "remedy",
  "bookdown",
  "brms",
  "psych",
  "ggplot2",
  "ggthemes",
  "purrr",
  "haven",
  "RColorBrewer",
  "plotly",
  "gridExtra",
  "ggpattern",
  "lme4",
  "nlme",
  "jtools",
  "gtsummary",
  "sessioninfo",
  "tibble",
  "pander",
  "devtools",
  "mada",
  "data.table",
  "plyr",
  "dplyr",
  "tidyr",
  "Hmisc",
  "kableExtra",
  "papaja",
  "stringr",
  "stringi",
  "reshape2",
  "lubridate",
  "misty",
  "sjPlot",
  "sjmisc",
  "metafor"
)
invisible(lapply(lib, library, character.only = TRUE))
rm(lib)

# Load Custom Packages
source("./scripts/functions/fun.panel.R")
source("./scripts/functions/themes.R")
source("./scripts/functions/binaryCor.R")
source("./scripts/functions/MlCorMat.R")
source("./scripts/functions/MlTbl.R")
source("./scripts/functions/metaLmer.R")

# Markdown Options
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # set working directory
knitr::opts_knit$get("root.dir") # check working directory
options(
  scipen = 999,
  digits = 4,
  width = 400
) # removes scientific quotation
# knitr::opts_chunk$set(echo = TRUE, cache = F, cache.path = rprojroot::find_rstudio_root_file('cache/')) # cache settings

# Global Chunk Options
knitr::opts_chunk$set(
  fig.width = 12,
  fig.height = 8,
  fig.path = "Figures/",
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)
```

```{r import, include=FALSE}
load("data/wrangled.RData")
# remove accidental surplus to avoid conflicts
# rm(list = ls(pattern = "mdl|medicalSdtComp"))
```

\section{Study 1}

Based on our main hypotheses, the aim of our first study was to specifically test the general contact hypothesis, the influence of core need fulfillment, and perceived interaction quality during intergroup contacts. To this aim, we conducted an intensive longitudinal survey study with recent migrants to the Netherlands. Data was collected from May 5\textsuperscript{th} through June 6\textsuperscript{th}, 2018 (and all participants started the study within the first two days).

The full surveys are available in our OSF repository \citep{KreienkampMasked2022a} and the full data description is available in Online Supplementary Material A. Correlations and descriptive statistics of the included variables are available in Table \ref{tab:descrFullWide} and Table \ref{tab:descrOutWide}.

\subsection{Methods}

```{r workerSampleInfo, include=FALSE}
# combine education measure
workerOccupation <- 
  dtWorker$clean %>%
  select(PID, starts_with("occupation")) %>%
  mutate_all(as_factor) %>% 
  mutate_all(as.character) %>%
  replace(is.na(.), "") %>%
  unite("occupation", -PID, sep = "/") %>%
  mutate(occupation = trimws(occupation, which = "both", whitespace = "[/]")) %>%
  distinct

# summarize participant characteristics
workerSampleInfo <- 
  dtWorker$clean %>%
  group_by(PID) %>%
  summarise(
    dailiesN = n(), 
    morningN = sum(daytime=="morning"),
    afternoonN = sum(daytime=="afternoon"),
    age = age,
    gender = as_factor(Gender),
    edu = as_factor(education_level),
    nationality = as_factor(nationality)
  ) %>%
  distinct

# add occupation variable
workerSampleInfo <- merge(workerSampleInfo, workerOccupation)
rm(workerOccupation)

# look at frequencies of characteristics 
table(workerSampleInfo$gender)
table(workerSampleInfo$edu)
table(workerSampleInfo$occupation)
table(as.character(workerSampleInfo$nationality))

# categorical variables:
# - outgroup contact
# - non-outgroup contact

# continuous variables:
# - Core Need fulfillment
# - SDT Competence
# - SDT Autonomy
# - SDT Relatedness
# - Interaction Quality
# - Outgroup Attitudes
######
# within cor
# between cor
# ---
# Grand mean
# SD between
# SD within
# Proportion of variance
# __ __ __
# Note:
# N within ppt.s 
######

# divide into trait and state
dtWorkerSupp$workerWithinBetween <-
  MlTraitState(
    data = dtWorkerSupp$workerInteractionType,
    id = "PID",
    selection =
      c(
        "keyMotiveFulfilled",
        "competence.daily.all",
        "autonomy.daily.all",
        "relatedness.daily.all",
        "thermometerDutch_1",
        "keymotive_fulfillemt_1",
        "competence_1",
        "autonomy_1",
        "relatedness_1", 
        "quality_overall_1", 
        "OutgroupInteraction",
        "NonOutgroupInteraction", 
        "OutgroupInteractionM",
        "NonOutgroupInteractionM"
      )
  )

dtWorkerSupp$workerOutWithinBetween <-
  MlTraitState(
    data = dtWorkerSupp$workerInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection =
      c(
        "keyMotiveFulfilled",
        "thermometerDutch_1",
        "keymotive_fulfillemt_1",
        "competence_1",
        "autonomy_1",
        "relatedness_1", 
        "quality_overall_1"
      )
  )
```

```{r workerVarDescr, include=FALSE}
workerMlCor <-
  MlCorMat(
    data = dtWorkerSupp$workerInteractionType,
    id = "PID",
    selection = c("keyMotiveFulfilled", "competence.daily.all", "autonomy.daily.all", "relatedness.daily.all", "quality_overall_1", "thermometerDutch_1"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Quality", "Attitudes NL")
  ) 

workerMlCor %>%
  kable(
    .,
    caption = "Worker: Multilevel Core Variable Descriptives",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/workerVarDescr.tex")
```

```{r workerOutVarDescr, include=FALSE}
workerOutMlCor <-
  MlCorMat(
    data = dtWorkerSupp$workerInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection = c("keymotive_fulfillemt_1", "competence_1", "autonomy_1", "relatedness_1", "quality_overall_1", "thermometerDutch_1"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Quality", "Attitudes NL")
  )

workerOutMlCor %>%
  kable(
    .,
    caption = "Worker: Multilevel Core Variable Descriptives (Outgroup Contact Only)",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/workerOutVarDescr.tex")

# misty::multilevel.descript(dtWorkerSupp$workerWithinBetween$keyMotiveFulfilled, cluster = dtWorkerSupp$workerWithinBetween$PID)
```


\subsubsection{Participants} After receiving ethical approval from the University Masked for Peer Review, we recruited `r nrow(workerSampleInfo)` migrants using the local paid participant pool and specifically targeted non-Dutch migrants to participate in our study. Participants reported on their interactions for at least 30 days with two daily measures (capturing the morning and afternoon). With this design, we aimed at getting 50-60 measurements per participant (\textit{M} = `r format(round(mean(workerSampleInfo$dailiesN),2), nsmall=2)`, \textit{SD} = `r format(round(sd(workerSampleInfo$dailiesN),2), nsmall=2)`, \textit{total N} = `r format(sum(workerSampleInfo$dailiesN), big.mark=",")`). This is a common number of measurements found in experience sampling studies and offers sufficient power to model processes within and between participants \citep[e.g., for a systematic review see][]{AanhetRot2012}. Participants were compensated for their participation with up to 34 Euros – each two Euros for pre- and post-questionnaire as well as 50 Eurocents for every experience sampling measurement occasion. The sample consisted of relatively young, educated, and western migrants from the global north ($M_{age}$ = `r format(round(mean(workerSampleInfo$age),2), nsmall=2)`, $SD_{age}$ = `r format(round(sd(workerSampleInfo$age),2), nsmall=2)`, `r nrow(workerSampleInfo %>% filter(gender == "Female"))` women, `r nrow(workerSampleInfo %>% filter(occupation == "student"))` students). The sample accurately describes the largest groups of migrants in the region \citep[][]{GemeenteGroningen2015}.

\subsubsection{Procedure} The study itself consisted of three main parts, an introductory pre-measurement, and the daily experience sampling measurements, as well as a concluding post-measurement. After giving informed consent, participants started by filling in an online pre-questionnaire assessing demographics and general information about their immigration. Over the next thirty days, the participants were then invited twice a day (at 12 pm and 7pm) to reflect upon their interactions, psychological need fulfillments, and current attitudes towards the Dutch outgroup (\textit{median survey duration} = `r seconds_to_period(median(dtWorker$clean$Duration__in_seconds_)) %>% as.character`, \textit{MAD duration} = `r seconds_to_period(round(mad(dtWorker$clean$Duration__in_seconds_))) %>% as.character`). General compliance was high (`r format(round(sum(workerSampleInfo$dailiesN)/(nrow(workerSampleInfo)*62)*100,2), nsmall=2)`\% of all invited surveys were filled in)\footnote{Two participants completed only two days (among the others, participation was `r format(round(sum(workerSampleInfo$dailiesN[workerSampleInfo$dailiesN>3])/(nrow(workerSampleInfo[workerSampleInfo$dailiesN>3,])*62)*100,2), nsmall=2)`\%).}. The response rates were approximately equal during mornings (\textit{n} = `r format(sum(workerSampleInfo$morningN), big.mark=",")`) and afternoons (\textit{n} = `r format(sum(workerSampleInfo$afternoonN), big.mark=",")`) and most measurements were completed within four hours of the invitation. After the final day of experience sampling measurements, participants were invited to fill in a longer post measurement survey that mirrored the pre-measurement. All key variables for this study were part of the short experience sampling surveys. 

\subsubsection{Materials}

\paragraph{Intergroup Contact}To test the prerequisite effect of intergroup contact, every experience sampling measurement started with the question “\textit{Did you meet a Dutch person this morning [/afternoon]? (In person interaction for at least 10 minutes)}”. Our participants recorded between `r dtWorkerSupp$workerAvFreQual$SumContactNL[dtWorkerSupp$workerAvFreQual$SumContactNL > 0] %>% min`--`r dtWorkerSupp$workerAvFreQual$SumContactNL[dtWorkerSupp$workerAvFreQual$SumContactNL > 0] %>% max`
interactions with Dutch outgroup members (`r dtWorkerSupp$workerAvFreQual$PercContactNL[dtWorkerSupp$workerAvFreQual$PercContactNL > 0] %>% min %>% round(2) %>% format(nsmall=2)`--`r dtWorkerSupp$workerAvFreQual$PercContactNL[dtWorkerSupp$workerAvFreQual$PercContactNL > 0] %>% max %>% round(2) %>% format(nsmall=2)`\% of individual experience sampling measurements; `r format(sum(dtWorkerSupp$workerAvFreQual$SumContactNL), big.mark=",")` of all `r format(nrow(dtWorkerSupp$workerInteractionType), big.mark=",")` experience sampling responses)\footnote{Two participants only recorded two experience sampling measurements each and non of these included outgroup contacts. These participants are removed from any analyses that focus on outgroup contacts.}.

\paragraph{Psychological Needs}Irrespective of whether participants had an interaction with Dutch people or not, everyone answered a short series of questions on psychological need fulfillment. However, whereas participants with interactions reported on the need fulfillment during the interaction, people without interactions with Dutch people judged the past daytime period in general. To assess the fulfillment of psychological needs, we included two types of need measurement: (1) the core situational need and (2) general self-determination theory needs.

For the core situational need, we asked participants in an open ended text field: “\textit{What was your most important goal [during the interaction / this morning / this afternoon]?}”. Then, with reference to the text entry, we asked how much this core need was fulfilled during the interaction or the past daytime period: “\textit{[The interaction / You] fulfilled your goal: [-previous text entry-]}” on a continuous slider scale ranging from strongly disagree (-50) to strongly agree (+50).

We, additionally, included a common measure of three self-determination theory needs \citep[see][]{Downie2008}. The items were introduced either by “\textit{During the interaction:}” or “\textit{This morning [/afternoon]:}” and measured autonomy (“\textit{I was myself.}”), competence (“\textit{I felt competent.}”), and relatedness (without intergroup contact “\textit{I had a strong need to belong}”; with intergroup contact: “\textit{I shared information about myself.}” and “\textit{The other(s) shared information about themselves.}”). All items were rated on a continuous slider scale from very little (-50) to a great deal (+50).

\paragraph{Perceived Interaction Quality}As an explanatory mechanism, we assessed ratings of the perceived interaction quality. As our main measurement, participants rated the statement “\textit{Overall the interaction was …}” on two continuous slider scales measuring pleasantness \citep[from unpleasant (-50) to pleasant (+50)) and meaningfulness (from superficial (-50) to meaningful (+50); both items adapted from][]{Downie2008}.

\paragraph{Outgroup Attitudes}At the end of every experience sampling measurement we asked all participants about their current attitudes towards the Dutch – our main dependent variable. To assess the momentary outgroup evaluation we used the common feeling thermometer: “How favorable do you feel towards the Dutch?” \citep[][]{Lavrakas2008}. Participants then rated their attitude on a continuous slider scale from “very cold – 0” through “no feeling – 50” to “very warm – 100”. Both the question phrasing as well as the tick labels were consistent with large-scale panel surveys \citep[e.g.,][]{DeBell2010}.

\subsection{Results}

```{r WorkerFreqAttCor, include=FALSE}
dtWorkerSupp$workerAvFreQual <-
  dtWorkerSupp$workerAvFreQual %>%
  mutate(
    SumContactNL_c = SumContactNL - mean(SumContactNL, na.rm = TRUE),
    SumContactNLAll_c = SumContactNLAll - mean(SumContactNLAll, na.rm = TRUE),
    AvAttitude_c = AvAttitude - mean(AvAttitude, na.rm = TRUE),
    AvQuality_c = AvQuality - mean(AvQuality, na.rm = TRUE)
  )

# correlation panel
pairs.panels.new(
  dtWorkerSupp$workerAvFreQual %>% select(SumContactNL, SumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)",
    "Sum:\nNumber of Outgroup Contacts (NL)",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)

# correlation panel with interaction sums winsorized
pairs.panels.new(
  dtWorkerSupp$workerAvFreQual %>% select(WinSumContactNL, WinSumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)\n[Winsorized]",
    "Sum:\nNumber of Outgroup Contacts (NL)\n[Winsorized]",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)

rContactAvg <- dtWorkerSupp$workerAvFreQual %>% 
  select(SumContactNL, SumContactNLAll, AvAttitude) %>%
  as.matrix %>%
  rcorr

rContactAvgMax <- format(round(max(abs(rContactAvg$r[rownames(rContactAvg$r) != "AvAttitude","AvAttitude"])),2), nsmall = 2)
pContactAvgMin <- format(round(min(rContactAvg$P[rownames(rContactAvg$P) != "AvAttitude","AvAttitude"]),3), nsmall = 3)

# Average Interaction Quality and their Average Outgroup Attitudes
rAttitudeQuality <- dtWorkerSupp$workerAvFreQual %>% 
  select(AvQuality, AvAttitude) %>%
  as.matrix %>%
  rcorr
```

```{r workerModelOlsAttFreqQual, include=FALSE}
# create list to store Worker models
mdlWorker <- list()

# regression
mdlWorker$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtWorkerSupp$workerAvFreQual)
# summary(lmWorkerAttFreqQualX)

summ(
  mdlWorker$lmAttFreqQualX,
  confint = TRUE,
  digits = 3
)

mdlWorker$lmAttFreqQualXEta <-
  effectsize::eta_squared(mdlWorker$lmAttFreqQualX, partial = TRUE)

interactions::interact_plot(
  mdlWorker$lmAttFreqQualX,
  pred = AvQuality_c,
  modx = SumContactNL_c,
  interval = TRUE,
  partial.residuals = TRUE
)

interactions::johnson_neyman(mdlWorker$lmAttFreqQualX,
                             pred = AvQuality_c,
                             modx = SumContactNL_c,
                             alpha = .05)

```

```{r workerModelMLAttNull, include=FALSE}
# Create and save Model
mdlWorker$lmerAttNull <-
  lme4::lmer(thermometerDutch_1 ~ 1 + (1 | PID),
    data = dtWorker$full
  ) # use optim if it does not converge

mdlWorker$lmeAttNull <-
  lme(
    thermometerDutch_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorker$full,
    na.action=na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(lmerWorkerAttNull) #or with the lme function
summ(mdlWorker$lmerAttNull, digits = 3, center = TRUE)

# Save variances
mdlWorker$varAttNull <- 
  VarCorr(mdlWorker$lmeAttNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorker$tauAttNull <- 
  as.numeric(mdlWorker$varAttNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorker$sigmaAttNull <- 
  as.numeric(mdlWorker$varAttNull[2])
# The ICC estimate (between/between+within) is:
mdlWorker$IccAttNull <-
  (as.numeric(mdlWorker$varAttNull[1]) / (as.numeric(mdlWorker$varAttNull[1]) + as.numeric(mdlWorker$varAttNull[2])))
mdlWorker$IccPercAttNull <-
  ((as.numeric(mdlWorker$varAttNull[1]) / (as.numeric(mdlWorker$varAttNull[1]) + as.numeric(mdlWorker$varAttNull[2])))) * 100
```
```{r workerModelInterceptAttType, include=FALSE}
# Create and save Model
mdlWorker$lmeInterceptAttType <-
  lme(
    thermometerDutch_1 ~ OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM,
    random =  ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerInteractionType
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorker$lmerInterceptAttType <- lmer(
    thermometerDutch_1 ~ OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM + (1 | PID),
    data = dtWorkerSupp$workerInteractionType
  ),
  confint = TRUE,
  digits = 3
)

mdlWorker$lmerInterceptAttTypeCI <- 
  confint(method = "Wald", mdlWorker$lmerInterceptAttType)

# Compare new model to previous step
anova(mdlWorker$lmeAttNull, 
      mdlWorker$lmeInterceptAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorker$varInterceptAttType <- 
  lme4::VarCorr(mdlWorker$lmeInterceptAttType)
```

\subsubsection{Contact Hypothesis}
<!-- We tested the most general contact hypothesis in two steps. First, we assessed whether overall between participants more intergroup interactions were related to to more positive average outgroup attitudes. Second, we tested whether a potential positive effect on outgroup attitudes depended on the interaction quality (jointly with the number of interactions). We find that neither the overall number of contacts nor the number of experience sampling responses with a contact were significantly related with the average outgroup attitudes (all | \textit{r} | < `r rContactAvgMax`, all \textit{p} > `r pContactAvgMin`). However, we did find a medium sized correlation between the participants' average contact quality and their average outgroup attitudes (\textit{r} = `r format(round(rAttitudeQuality$r[rownames(rAttitudeQuality$r) != "AvAttitude","AvAttitude"],2), nsmall = 2)`, \textit{p} = `r format(round(rAttitudeQuality$P[rownames(rAttitudeQuality$r) != "AvAttitude","AvAttitude"],3), nsmall = 3)`). And when considering the number of contacts and average contact quality jointly in a linear regression, we additionally found a statistically significant interaction term (\textit{b} = `r coef(summary(mdlWorker$lmAttFreqQualX))["SumContactNL_c:AvQuality_c","Estimate"] %>% round(2) %>% format(nsmall=2)`, \textit{t}(`r mdlWorker$lmAttFreqQualX$df.residual`) = `r coef(summary(mdlWorker$lmAttFreqQualX))["SumContactNL_c:AvQuality_c","t value"] %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r coef(summary(mdlWorker$lmAttFreqQualX))["SumContactNL_c:AvQuality_c","Pr(>|t|)"] %>% round(3) %>% format(nsmall=3)`, $\eta_p^2$ = `r mdlWorker$lmAttFreqQualXEta %>% filter(Parameter == "SumContactNL_c:AvQuality_c") %>% select(Eta2_partial) %>% as.numeric %>% round(2) %>% format(nsmall=2)`), where in our sample with an increasing number of contacts the positive effect of average contact quality becomes weaker (also see Table \ref{tab:intergroupGeneralTblLong}).  -->
We used a multilevel regression to check whether having an interaction with an outgroup member had a situational (i.e., contemporaneous) effect within the participants. We find that having an outgroup contact is indeed associated with significantly more positive outgroup attitudes (`r MlCoeffLatex(lmeMdl = mdlWorker$lmeInterceptAttType, lmerCI = mdlWorker$lmerInterceptAttTypeCI, varName = "OutgroupInteractionC")`), even after controlling for having an interaction with a non-Dutch (which did not relate to outgroup attitudes independently). Additionally, while multi-level regressions are generally robust against unequal cell sizes, we correct for inequalities by use centered predictors and reintroducing the means as level two predictors. Nonetheless, we also offer an analysis of the joint data sets in Online Supplemental Material A (for full results see Table \ref{tab:intergroupGeneralTblLong}, Figure \ref{fig:ContactHypothesis}, and Online Supplementary Material A)\footnote{Interestingly, adding random slopes to this model did not explain additional variance. This is unusual and might indicate that the effect is very consistent across participants. However, the small number of participants, or other measurement issues provide an alternative explanation, which is why we offer a combined data set analyses following the individual studies.}. 
Thus, in our first data we find initial evidence that outgroup contacts show a positive effect on outgroup attitudes within real-life data. While this offers support for the most basic premise of the intergroup contact hypothesis (i.e., that any interaction will lead to more positive outgroup attitudes), this analysis does not consider any notion of interaction quality. We assess the conditional effects of interaction numbers and interaction quality ratings after we report on the individual studies to avoid under-powered analyses.

\subsubsection{Core Need}The main proposal of our article is that the success of an outgroup contact might be explained by whether or not the contact fulfilled the person's core situational need. This should, in turn, be due to a higher perceived contact quality. We sequentially test whether the fulfillment of the core need during an interaction is (1) related to more positive outgroup attitudes, (2) higher perceived contact quality, and (3) whether the variance explained by the core need is subsumed by the perceived contact quality if considered jointly (for full regression results see Table \ref{tab:intergroupNeedsTblLong} and Figure \ref{fig:AllportNeedFulfillment}). 

```{r workerOutModelMLAttNull, include=FALSE}
# create empty list to organize models
mdlWorkerOut <- 
  list(
    Att = list(),
    Qlt = list()
  )

# Create and save Model
mdlWorkerOut$Att$lmerNull <-
  lme4::lmer(thermometerDutch_1 ~ 1 + (1 | PID), 
             data = dtWorkerSupp$workerOutgroupInteraction) # use optim if it does not converge
mdlWorkerOut$Att$lmeNull <-
  lme(
    thermometerDutch_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutgroupInteraction,
    na.action=na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.ML.r) #or with the lme function
summ(mdlWorkerOut$Att$lmerNull, digits = 3, center = TRUE)

# Save variances
mdlWorkerOut$Att$varNull <- 
  VarCorr(mdlWorkerOut$Att$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorkerOut$Att$tauNull <- 
  as.numeric(mdlWorkerOut$Att$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorkerOut$Att$sigmaNull <- 
  as.numeric(mdlWorkerOut$Att$varNull[2])
# The ICC estimate (between/between+within) is:
mdlWorkerOut$Att$IccNull <-
  (as.numeric(mdlWorkerOut$Att$varNull[1]) / (as.numeric(mdlWorkerOut$Att$varNull[1]) + as.numeric(mdlWorkerOut$Att$varNull[2])))
mdlWorkerOut$Att$IccPercNull <-
  ((as.numeric(mdlWorkerOut$Att$varNull[1]) / (as.numeric(mdlWorkerOut$Att$varNull[1]) + as.numeric(mdlWorkerOut$Att$varNull[2])))) * 100
```
```{r workerOutModelInterceptAttCore, include=FALSE}
# Create and save Model
mdlWorkerOut$Att$lmeInterceptCore <-
  lme(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc,
    random = ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Att$lmerInterceptCore <-
    lmer(
      thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + (1 | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlWorkerOut$Att$lmerInterceptCoreCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerInterceptCore)

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeNull, 
      mdlWorkerOut$Att$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varInterceptCore <-
  lme4::VarCorr(mdlWorkerOut$Att$lmeInterceptCore)

# The estimate of between-group (or Intercept variance) explained:
# Variance Explained = 1 – (Var with Predictor/Var without Predictor)
mdlWorkerOut$Att$varBtwInterceptCore <-
  1 - (mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["(Intercept)", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varBtwPercInterceptCore <-
  (1 - (mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["(Intercept)", "Variance"] %>% as.numeric)) * 100
# and the estimate of within-group (or residual variance) explained is:
mdlWorkerOut$Att$varWithinInterceptCore <-
  1 - (mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["Residual", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varWithinPercInterceptCore <-
  (1 - (mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varNull["Residual", "Variance"] %>% as.numeric)) * 100
```
```{r workerOutModelSlopesAttCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesCore <-
  lme(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesCore <- lmer(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc +
      (1 + keymotive_fulfillemt_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# all variables standardized within PPT
summ(
  mdlWorkerOut$Att$lmerSlopesCoreZ <- lmer(
    thermometerDutch_1_zwc ~
      keymotive_fulfillemt_1_zwc +
      (1 + keymotive_fulfillemt_1_zwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# standardized coefficients
stdCoef.merMod(mdlWorkerOut$Att$lmerSlopesCore)

# 95%CIs
mdlWorkerOut$Att$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerSlopesCore)

# Attempts at R^2
r2mlm::r2mlm(mdlWorkerOut$Att$lmerSlopesCore, bargraph = TRUE)
mitml::multilevelR2(mdlWorkerOut$Att$lmerSlopesCore)
performance::r2(mdlWorkerOut$Att$lmerSlopesCore)
performance::model_performance(mdlWorkerOut$Att$lmerSlopesCore)
performance::compare_performance(mdlWorkerOut$Att$lmerNull, 
                                 mdlWorkerOut$Att$lmerInterceptCore, 
                                 mdlWorkerOut$Att$lmerSlopesCore)

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeNull, 
      mdlWorkerOut$Att$lmeInterceptCore, 
      mdlWorkerOut$Att$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varSlopesCore <- 
  lme4::VarCorr(mdlWorkerOut$Att$lmeSlopesCore)

# The estimate of between-group (or Intercept variance) explained:
# Variance Explained = 1 – (Var with Predictor/Var without Predictor)
mdlWorkerOut$Att$varBtwSlopesCore <-
  1 - (mdlWorkerOut$Att$varSlopesCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varBtwPercSlopesCore <-
  (1 - (mdlWorkerOut$Att$varSlopesCore["(Intercept)", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["(Intercept)", "Variance"] %>% as.numeric)) * 100
# and the estimate of within-group (or residual variance) explained is:
mdlWorkerOut$Att$varWithinSlopesCore <-
  1 - (mdlWorkerOut$Att$varSlopesCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric)
mdlWorkerOut$Att$varWithinPercSlopesCore <-
  (1 - (mdlWorkerOut$Att$varSlopesCore["Residual", "Variance"] %>% as.numeric / mdlWorkerOut$Att$varInterceptCore["Residual", "Variance"] %>% as.numeric)) * 100

# Assumption Checks:
mdlWorkerOut$Att$diagSlopesCore <- 
  sjPlot::plot_model(mdlWorkerOut$Att$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlWorkerOut$Att$diagSlopesCore[[1]],
  mdlWorkerOut$Att$diagSlopesCore[[2]]$`PID`,
  mdlWorkerOut$Att$diagSlopesCore[[3]],
  mdlWorkerOut$Att$diagSlopesCore[[4]]
)

# Plot prediction model
mdlWorkerOut$Att$predSlopesCore <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  select(thermometerDutch_1, session, PID) %>% 
  mutate(measure = predict(mdlWorkerOut$Att$lmeSlopesCore,
                           dtWorkerSupp$workerOutWithinBetween,
                           re.form = NA
                           )
         )

(
  mdlWorkerOut$Att$predPltSlopesCore <-
    ggplot(data = mdlWorkerOut$Att$predSlopesCore, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/WorkerOut_PredictionPlot_SlopesAttCore.png",
  mdlWorkerOut$Att$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

```{r workerOutModelMLQltNull, include=FALSE}
# Create and save Model
mdlWorkerOut$Qlt$lmerNull <-
  lme4::lmer(quality_overall_1 ~ 1 + (1 | PID), 
             data = dtWorkerSupp$workerOutWithinBetween) # use optim if it does not converge

mdlWorkerOut$Qlt$lmeNull <-
  mdlWorkerOut$Qlt$lmeNull <- lme(
    quality_overall_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action=na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.Qual.ML.r) #or with the lme function
summ(mdlWorkerOut$Qlt$lmerNull, digits = 3)

# Save variances
mdlWorkerOut$Qlt$varNull <- 
  VarCorr(mdlWorkerOut$Qlt$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorkerOut$Qlt$tauNull <- 
  as.numeric(mdlWorkerOut$Qlt$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorkerOut$Qlt$sigmaNull <- 
  as.numeric(mdlWorkerOut$Qlt$varNull[2])
# The ICC estimate (between/between+within) is:
mdlWorkerOut$Qlt$IccNull <-
  (as.numeric(mdlWorkerOut$Qlt$varNull[1]) / (as.numeric(mdlWorkerOut$Qlt$varNull[1]) + as.numeric(mdlWorkerOut$Qlt$varNull[2])))
mdlWorkerOut$Qlt$IccPercNull <-
  ((as.numeric(mdlWorkerOut$Qlt$varNull[1]) / (as.numeric(mdlWorkerOut$Qlt$varNull[1]) + as.numeric(mdlWorkerOut$Qlt$varNull[2])))) * 100
```
```{r workerOutModelInterceptQltCore, include=FALSE}
# Create and save Model
mdlWorkerOut$Qlt$lmeInterceptCore <-
  lme(
    quality_overall_1 ~ keymotive_fulfillemt_1_cwc,
    random = ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Qlt$lmerInterceptCore <-
    lmer(
      quality_overall_1 ~ keymotive_fulfillemt_1_cwc + (1 | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# 95%CI
mdlWorkerOut$Qlt$lmerInterceptCoreCI <- 
  confint(method = "Wald", mdlWorkerOut$Qlt$lmerInterceptCore)

# Compare new model to previous step
anova(mdlWorkerOut$Qlt$lmeNull, 
      mdlWorkerOut$Qlt$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Qlt$varInterceptCore <-
  lme4::VarCorr(mdlWorkerOut$Qlt$lmeInterceptCore)
```
```{r workerOutModelSlopesQltCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Qlt$lmeSlopesCore <-
  lme(
    quality_overall_1 ~
      keymotive_fulfillemt_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Qlt$lmerSlopesCore <-
    lmer(
      quality_overall_1 ~
        keymotive_fulfillemt_1_cwc +
        (1 + keymotive_fulfillemt_1_cwc | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# 95%CI
mdlWorkerOut$Qlt$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlWorkerOut$Qlt$lmerSlopesCore)

# Compare new model to previous step
anova(mdlWorkerOut$Qlt$lmeNull, 
      mdlWorkerOut$Qlt$lmeInterceptCore, 
      mdlWorkerOut$Qlt$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Qlt$varSlopesCore <- 
  lme4::VarCorr(mdlWorkerOut$Qlt$lmeSlopesCore)
```
```{r workerOutModelInterceptAttCoreQlt, include=FALSE}
# Create and save Model
mdlWorkerOut$Att$lmeInterceptCoreQlt <-
  lme(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + quality_overall_1_cwc,
    random = ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Att$lmerInterceptCoreQlt <-
    lmer(
      thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + quality_overall_1_cwc + (1 | PID),
      data = dtWorkerSupp$workerOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

# 95% CI
mdlWorkerOut$Att$lmerInterceptCoreQltCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerInterceptCoreQlt)

# Compare new model to previous step
anova(
  mdlWorkerOut$Att$lmeNull, 
  mdlWorkerOut$Att$lmeInterceptCoreQlt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varInterceptCoreQlt <-
  lme4::VarCorr(mdlWorkerOut$Att$lmeInterceptCoreQlt)
```
```{r workerOutModelSlopesAttCoreQlt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesCoreQlt <-
  lme(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + quality_overall_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc + quality_overall_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    na.action=na.omit,
    data = dtWorkerSupp$workerOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesCoreQlt <- lmer(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + quality_overall_1_cwc +
      (1 + keymotive_fulfillemt_1_cwc + quality_overall_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlWorkerOut$Att$lmerSlopesCoreQltCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerSlopesCoreQlt)

# Compare new model to previous step
anova(
  mdlWorkerOut$Att$lmeNull,
  mdlWorkerOut$Att$lmeInterceptCoreQlt,
  mdlWorkerOut$Att$lmeSlopesCoreQlt
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorkerOut$Att$varSlopesCoreQlt <- 
  lme4::VarCorr(mdlWorkerOut$Att$lmeSlopesCoreQlt)

# Assumption Checks:
mdlWorkerOut$Att$diagSlopesCoreQlt <- 
  sjPlot::plot_model(mdlWorkerOut$Att$lmerSlopesCoreQlt, type = "diag")
grid.arrange(
  mdlWorkerOut$Att$diagSlopesCoreQlt[[1]],
  mdlWorkerOut$Att$diagSlopesCoreQlt[[2]]$`PID`,
  mdlWorkerOut$Att$diagSlopesCoreQlt[[3]],
  mdlWorkerOut$Att$diagSlopesCoreQlt[[4]]
)

# Plot prediction model
mdlWorkerOut$Att$predSlopesCoreQlt <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  select(thermometerDutch_1, session, PID) %>% 
  mutate(measure = predict(mdlWorkerOut$Att$lmeSlopesCoreQlt,
                           dtWorkerSupp$workerOutWithinBetween,
                           re.form = NA
                           )
         )

(
  mdlWorkerOut$Att$predPltSlopesCoreQlt <-
    ggplot(data = mdlWorkerOut$Att$predSlopesCoreQlt, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/WorkerOut_PredictionPlot_SlopesAttCoreQlt.png",
  mdlWorkerOut$Att$predPltSlopesCoreQlt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We find that in the multilevel models, the fulfillment of core situational needs during outgroup contacts was associated with more positive outgroup attitudes (random slopes model; `r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCore, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreCI, varName = "keymotive_fulfillemt_1_cwc")`) and also predicted higher perceived contact quality (random intercept model; `r MlCoeffLatex(lmeMdl = mdlWorkerOut$Qlt$lmeInterceptCore, lmerCI = mdlWorkerOut$Qlt$lmerInterceptCoreCI, varName = "keymotive_fulfillemt_1_cwc")`). Moreover, when we consider the influences of core need fulfillment and contact quality on outgroup attitudes jointly, we find that virtually all variance is explained by perceived contact quality (random slopes mode; `r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreQlt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreQltCI, varName = "quality_overall_1_cwc")`) and only little unique variance is still explained by core need fulfillment (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreQlt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreQltCI, varName = "keymotive_fulfillemt_1_cwc")`). We thus find support for our hypotheses and can conclude that in this data set the fulfillment of core situational needs had a significant influence on outgroup attitudes. Additionally, this effect is likely explained by its effect through perceived contact quality. 

<!-- \faQuestionCircle\ Are we sure that we don't want some sort of bootstrapped indirect effect?  -->

\subsubsection{Robustness}
```{r workerModelInterceptAttCoreInt, include=FALSE}
# Create and save Model
mdlWorker$lmeInterceptAttCoreInt <-
  lme(
    thermometerDutch_1 ~ keyMotiveFulfilled_cwc * OutgroupInteraction,
    random =  ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorker$lmerInterceptAttCoreInt <- lmer(
    thermometerDutch_1 ~ keyMotiveFulfilled_cwc * OutgroupInteraction + (1 | PID),
    data = dtWorkerSupp$workerWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlWorker$lmerInterceptAttCoreIntCI <- 
  confint(method = "Wald", mdlWorker$lmerInterceptAttCoreInt)

# Compare new model to previous step
anova(mdlWorker$lmeAttNull, 
      mdlWorker$lmeInterceptAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorker$varInterceptAttCoreInt <- 
  lme4::VarCorr(mdlWorker$lmeInterceptAttCoreInt)
```
```{r workerModelSlopesAttCoreIntX, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorker$lmeSlopesAttCoreInt <- lme(
  thermometerDutch_1 ~
    keyMotiveFulfilled_cwc * OutgroupInteraction,
  random = ~ 1 + keyMotiveFulfilled_cwc + OutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  na.action=na.omit,
  data = dtWorkerSupp$workerWithinBetween
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorker$lmerSlopesAttCoreInt <- lmer(
    thermometerDutch_1 ~
      keyMotiveFulfilled_cwc * OutgroupInteraction +
      (1 + keyMotiveFulfilled_cwc + OutgroupInteraction | PID),
    data = dtWorkerSupp$workerWithinBetween
  ), 
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlWorker$lmerSlopesAttCoreIntCI <- 
  confint(method = "Wald", mdlWorker$lmerSlopesAttCoreInt)

# Compare new model to previous step
anova(mdlWorker$lmeAttNull, 
      mdlWorker$lmeInterceptAttCoreInt,
      mdlWorker$lmeSlopesAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorker$varSlopesAttCoreInt <- 
  lme4::VarCorr(mdlWorker$lmeSlopesAttCoreInt)

# Assumption Checks:
mdlWorker$diagSlopesAttCoreInt <-
  sjPlot::plot_model(mdlWorker$lmerSlopesAttCoreInt, type = "diag")
grid.arrange(
  mdlWorker$diagSlopesAttCoreInt[[1]],
  mdlWorker$diagSlopesAttCoreInt[[2]]$`PID`,
  mdlWorker$diagSlopesAttCoreInt[[3]],
  mdlWorker$diagSlopesAttCoreInt[[4]]
)

# Plot prediction model
mdlWorker$predSlopesAttCoreInt <- 
  dtWorkerSupp$workerWithinBetween %>%
  select(thermometerDutch_1, session, PID) %>% 
  mutate(measure = predict(mdlWorker$lmeSlopesAttCoreInt,
                           dtWorkerSupp$workerWithinBetween,
                           re.form = NA
                           )
         )

(
  mdlWorker$predPltSlopesAttCoreInt <-
    ggplot(data = mdlWorker$predSlopesAttCoreInt, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Worker_PredictionPlot_SlopesAttCoreInt.png",
  mdlWorker$predPltSlopesAttCoreInt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

To build further confidence in our results, we assessed two additional models that might offer alternative explanations. First, to ensure that the effect of core need fulfillment is specific to an actual contact, we compared the effect to core need fulfillment in situations without an intergroup contact. For this, we analyzed the generalized situational core need fulfillment (either during a contact or about the daytime in general) and tested whether the effect differed during experience sampling measurements with and without outgroup contacts. We found no main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlWorker$lmeSlopesAttCoreInt, lmerCI = mdlWorker$lmerSlopesAttCoreIntCI, varName = "keyMotiveFulfilled_cwc")`) but a significant interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlWorker$lmeSlopesAttCoreInt, lmerCI = mdlWorker$lmerSlopesAttCoreIntCI, varName = "keyMotiveFulfilled_cwc:OutgroupInteraction")`; also see Table \ref{tab:robustnessTblLong} and Figure \ref{fig:Robustness}). Together with a significant main effect of having an outgroup contact, this indicates that it is not key need fulfillment in general --- but only key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. 

```{r workerOutModelInterceptAttCoreSdt, include=FALSE}
# Create and save Model
mdlWorkerOut$Att$lmeInterceptCoreSdt <-
  lme(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Att$lmerInterceptCoreSdt <- lmer(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc + (1 | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# To be compared against a model with only the self-determination theory needs
mdlWorkerOut$Att$lmeInterceptSdt <-
  lme(
    thermometerDutch_1 ~ competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

summ(
  mdlWorkerOut$Att$lmerInterceptSdt <- lmer(
    thermometerDutch_1 ~ competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc + (1 | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous steps
anova(
  mdlWorkerOut$Att$lmeInterceptSdt,
  mdlWorkerOut$Att$lmeInterceptCoreSdt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")
rm(lmeInterceptCoreRed)

# Save variances
mdlWorkerOut$Att$varInterceptCoreSdt <-
  lme4::VarCorr(mdlWorkerOut$Att$lmeInterceptCoreSdt)
```
```{r workerOutModelSlopesAttCoreSdt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesCoreSdt <-
  lme(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesCoreSdt <- lmer(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc +
      (1 + keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlWorkerOut$Att$lmerSlopesCoreSdtCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerSlopesCoreSdt)

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeInterceptSdt,
      mdlWorkerOut$Att$lmeInterceptCoreSdt, 
      mdlWorkerOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# model with SDT only
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesSdt <-
  lme(
    thermometerDutch_1 ~
      competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesSdt <- lmer(
    thermometerDutch_1 ~
      competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc +
      (1 + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeInterceptSdt,
      mdlWorkerOut$Att$lmeSlopesSdt, 
      mdlWorkerOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")


# Save variances
mdlWorkerOut$Att$varSlopesCoreSdt <- 
  lme4::VarCorr(mdlWorkerOut$Att$lmeSlopesCoreSdt)

# Assumption Checks:
mdlWorkerOut$Att$diagSlopesCoreSdt <- 
  sjPlot::plot_model(mdlWorkerOut$Att$lmerSlopesCoreSdt, type = "diag")
grid.arrange(
  mdlWorkerOut$Att$diagSlopesCoreSdt[[1]],
  mdlWorkerOut$Att$diagSlopesCoreSdt[[2]]$`PID`,
  mdlWorkerOut$Att$diagSlopesCoreSdt[[3]],
  mdlWorkerOut$Att$diagSlopesCoreSdt[[4]]
)

# Plot prediction model
mdlWorkerOut$Att$predSlopesCoreSdt <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  filter(!is.na(autonomy_1)) %>%
  select(thermometerDutch_1, session, PID, autonomy_1) %>% 
  mutate(measure = predict(mdlWorkerOut$Att$lmeSlopesCoreSdt,
                           dtWorkerSupp$workerOutWithinBetween %>% filter(!is.na(autonomy_1)),
                           re.form = NA
                           )
         )

(
  mdlWorkerOut$Att$predPltSlopesCoreSdt <-
    ggplot(data = mdlWorkerOut$Att$predSlopesCoreSdt, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/WorkerOut_PredictionPlot_SlopesAttCoreStd.png",
  mdlWorkerOut$Att$predPltSlopesCoreSdt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

# Model comparison
workerSdtComp <-
  anova(
    mdlWorkerOut$Att$lmerSlopesSdt, 
    mdlWorkerOut$Att$lmerSlopesCoreSdt
  ) %>%
  as.data.frame()
workerSdtCompDf <- workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Df"]
workerSdtCompN <- sapply(ranef(mdlWorkerOut$Att$lmerSlopesCoreSdt), nrow)
workerSdtCompChi <- workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2)
workerSdtCompP <-
  ifelse(workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001,
         "< .001",
         paste0("= ", workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3)))

workerSdtCompChiSq <- paste0("$\\chi^2$(", workerSdtCompDf, ", \\textit{N} = ", workerSdtCompN, ") = ", workerSdtCompChi, ", \\textit{p} ", workerSdtCompP)
```

In a final step, we controlled for other fundamental psychological needs during the contact. We focus on the three commonly considered self-determination needs (SDT): competence, autonomy, and relatedness. We find that the core need fulfillment adds significantly above a model with only the self-determination theory needs (random slopes models; `r workerSdtCompChiSq`). We also find that next to relatedness (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreSdt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreSdtCI, varName = "relatedness_1_cwc")`), the core need explains the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreSdt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreSdtCI, varName = "keymotive_fulfillemt_1_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all three fundamental needs (competence and autonomy needs turning non-significant; all \textit{b} < `r coef(summary(mdlWorkerOut$Att$lmeSlopesCoreSdt))[c("competence_1_cwc", "autonomy_1_cwc"),"Value"] %>% max %>% round(2) %>% format(nsmall=2)`, all \textit{p} > `r coef(summary(mdlWorkerOut$Att$lmeSlopesCoreSdt))[c("competence_1_cwc", "autonomy_1_cwc"),"p-value"] %>% min %>% round(3) %>% format(nsmall=3)`). For full results see see Table \ref{tab:robustnessTblLong}, Figure \ref{fig:Robustness}, and Online Supplementary Material A. There is, thus, considerable evidence lending confidence to the stability and relevance of psychological need fulfillment as a predictor of positive outgroup attitudes for natural intergroup contacts.

\section{Study 2}

The aim of Study 2 is similar to Study 1, as we again test the general contact hypothesis, the influence of core need fulfillment, and perceived contact quality during intergroup contacts. However, in this second study we collected a substantially larger sample of international students who recently arrived in the Netherlands and also improved the study design (e.g., pop-up explanations described later). The survey method again offers a large body of ecologically valid data on need satisfaction in real-life intergroup contact situations as these students will likely interact with the Dutch majority outgroup on a daily basis. Data was collected from November 19\textsuperscript{th}, 2018 through January 6\textsuperscript{th}, 2019.

The full surveys are available in our OSF repository \citep{KreienkampMasked2022a} and the full data description is available in Online Supplementary Material A. Correlations and descriptive statistics of the included variables are available in Table \ref{tab:descrFullWide} and Table \ref{tab:descrOutWide}.

\subsection{Methods}

```{r studentSampleInfo, include=FALSE}
# summarize participant characteristics
studentSampleInfo <- 
  dtStudents$full %>%
  mutate(gender = as.factor(ifelse(.$Gender == 1, "women", ifelse(.$Gender == 2, "man", ifelse(.$Gender == 3, "other", NA))))) %>%
  group_by(PID) %>%
  summarise(
    dailiesN = n(), 
    morningN = sum(periodMA=="morning"),
    afternoonN = sum(periodMA=="afternoon"),
    age = age,
    gender = gender,
    nationality = nationality
  ) %>%
  distinct

# look at frequencies of characteristics 
table(studentSampleInfo$gender)
table(as.character(studentSampleInfo$nationality))

# categorical variables:
# - outgroup contact
# - non-outgroup contact

# continuous variables:
# - Core Need fulfillment
# - SDT Competence
# - SDT Autonomy
# - SDT Relatedness
# - Interaction Quality
# - Outgroup Attitudes
######
# within cor
# between cor
# ---
# Grand mean
# SD between
# SD within
# Proportion of variance
# __ __ __
# Note:
# N within ppt.s 
######

# divide into trait and state
dtStudentSupp$studentWithinBetween <-
  MlTraitState(
    data = dtStudentSupp$studentInteractionType,
    id = "PID",
    selection =
      c(
        "KeyNeedFullfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AttitudesDutch",
        "quality_overall",
        "OutgroupInteraction",
        "NonOutgroupInteraction",
        "OutgroupInteractionM",
        "NonOutgroupInteractionM"
      )
  )
dtStudentSupp$studentOutWithinBetween <-
  MlTraitState(
    data = dtStudentSupp$studentInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection =
      c(
        "KeyNeedFullfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AttitudesDutch",
        "quality_overall"
      )
  )
```

```{r studentVarDescr, include=FALSE}
studentMlCor <-
  MlCorMat(
    data = dtStudentSupp$studentInteractionType,
    id = "PID",
    selection = c("KeyNeedFullfillment", "Competence", "Autonomy", "Relatedness", "quality_overall", "AttitudesDutch"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Quality", "Attitudes NL")
  ) 

studentMlCor %>%
  kable(
    .,
    caption = "Student: Multilevel Core Variable Descriptives",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/studentVarDescr.tex")
```

```{r studentOutVarDescr, include=FALSE}
studentOutMlCor <-
  MlCorMat(
    data = dtStudentSupp$studentInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection = c("KeyNeedFullfillment", "Competence", "Autonomy", "Relatedness", "quality_overall", "AttitudesDutch"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Quality", "Attitudes NL")
  )

studentOutMlCor %>%
  kable(
    .,
    caption = "Student: Multilevel Core Variable Descriptives (Outgroup Contact Only)",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/studentOutVarDescr.tex")

# misty::multilevel.descript(dtStudentsSupp$studentWithinBetween$keyMotiveFulfilled, cluster = dtStudentsSupp$studentWithinBetween$PID)
```

\subsubsection{Participants} We recruited `r nrow(studentSampleInfo)` international students using a local participant pool. We specifically targeted non-Dutch students, who had recently arrived in the Netherlands. Participants reported on their interactions for at least 30 days with two daily measures (capturing the morning and afternoon). With this design, we again aimed at receiving 50-60 measurements per participant (\textit{M} = `r format(round(mean(studentSampleInfo$dailiesN),2), nsmall=2)`, \textit{SD} = `r format(round(sd(studentSampleInfo$dailiesN),2), nsmall=2)`, \textit{total N} = `r format(sum(studentSampleInfo$dailiesN), big.mark=",")`). As with the previous study this should offer sufficient power to model processes within participants and will lend stronger weight to between-participant results. Participants were compensated for their participation with partial course credits --- depending on their participation. The sample consisted of relatively young migrants, who were mostly from the global north ($M_{age}$ = `r format(round(mean(studentSampleInfo$age),2), nsmall=2)`, $SD_{age}$ = `r format(round(sd(studentSampleInfo$age),2), nsmall=2)`, `r nrow(studentSampleInfo %>% filter(gender == "women"))` women). The sample fairly accurately describes the local population of international students.

\subsubsection{Procedure} The study procedure mirrored the setup of Study 1 and consisted of pre-, experience sampling-, and post-measurements. The participants were invited for experience sampling measurements twice a day (at 12 pm and 7pm) for 30 days (\textit{median survey duration} = `r seconds_to_period(median(difftime(dtStudents$clean$ended.daily, dtStudents$clean$created.daily))) %>% as.character`, \textit{MAD duration} = `r seconds_to_period(round(mad(difftime(dtStudents$clean$ended.daily, dtStudents$clean$created.daily)))) %>% as.character`).  General compliance was high (`r format(round(sum(studentSampleInfo$dailiesN)/(nrow(studentSampleInfo)*62)*100,2), nsmall=2)`\% of all invited surveys were filled in). The response rates were approximately equal during mornings (\textit{n} = `r format(sum(studentSampleInfo$morningN), big.mark=",")`) and afternoons (\textit{n} = `r format(sum(studentSampleInfo$afternoonN), big.mark=",")`). All key variables for this study were part of the short experience sampling surveys. 

\subsubsection{Materials}

\paragraph{Intergroup Contact}To measure intergroup contacts, every experience sampling measurement started with the question “\textit{Did you meet a Dutch person this morning [/afternoon]? (in-person interaction for at least 10 minutes)}”. Participants were additionally offered a pop-up explanation: "With in-person interaction, we mean a continued interaction with another person (potentially in a group) that lasted at least 10 minutes. This interaction should be offline and face-to-face. It should include some form of verbal communication and should be uninterrupted to still count as the same interaction. Any individual interaction can last minutes or hours. If there were multiple interaction partners, we would like you to focus on the person that was most important to you during the interaction.". The participants recorded between `r dtStudentSupp$studentContactFreq$SumContactNL[dtStudentSupp$studentContactFreq$SumContactNL > 0] %>% min`--`r dtStudentSupp$studentContactFreq$SumContactNL %>% max`
interactions with Dutch majority people (`r dtStudentSupp$studentContactFreq$PercContactNL[dtStudentSupp$studentContactFreq$PercContactNL > 0] %>% min %>% round(2) %>% format(nsmall=2)`--`r dtStudentSupp$studentContactFreq$PercContactNL %>% max %>% round(2) %>% format(nsmall=2)`\% of individual experience sampling measurements; `r format(sum(dtStudentSupp$studentContactFreq$SumContactNL), big.mark=",")` of all `r format(nrow(dtStudentSupp$studentInteractionType), big.mark=",")` experience sampling responses). 

\paragraph{Psychological Needs}For the core situational need, we asked participants in an open ended text field: “\textit{What was your main goal [during the interaction with -X- / this morning / this afternoon]?}” (where \textit{-X-} was dynamically replaced with the name of the interaction partner). Participants could additionally click on a pop-up explanation: "Your main goal during an interaction can vary depending on the interaction. It could be to connect with friends, to find or provide help, to achieve academic ambitions, work on your fitness, work for a job, or simply to get a coffee, just as well as many other concrete or abstract goals that are import to you in the moment. It really depends on your subjective experience of the interaction.". Then, with reference to the text entry, we asked how much this core need was fulfilled during the interaction or the past daytime period: “\textit{During your interaction with -X- [this morning / this evening] your goal (-previous text entry-) was fulfilled.}” on a continuous slider scale ranging from strongly disagree (1) to strongly agree (100).

The measurement of the self-determination needs was identical to Study 1. 

\paragraph{Perceived Interaction Quality}The ratings of the perceived contact quality was identical to Study 1.

\paragraph{Outgroup Attitudes}As in Study 1, attitudes towards the Dutch majority outgroup were again measured using the feeling thermometer. All survey details are also available in our OSF repository \citep{KreienkampMasked2022a} and Online Supplemental Materials A. 

\subsection{Results}

```{r studentFreqAttCor, include=FALSE}

dtStudentSupp$studentContactFreq <-
  dtStudentSupp$studentContactFreq %>%
  mutate(
    SumContactNL_c = SumContactNL - mean(SumContactNL, na.rm = TRUE),
    SumContactNLAll_c = SumContactNLAll - mean(SumContactNLAll, na.rm = TRUE),
    AvAttitude_c = AvAttitude - mean(AvAttitude, na.rm = TRUE),
    AvQuality_c = AvQuality - mean(AvQuality, na.rm = TRUE)
  )

# correlation panel
pairs.panels.new(
  dtStudentSupp$studentContactFreq %>% select(SumContactNL, SumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)",
    "Sum:\nNumber of Outgroup Contacts (NL)",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)

# correlation panel with interaction sums winsorized
pairs.panels.new(
  dtStudentSupp$studentContactFreq %>% select(WinSumContactNL, WinSumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)\n[Winsorized]",
    "Sum:\nNumber of Outgroup Contacts (NL)\n[Winsorized]",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)
```

```{r studentModelOlsAttFreqQual, include=FALSE}
# create list to store Worker models
mdlStudent <- list()

# regression
mdlStudent$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtStudentSupp$studentContactFreq)

summ(
  mdlStudent$lmAttFreqQualX,
  confint = TRUE,
  digits = 3
)

mdlStudent$lmAttFreqQualXEta <-
  effectsize::eta_squared(mdlStudent$lmAttFreqQualX, partial = TRUE)

interactions::interact_plot(
  mdlStudent$lmAttFreqQualX,
  pred = SumContactNL_c,
  modx = AvQuality_c,
  interval = TRUE,
  partial.residuals = TRUE
)

interactions::johnson_neyman(mdlStudent$lmAttFreqQualX,
                             pred = SumContactNL_c,
                             modx = AvQuality_c,
                             alpha = .05)
```

```{r studentModelMLAttNull, include=FALSE}
# Create and save Model
mdlStudent$lmerAttNull <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
    data = dtStudents$full
  ) # use optim if it does not converge

mdlStudent$lmeAttNull <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtStudents$full,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(mdlStudent$lmerAttNull) #or with the lme function
summ(mdlStudent$lmerAttNull, digits = 3)

# Save variances
mdlStudent$varAttNull <- 
  VarCorr(mdlStudent$lmeAttNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlStudent$tauAttNull <- 
  as.numeric(mdlStudent$varAttNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlStudent$sigmaAttNull <- 
  as.numeric(mdlStudent$varAttNull[2])
# The ICC estimate (between/between+within) is:
mdlStudent$IccAttNull <-
  (as.numeric(mdlStudent$varAttNull[1]) / (as.numeric(mdlStudent$varAttNull[1]) + as.numeric(mdlStudent$varAttNull[2])))
mdlStudent$IccPercAttNull <-
  ((as.numeric(mdlStudent$varAttNull[1]) / (as.numeric(mdlStudent$varAttNull[1]) + as.numeric(mdlStudent$varAttNull[2])))) * 100
```
```{r studentModelInterceptAttType, include = FALSE}
# Create and save Model
mdlStudent$lmeInterceptAttType <-
  lme(
    AttitudesDutch ~ OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM,
    random =  ~ 1 | PID,
    data = dtStudentSupp$studentInteractionType
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudent$lmerInterceptAttType <- lmer(
    AttitudesDutch ~ OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM + (1 | PID),
    data = dtStudentSupp$studentInteractionType
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudent$lmerInterceptAttTypeCI <- 
  confint(method = "Wald", mdlStudent$lmerInterceptAttType)

# Compare new model to previous step
anova(mdlStudent$lmeAttNull, 
      mdlStudent$lmeInterceptAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudent$varInterceptAttType <- 
  lme4::VarCorr(mdlStudent$lmeInterceptAttType)
```
```{r studentModelSlopesInteractionType, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudent$lmeSlopesAttType <- lme(
  AttitudesDutch ~
    OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM,
  random = ~ 1 + OutgroupInteractionC + NonOutgroupInteractionC | PID,
  control = lmeControl(opt = "optim"),
  data = dtStudentSupp$studentInteractionType
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudent$lmerSlopesAttType <- lmer(
    AttitudesDutch ~
      OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM +
      (1 + OutgroupInteractionC + NonOutgroupInteractionC | PID),
    data = dtStudentSupp$studentInteractionType
  ), 
  confint = TRUE,
  digits = 3
)


# 95%CI
mdlStudent$lmerSlopesAttTypeCI <- 
  confint(method = "Wald", mdlStudent$lmerSlopesAttType)

# Compare new model to previous step
anova(mdlStudent$lmeAttNull,
      mdlStudent$lmeInterceptAttType, 
      mdlStudent$lmeSlopesAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudent$varSlopesAttType <- 
  lme4::VarCorr(mdlStudent$lmeSlopesAttType)

# Assumption Checks:
mdlStudent$diagSlopesAttType <-
  sjPlot::plot_model(mdlStudent$lmerSlopesAttType, type = "diag")
grid.arrange(
  mdlStudent$diagSlopesAttType[[1]],
  mdlStudent$diagSlopesAttType[[2]]$`PID`,
  mdlStudent$diagSlopesAttType[[3]],
  mdlStudent$diagSlopesAttType[[4]]
)

# Plot prediction model
mdlStudent$predSlopesAttType <- 
  dtStudentSupp$studentInteractionType %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudent$lmeSlopesAttType,
                           dtStudentSupp$studentInteractionType,
                           re.form = NA
                           )
         )

(
  mdlStudent$predPltSlopesAttType <-
    ggplot(data = mdlStudent$predSlopesAttType %>% filter(PID %in% dtStudentSupp$studentPltIDs), 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Student_PredictionPlot_SlopesAttType.png",
  mdlStudent$predPltSlopesAttType,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

\subsubsection{Contact Hypothesis}
<!-- We tested the most general contact hypothesis as in Study 1. We found a significant correlation with average outgroup attitudes for both the total number of outgroup interactions (\textit{r} = `r cor(dtStudentSupp$studentContactFreq$SumContactNLAll, dtStudentSupp$studentContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r cor.test(dtStudentSupp$studentContactFreq$SumContactNLAll, dtStudentSupp$studentContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`) and the number of measurement beeps with an interaction (\textit{r} = `r cor(dtStudentSupp$studentContactFreq$SumContactNL, dtStudentSupp$studentContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r cor.test(dtStudentSupp$studentContactFreq$SumContactNL, dtStudentSupp$studentContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`). However, we found no significant correlation between the participants' average interaction quality and their average outgroup attitudes (\textit{r} = `r cor(dtStudentSupp$studentContactFreq$AvQuality, dtStudentSupp$studentContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r cor.test(dtStudentSupp$studentContactFreq$AvQuality, dtStudentSupp$studentContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`). Thus, when considering the number of interactions and average interaction quality jointly in a linear regression, we find a main effect of intergroup contacts to predict outgroup attitudes (\textit{b} = `r coef(summary(mdlStudent$lmAttFreqQualX))["SumContactNL_c","Estimate"] %>% round(2) %>% format(nsmall=2)`, \textit{t}(`r mdlStudent$lmAttFreqQualX$df.residual`) = `r coef(summary(mdlStudent$lmAttFreqQualX))["SumContactNL_c","t value"] %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r coef(summary(mdlStudent$lmAttFreqQualX))["SumContactNL_c","Pr(>|t|)"] %>% round(3) %>% format(nsmall=3)`, $\eta_p^2$ = `r mdlStudent$lmAttFreqQualXEta %>% filter(Parameter == "SumContactNL_c") %>% select(Eta2_partial) %>% as.numeric %>% round(2) %>% format(nsmall=2)`) but no significant effect of average perceived contact quality and no significant interaction term (for full results see Table \ref{tab:intergroupGeneralTblLong} and Figure \ref{fig:ContactHypothesis}).  -->
We tested the most general contact hypothesis as we did for Study 1. We, again, used a multilevel regression analysis to check whether having an interaction with an outgroup member had a situational (i.e., contemporaneous) effect within the participants. We find that having an outgroup interaction is indeed associated with significantly more positive outgroup attitudes within the participants (random slopes model; `r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttType, lmerCI = mdlStudent$lmerSlopesAttTypeCI, varName = "OutgroupInteractionC")`), even after controlling for having an interaction with a non-Dutch person (which did not relate to outgroup attitudes independently). We again added the participant means back into the model. Because these are the means of the contact dummy variables they are the proportion of measurements that included a particular contact. This not only adjusts the model for unequal cell sizes but allows us to see whether between subject differences in the relative number of interactions had an effect on outgroup attitudes. We find that in this data set participant-level outgroup contact proportions were also a positive predictor of outgroup attitudes (`r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttType, lmerCI = mdlStudent$lmerSlopesAttTypeCI, varName = "OutgroupInteractionM")`). The relative number of non-outgroup interactions showed no such effect (for full results see Table \ref{tab:intergroupGeneralTblLong}, Figure \ref{fig:ContactHypothesis}, as well as Online Supplementary Material A). 
Thus, in our second data set we find that outgroup contacts show a positive effect on outgroup attitudes in the moment and on average between participants.

\subsubsection{Core Need}
```{r studentOutModelMLAttNull, include=FALSE}
# create empty list to organize models
mdlStudentOut <- 
  list(
    Att = list(),
    Qlt = list()
  )

# Create and save Model
mdlStudentOut$Att$lmerNull <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID), 
             data = dtStudentSupp$studentOutgroupInteraction) # use optim if it does not converge
mdlStudentOut$Att$lmeNull <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutgroupInteraction,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.ML.r) #or with the lme function
summ(mdlStudentOut$Att$lmerNull, digits = 3, center = TRUE)

# Save variances
mdlStudentOut$Att$varNull <- 
  VarCorr(mdlStudentOut$Att$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlStudentOut$Att$tauNull <- 
  as.numeric(mdlStudentOut$Att$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlStudentOut$Att$sigmaNull <- 
  as.numeric(mdlStudentOut$Att$varNull[2])
# The ICC estimate (between/between+within) is:
mdlStudentOut$Att$IccNull <-
  (as.numeric(mdlStudentOut$Att$varNull[1]) / (as.numeric(mdlStudentOut$Att$varNull[1]) + as.numeric(mdlStudentOut$Att$varNull[2])))
mdlStudentOut$Att$IccPercNull <-
  ((as.numeric(mdlStudentOut$Att$varNull[1]) / (as.numeric(mdlStudentOut$Att$varNull[1]) + as.numeric(mdlStudentOut$Att$varNull[2])))) * 100
```
```{r studentOutModelInterceptAttCore, include=FALSE}
# Create and save Model
mdlStudentOut$Att$lmeInterceptCore <-
  lme(
    AttitudesDutch ~ KeyNeedFullfillment_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudentOut$Att$lmerInterceptCore <-
    lmer(
      AttitudesDutch ~ KeyNeedFullfillment_cwc + (1 | PID),
      data = dtStudentSupp$studentOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# 95%CI
mdlStudentOut$Att$lmerInterceptCoreCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerInterceptCore)

# Compare new model to previous step
anova(mdlStudentOut$Att$lmeNull, 
      mdlStudentOut$Att$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Att$varInterceptCore <-
  lme4::VarCorr(mdlStudentOut$Att$lmeInterceptCore)
```
```{r studentOutModelSlopesAttCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Att$lmeSlopesCore <-
  lme(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc,
    random = ~ 1 + KeyNeedFullfillment_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Att$lmerSlopesCore <- lmer(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc +
      (1 + KeyNeedFullfillment_cwc | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# all variables standardized within PPT
summ(
  mdlStudentOut$Att$lmerSlopesCoreZ <- lmer(
    AttitudesDutch_zwc ~
      KeyNeedFullfillment_zwc +
      (1 + KeyNeedFullfillment_zwc | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# standardized coefficients
stdCoef.merMod(mdlStudentOut$Att$lmerSlopesCore)

# 95%CIs
mdlStudentOut$Att$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerSlopesCore)

# Attempts at R^2
r2mlm::r2mlm(mdlStudentOut$Att$lmerSlopesCore, bargraph = TRUE)
mitml::multilevelR2(mdlStudentOut$Att$lmerSlopesCore)
performance::r2(mdlStudentOut$Att$lmerSlopesCore)
performance::model_performance(mdlStudentOut$Att$lmerSlopesCore)
performance::compare_performance(mdlStudentOut$Att$lmerNull, 
                                 mdlStudentOut$Att$lmerInterceptCore, 
                                 mdlStudentOut$Att$lmerSlopesCore)

# Compare new model to previous step
anova(mdlStudentOut$Att$lmeNull, 
      mdlStudentOut$Att$lmeInterceptCore, 
      mdlStudentOut$Att$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Att$varSlopesCore <- 
  lme4::VarCorr(mdlStudentOut$Att$lmeSlopesCore)

# Assumption Checks:
mdlStudentOut$Att$diagSlopesCore <- 
  sjPlot::plot_model(mdlStudentOut$Att$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlStudentOut$Att$diagSlopesCore[[1]],
  mdlStudentOut$Att$diagSlopesCore[[2]]$`PID`,
  mdlStudentOut$Att$diagSlopesCore[[3]],
  mdlStudentOut$Att$diagSlopesCore[[4]]
)

# Plot prediction model
mdlStudentOut$Att$predSlopesCore <- 
  dtStudentSupp$studentOutWithinBetween %>% 
  filter(PID %in% dtStudentSupp$studentOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudentOut$Att$lmeSlopesCore,
                           dtStudentSupp$studentOutWithinBetween %>% filter(PID %in% dtStudentSupp$studentOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudentOut$Att$predPltSlopesCore <-
    ggplot(data = mdlStudentOut$Att$predSlopesCore, 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/StudentOut_PredictionPlot_SlopesAttCore.png",
  mdlStudentOut$Att$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

```{r studentOutModelMLQltNull, include=FALSE}
# Create and save Model
mdlStudentOut$Qlt$lmerNull <-
  lme4::lmer(quality_overall ~ 1 + (1 | PID), 
             data = dtStudentSupp$studentOutWithinBetween) # use optim if it does not converge
mdlStudentOut$Qlt$lmeNull <-
  mdlStudentOut$Qlt$lmeNull <-lme(
    quality_overall ~ 1,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.Qual.ML.r) #or with the lme function
summ(mdlStudentOut$Qlt$lmerNull, digits = 3)

# Save variances
mdlStudentOut$Qlt$varNull <- 
  VarCorr(mdlStudentOut$Qlt$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlStudentOut$Qlt$tauNull <- 
  as.numeric(mdlStudentOut$Qlt$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlStudentOut$Qlt$sigmaNull <- 
  as.numeric(mdlStudentOut$Qlt$varNull[2])
# The ICC estimate (between/between+within) is:
mdlStudentOut$Qlt$IccNull <-
  (as.numeric(mdlStudentOut$Qlt$varNull[1]) / (as.numeric(mdlStudentOut$Qlt$varNull[1]) + as.numeric(mdlStudentOut$Qlt$varNull[2])))
mdlStudentOut$Qlt$IccPercNull <-
  ((as.numeric(mdlStudentOut$Qlt$varNull[1]) / (as.numeric(mdlStudentOut$Qlt$varNull[1]) + as.numeric(mdlStudentOut$Qlt$varNull[2])))) * 100
```
```{r studentOutModelInterceptQltCore, include=FALSE}
# Create and save Model
mdlStudentOut$Qlt$lmeInterceptCore <-
  lme(
    quality_overall ~ KeyNeedFullfillment_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudentOut$Qlt$lmerInterceptCore <-
    lmer(
      quality_overall ~ KeyNeedFullfillment_cwc + (1 | PID),
      data = dtStudentSupp$studentOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# 95%CI
mdlStudentOut$Qlt$lmerInterceptCoreCI <- 
  confint(method = "Wald", mdlStudentOut$Qlt$lmerInterceptCore)

# Compare new model to previous step
anova(mdlStudentOut$Qlt$lmeNull, 
      mdlStudentOut$Qlt$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Qlt$varInterceptCore <-
  lme4::VarCorr(mdlStudentOut$Qlt$lmeInterceptCore)
```
```{r studentOutModelSlopesQltCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Qlt$lmeSlopesCore <-
  lme(
    quality_overall ~
      KeyNeedFullfillment_cwc,
    random = ~ 1 + KeyNeedFullfillment_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Qlt$lmerSlopesCore <-
    lmer(
      quality_overall ~
        KeyNeedFullfillment_cwc +
        (1 + KeyNeedFullfillment_cwc | PID),
      data = dtStudentSupp$studentOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# 95%CI
mdlStudentOut$Qlt$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlStudentOut$Qlt$lmerSlopesCore)

# Compare new model to previous step
anova(mdlStudentOut$Qlt$lmeNull, 
      mdlStudentOut$Qlt$lmeInterceptCore, 
      mdlStudentOut$Qlt$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Qlt$varSlopesCore <- 
  lme4::VarCorr(mdlStudentOut$Qlt$lmeSlopesCore)

# Assumption Checks:
mdlStudentOut$Qlt$diagSlopesCore <-
  sjPlot::plot_model(mdlStudentOut$Qlt$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlStudentOut$Qlt$diagSlopesCore[[1]],
  mdlStudentOut$Qlt$diagSlopesCore[[2]]$`PID`,
  mdlStudentOut$Qlt$diagSlopesCore[[3]],
  mdlStudentOut$Qlt$diagSlopesCore[[4]]
)

# Plot prediction model
mdlStudentOut$Qlt$predSlopesCore <- 
  dtStudentSupp$studentOutWithinBetween %>%
  filter(PID %in% dtStudentSupp$studentOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudentOut$Qlt$lmeSlopesCore,
                           dtStudentSupp$studentOutWithinBetween %>% filter(PID %in% dtStudentSupp$studentOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudentOut$Qlt$predPltSlopesCore <-
    ggplot(data = mdlStudentOut$Qlt$predSlopesCore %>% filter(PID %in% dtStudentSupp$studentOutPltIDs), 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/StudentOut_PredictionPlot_SlopesCore.png",
  mdlStudentOut$Qlt$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

```
```{r studentOutModelInterceptAttCoreQlt, include=FALSE}
# Create and save Model
mdlStudentOut$Att$lmeInterceptCoreQlt <-
  lme(
    AttitudesDutch ~ KeyNeedFullfillment_cwc + quality_overall_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudentOut$Att$lmerInterceptCoreQlt <-
    lmer(
      AttitudesDutch ~ KeyNeedFullfillment_cwc + quality_overall_cwc + (1 | PID),
      data = dtStudentSupp$studentOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudentOut$Att$lmerInterceptCoreQltCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerInterceptCoreQlt)

# Compare new model to previous step
anova(
  mdlStudentOut$Att$lmeNull, 
  mdlStudentOut$Att$lmeInterceptCoreQlt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Att$varInterceptCoreQlt <-
  lme4::VarCorr(mdlStudentOut$Att$lmeInterceptCoreQlt)
```
```{r studentOutModelSlopesAttCoreQlt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Att$lmeSlopesCoreQlt <-
  lme(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc + quality_overall_cwc,
    random = ~ 1 + KeyNeedFullfillment_cwc + quality_overall_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtStudentSupp$studentOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Att$lmerSlopesCoreQlt <- lmer(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc + quality_overall_cwc +
      (1 + KeyNeedFullfillment_cwc + quality_overall_cwc | PID),
    data = dtStudentSupp$studentOutWithinBetween,
    control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudentOut$Att$lmerSlopesCoreQltCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerSlopesCoreQlt)

# Compare new model to previous step
anova(
  mdlStudentOut$Att$lmeNull,
  mdlStudentOut$Att$lmeInterceptCoreQlt,
  mdlStudentOut$Att$lmeSlopesCoreQlt
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudentOut$Att$varSlopesCoreQlt <- 
  lme4::VarCorr(mdlStudentOut$Att$lmeSlopesCoreQlt)

# Assumption Checks:
mdlStudentOut$Att$diagSlopesCoreQlt <- 
  sjPlot::plot_model(mdlStudentOut$Att$lmerSlopesCoreQlt, type = "diag")
grid.arrange(
  mdlStudentOut$Att$diagSlopesCoreQlt[[1]],
  mdlStudentOut$Att$diagSlopesCoreQlt[[2]]$`PID`,
  mdlStudentOut$Att$diagSlopesCoreQlt[[3]],
  mdlStudentOut$Att$diagSlopesCoreQlt[[4]]
)

# Plot prediction model
mdlStudentOut$Att$predSlopesCoreQlt <- 
  dtStudentSupp$studentOutWithinBetween %>% 
  filter(PID %in% dtStudentSupp$studentOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudentOut$Att$lmeSlopesCoreQlt,
                           dtStudentSupp$studentOutWithinBetween %>% filter(PID %in% dtStudentSupp$studentOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudentOut$Att$predPltSlopesCoreQlt <-
    ggplot(data = mdlStudentOut$Att$predSlopesCoreQlt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/StudentOut_PredictionPlot_SlopesAttCoreQlt.png",
  mdlStudentOut$Att$predPltSlopesCoreQlt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We again sequentially tested whether the fulfillment of the core need during an interaction was (1) related to more positive outgroup attitudes, (2) higher perceived interaction quality, and (3) whether the variance explained by the core need is subsumed by the perceived interaction quality if considered jointly. We find that in the multilevel models, the fulfillment of core situational needs during outgroup contacts was associated with more positive outgroup attitudes (random slopes model; `r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCore, lmerCI = mdlStudentOut$Att$lmerSlopesCoreCI, varName = "KeyNeedFullfillment_cwc")`) and also predicted higher perceived interaction quality (random slopes model; `r MlCoeffLatex(lmeMdl = mdlStudentOut$Qlt$lmeSlopesCore, lmerCI = mdlStudentOut$Qlt$lmerSlopesCoreCI, varName = "KeyNeedFullfillment_cwc")`). Additionally, if we consider the influences of core need fulfillment and interaction quality on outgroup attitudes jointly, we find that virtually all variance is explained by perceived interaction quality (random slopes mode; `r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreQlt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreQltCI, varName = "quality_overall_cwc")`) and only little unique variance is still explained by core need fulfillment (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreQlt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreQltCI, varName = "KeyNeedFullfillment_cwc")`; also see Table \ref{tab:intergroupNeedsTblLong} and Figure \ref{fig:AllportNeedFulfillment} for full results). These results are consistent with the results in Study 1. We, thus, find support for our hypotheses that the fulfillment of core situational needs had a significant influence on outgroup attitudes and that this effect is likely explained by its effect through perceived interaction quality. 

<!-- \faQuestionCircle\ Are we sure that we don't want some sort of bootstrapped indirect effect?  -->

\subsubsection{Robustness}
```{r studentModelInterceptAttCoreInt, include=FALSE}
# Create and save Model
mdlStudent$lmeInterceptAttCoreInt <-
  lme(
    AttitudesDutch ~ KeyNeedFullfillment_cwc * OutgroupInteraction,
    random =  ~ 1 | PID,
    data = dtStudentSupp$studentWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudent$lmerInterceptAttCoreInt <- lmer(
    AttitudesDutch ~ KeyNeedFullfillment_cwc * OutgroupInteraction + (1 | PID),
    data = dtStudentSupp$studentWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudent$lmerInterceptAttCoreIntCI <- 
  confint(method = "Wald", mdlStudent$lmerInterceptAttCoreInt)

# Compare new model to previous step
anova(mdlStudent$lmeAttNull, 
      mdlStudent$lmeInterceptAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudent$varInterceptAttCoreInt <- 
  lme4::VarCorr(mdlStudent$lmeInterceptAttCoreInt)
```
```{r studentModelSlopesAttCoreIntX, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudent$lmeSlopesAttCoreInt <- lme(
  AttitudesDutch ~
    KeyNeedFullfillment_cwc * OutgroupInteraction,
  random = ~ 1 + KeyNeedFullfillment_cwc + OutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  data = dtStudentSupp$studentWithinBetween
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudent$lmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc * OutgroupInteraction +
      (1 + KeyNeedFullfillment_cwc + OutgroupInteraction | PID),
    data = dtStudentSupp$studentWithinBetween
  ), 
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudent$lmerSlopesAttCoreIntCI <- 
  confint(method = "Wald", mdlStudent$lmerSlopesAttCoreInt)

# Compare new model to previous step
anova(mdlStudent$lmeAttNull, 
      mdlStudent$lmeInterceptAttCoreInt,
      mdlStudent$lmeSlopesAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudent$varSlopesAttCoreInt <- 
  lme4::VarCorr(mdlStudent$lmeSlopesAttCoreInt)

# Assumption Checks:
mdlStudent$diagSlopesAttCoreInt <-
  sjPlot::plot_model(mdlStudent$lmerSlopesAttCoreInt, type = "diag")
grid.arrange(
  mdlStudent$diagSlopesAttCoreInt[[1]],
  mdlStudent$diagSlopesAttCoreInt[[2]]$`PID`,
  mdlStudent$diagSlopesAttCoreInt[[3]],
  mdlStudent$diagSlopesAttCoreInt[[4]]
)

# Plot prediction model
mdlStudent$predSlopesAttCoreInt <- 
  dtStudentSupp$studentWithinBetween %>%
  filter(PID %in% dtStudentSupp$studentPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudent$lmeSlopesAttCoreInt,
                           dtStudentSupp$studentWithinBetween %>% filter(PID %in% dtStudentSupp$studentPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudent$predPltSlopesAttCoreInt <-
    ggplot(data = mdlStudent$predSlopesAttCoreInt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Student_PredictionPlot_SlopesAttCoreInt.png",
  mdlStudent$predPltSlopesAttCoreInt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We again checked for alternative models. First, when considering generalized situational core need fulfillment together with whether an intergroup contact took place, we find that there is only a minuscule main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "KeyNeedFullfillment_cwc")`) but a stronger interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "KeyNeedFullfillment_cwc:OutgroupInteraction")`). Together with a significant main effect of having an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "OutgroupInteraction")`), this indicates that it is not key need fulfillment in general --- but key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. This finding is consistent with the results of the previous study, albeit with a slightly weaker effect (likely because of the large number of measurements that did not include an outgroup interaction; For full results see Table \ref{tab:intergroupNeedsTblLong} and for visual comparison see Figure \ref{fig:AllportNeedFulfillment}).

```{r studentOutModelInterceptAttCoreSdt, include=FALSE}
# Create and save Model
mdlStudentOut$Att$lmeInterceptCoreSdt <-
  lme(
    AttitudesDutch ~ KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudentOut$Att$lmerInterceptCoreSdt <- lmer(
    AttitudesDutch ~ KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudentOut$Att$lmerInterceptCoreSdtCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerInterceptCoreSdt)

# To be compared against a model with only the self-determination theory needs
mdlStudentOut$Att$lmeInterceptSdt <-
  lme(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

summ(
  mdlStudentOut$Att$lmerInterceptSdt <- lmer(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous steps
anova(
  mdlStudentOut$Att$lmeNull,
  mdlStudentOut$Att$lmeInterceptSdt,
  mdlStudentOut$Att$lmeInterceptCoreSdt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")
rm(lmeInterceptCoreRed)

# Save variances
mdlStudentOut$Att$varInterceptCoreSdt <-
  lme4::VarCorr(mdlStudentOut$Att$lmeInterceptCoreSdt)
```
```{r studentOutModelSlopesAttCoreSdt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Att$lmeSlopesCoreSdt <-
  lme(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + KeyNeedFullfillment_cwc + Competence_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim", maxIter = 100, msMaxIter = 100),
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Att$lmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudentOut$Att$lmerSlopesCoreSdtCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerSlopesCoreSdt)

# Compare new model to previous step
anova(mdlStudentOut$Att$lmeInterceptSdt,
      mdlStudentOut$Att$lmeInterceptCoreSdt, 
      mdlStudentOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# model with SDT only
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Att$lmeSlopesSdt <-
  lme(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Att$lmerSlopesSdt <- lmer(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous step
anova(mdlStudentOut$Att$lmeInterceptSdt,
      mdlStudentOut$Att$lmeSlopesSdt, 
      mdlStudentOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")


# Save variances
mdlStudentOut$Att$varSlopesCoreSdt <- 
  lme4::VarCorr(mdlStudentOut$Att$lmeSlopesCoreSdt)

# Assumption Checks:
mdlStudentOut$Att$diagSlopesCoreSdt <- 
  sjPlot::plot_model(mdlStudentOut$Att$lmerSlopesCoreSdt, type = "diag")
grid.arrange(
  mdlStudentOut$Att$diagSlopesCoreSdt[[1]],
  mdlStudentOut$Att$diagSlopesCoreSdt[[2]]$`PID`,
  mdlStudentOut$Att$diagSlopesCoreSdt[[3]],
  mdlStudentOut$Att$diagSlopesCoreSdt[[4]]
)

# Plot prediction model
mdlStudentOut$Att$predSlopesCoreSdt <- 
  dtStudentSupp$studentOutWithinBetween %>%
  filter(PID %in% dtStudentSupp$studentOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID, Autonomy) %>% 
  mutate(measure = predict(mdlStudentOut$Att$lmeSlopesCoreSdt,
                           dtStudentSupp$studentOutWithinBetween %>% filter(PID %in% dtStudentSupp$studentOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudentOut$Att$predPltSlopesCoreSdt <-
    ggplot(data = mdlStudentOut$Att$predSlopesCoreSdt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/StudentOut_PredictionPlot_SlopesAttCoreStd.png",
  mdlStudentOut$Att$predPltSlopesCoreSdt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

# Model comparison
studentSdtComp <-
  anova(
    mdlStudentOut$Att$lmerSlopesSdt, 
    mdlStudentOut$Att$lmerSlopesCoreSdt
  ) %>%
  as.data.frame()
studentSdtCompDf <- studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Df"]
studentSdtCompN <- sapply(ranef(mdlStudentOut$Att$lmerSlopesCoreSdt), nrow)
studentSdtCompChi <- studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2)
studentSdtCompP <-
  ifelse(studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001,
         "< .001",
         paste0("= ", studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3)))

studentSdtCompChiSq <- paste0("$\\chi^2$(", studentSdtCompDf, ", \\textit{N} = ", studentSdtCompN, ") = ", studentSdtCompChi, ", \\textit{p} ", studentSdtCompP)
```

In a final step, we again checked whether during the interaction the core situational need remains a meaningful predictor even when taking other fundamental psychological needs into account. We find that the core need fulfillment adds significantly above a model with only the self-determination theory needs (random slopes models; `r studentSdtCompChiSq`). We find that the core need fulfillment explained the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "KeyNeedFullfillment_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all of the three fundamental needs. However, different from the first study, relatedness (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "Relatedness_cwc")`) and autonomy (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "Autonomy_cwc")`) also predicted positive outgroup attitudes in this larger sample. For full results see Table \ref{tab:intergroupNeedsTblLong}, Figure \ref{fig:Robustness}, and Online Supplementary Material A. This means that also within this second sample, the fulfillment of psychological needs during intergroup contact remained a key predictor of positive outgroup attitudes, even when taking into account several alternative models.

\section{Study 3}

The aim of this final study is to extend the previous studies by additionally testing Allport's conditions in an extensive longitudinal design and to compare the predictive powers of Allport's conditions and the core situational need fulfillment. We will, thus, again test the general contact hypothesis, the influence of core need fulfillment, and perceived interaction quality during intergroup contacts. However, we additionally have the opportunity to also assess the role of Allport's conditions in this and to compare the two approaches (Allport's conditions and core need fulfillment) directly. 

For this study, we specifically recruited international medical students, because they represent a particular group of migrants who face structural requirements to integrate and interact with Dutch majority outgroup members on a daily basis. As part of their educational program, the migrants are required to take language courses and interact with patients as part of their medical internships and medical residency. The extensive longitudinal survey method again offers a large body of ecologically valid data on need satisfaction in real-life intergroup contact situations. Data were collected from November 8\textsuperscript{th}, 2019 to January 10\textsuperscript{th}, 2020.

The full surveys are available in our OSF repository \citep{KreienkampMasked2022a} and the full data description is available in Online Supplementary Material A. Correlations and descriptive statistics of the included variables are available in Tables \ref{tab:descrFullWide} and \ref{tab:descrOutWide}.

\subsection{Methods}

```{r medicalSampleInfo, include=FALSE}
# extract demographic information from eligibility questionnaire
medicalDemographicSupp <- 
  dtMedical$raw.eligibility %>%
  filter(session %in% dtMedical$full$session) %>%
  select(session, nationality, studentBachMa)
# summarize participant characteristics

medicalSampleInfo <-
  merge(dtMedical$full, medicalDemographicSupp, by = "session") %>%
  mutate(gender = as.factor(ifelse(.$Gender == 1, "women", ifelse(.$Gender == 2, "man", ifelse(.$Gender == 3, "other", NA))))) %>%
  group_by(PID) %>%
  summarise(
    dailiesN = n(), 
    morningN = sum(periodMA=="morning"),
    afternoonN = sum(periodMA=="afternoon"),
    age = age,
    gender = gender,
    nationality = nationality
  ) %>%
  distinct

# look at frequencies of characteristics 
table(medicalSampleInfo$age)
table(medicalSampleInfo$gender)
table(as.character(medicalSampleInfo$nationality))

# divide into trait and state
dtMedicalSupp$medicalWithinBetween <- 
  MlTraitState(
    data = dtMedical$full,
    id = "PID",
    selection =
      c(
        "OutgroupInteraction",
        "NonOutgroupInteraction",
        "OutgroupInteractionM",
        "NonOutgroupInteractionM"
      )
  )

```

```{r medicalVarDescr, include=FALSE}
medicalMlCor <-
  MlCorMat(
    data = dtMedical$full,
    id = "PID",
    selection = c("KeyNeedFulfillment", "Competence", "Autonomy", "Relatedness", "AllportsCondition", "qualityOverall", "AttitudesDutch"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Allport", "Quality", "Attitudes NL")
  ) 

medicalMlCor %>%
  kable(
    .,
    caption = "Medical: Multilevel Core Variable Descriptives",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/medicalVarDescr.tex")
```

```{r medicalOutVarDescr, include=FALSE}
medicalOutMlCor <-
  MlCorMat(
    data = dtMedical$full %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection = c("KeyNeedFulfillment", "Competence", "Autonomy", "Relatedness", "AllportsCondition", "qualityOverall", "AttitudesDutch"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Allport", "Quality", "Attitudes NL")
  )

medicalOutMlCor %>%
  kable(
    .,
    caption = "Medical: Multilevel Core Variable Descriptives (Outgroup Contact Only)",
    format = "latex",
    booktabs = TRUE,
    linesep = linesep(c(ncol(.))),
    align = c("l", rep("c", ncol(.) - 1))
  ) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/medicalOutVarDescr.tex")

# misty::multilevel.descript(dtStudentsSupp$studentWithinBetween$keyMotiveFulfilled, cluster = dtStudentsSupp$studentWithinBetween$PID)
```

\subsubsection{Participants} We recruited `r nrow(medicalSampleInfo)` international medical students using contacts within the University Medical School. We specifically targeted non-Dutch students, who had recently arrived in the Netherlands. Participants reported on their interactions for at least 30 days with two daily measures (capturing the morning and afternoon). With this design, we aimed at getting 50-60 measurements per participant (\textit{M} = `r format(round(mean(medicalSampleInfo$dailiesN),2), nsmall=2)`, \textit{SD} = `r format(round(sd(medicalSampleInfo$dailiesN),2), nsmall=2)`, \textit{total N} = `r format(sum(medicalSampleInfo$dailiesN), big.mark=",")`). As with the previous studies, this should offer sufficient power to model processes within participants and will lend stronger weight to between-participant results. Participants were compensated for their participation in the same manner as during Study 1. The sample consisted of relatively young migrants, who were mostly from the global north ($M_{age}$ = `r format(round(mean(medicalSampleInfo$age),2), nsmall=2)`, $SD_{age}$ = `r format(round(sd(medicalSampleInfo$age),2), nsmall=2)`, `r nrow(medicalSampleInfo %>% filter(gender == "women"))` women). The sample fairly accurately describes the local population of young international medical professionals.

\subsubsection{Procedure} The study procedure mirrored the setup of studies one and two, in that it consisted of pre-, experience sampling-, and post-measurement. The participants were invited for experience sampling measurements twice a day (at 12 pm and 7pm) for 30 days (\textit{median survey duration} = `r seconds_to_period(median(difftime(dtMedical$clean$ended.daily, dtMedical$clean$created.daily, units = "secs"), na.rm=TRUE)) %>% as.character`, \textit{MAD duration} = `r seconds_to_period(round(mad(difftime(dtMedical$clean$ended.daily, dtMedical$clean$created.daily, units = "secs"), na.rm=TRUE))) %>% as.character`).  General compliance was high (`r format(round(table(medicalSampleInfo$dailiesN>30)["TRUE"]/nrow(medicalSampleInfo)*100,2), nsmall=2)`\% filled in at least 31 experience sampling surveys or more). The response rates were approximately equal during mornings (\textit{n} = `r format(sum(medicalSampleInfo$morningN), big.mark=",")`) and afternoons (\textit{n} = `r format(sum(medicalSampleInfo$afternoonN), big.mark=",")`). All key variables for this study were part of the short experience sampling surveys. 

\subsubsection{Materials}

\paragraph{Intergroup Contact}The measurement of intergroup contacts was identical to Study 2. The participants recorded between `r dtMedicalSupp$medicalContactFreq$SumContactNL[dtMedicalSupp$medicalContactFreq$SumContactNL > 0] %>% min`--`r dtMedicalSupp$medicalContactFreq$SumContactNL %>% max` interactions with Dutch outgroup members
(`r dtMedicalSupp$medicalContactFreq$PercContactNL[dtMedicalSupp$medicalContactFreq$PercContactNL > 0] %>% min %>% round(2) %>% format(nsmall=2)`--`r dtMedicalSupp$medicalContactFreq$PercContactNL %>% max %>% round(2) %>% format(nsmall=2)`\% of individual experience sampling measurements; `r format(sum(dtMedicalSupp$medicalContactFreq$SumContactNL), big.mark=",")` of all `r format(nrow(dtMedical$full), big.mark=",")` experience sampling responses). 

\paragraph{Psychological Needs}The measurement of the core situational need and its fulfillment was identical to Study 2. Similarly, the measurement of the self-determination needs was identical to Studies 1 and 2 

\paragraph{Allport's Conditions}We measured how much each of the interactions fulfilled Allport's conditions of optimal contact using a common short scale comprised of four attributes \citep{Islam1993, Voci2003, AlRamiah2012a, Dixon2005}. In particular, we asked participants to rate how much the interaction had equal status ("\textit{The interaction with [name interaction partner] was on equal footing (same status)}"), a common goal ("\textit{[name interaction partner] shared your goal ([free-text entry interaction key need])}"), support of authorities ("\textit{The interaction with [name interaction partner] was voluntary}"), and intergroup cooperation ("\textit{The interaction with [name interaction partner] was cooperative}"). We create a mean-averaged index of Allport's conditions in response to past findings indicating that the conditions are best conceptualized jointly and as functioning together rather than as fully independent factors \citep[][, p. 766]{Pettigrew2006}. For full psychometric information see Online Supplementary Material A.

\paragraph{Perceived Interaction Quality}The ratings of the perceived interaction quality was identical to Study 1.

\paragraph{Outgroup Attitudes}Attitudes towards the Dutch majority outgroup was again measured using the feeling thermometer, as in studies one and two. All survey details are also available in our OSF repository \citep{KreienkampMasked2022a} and Online Supplemental Materials A. 

\subsection{Results}

```{r medicalFreqAttCor, include=FALSE}
dtMedicalSupp$medicalContactFreq <-
  dtMedicalSupp$medicalContactFreq %>%
  mutate(
    SumContactNL_c = SumContactNL - mean(SumContactNL, na.rm = TRUE),
    SumContactNLAll_c = SumContactNLAll - mean(SumContactNLAll, na.rm = TRUE),
    AvAttitude_c = AvAttitude - mean(AvAttitude, na.rm = TRUE),
    AvQuality_c = AvQuality - mean(AvQuality, na.rm = TRUE)
  )

# correlation panel
pairs.panels.new(
  dtMedicalSupp$medicalContactFreq %>% select(SumContactNL, SumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)",
    "Sum:\nNumber of Outgroup Contacts (NL)",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)

# correlation panel with interaction sums winsorized
pairs.panels.new(
  dtMedicalSupp$medicalContactFreq %>% select(WinSumContactNL, WinSumContactNLAll, AvQuality, AvAttitude),
  labels = c(
    "Sum:\nNumer of beeps with Outgroup Contact (NL)\n[Winsorized]",
    "Sum:\nNumber of Outgroup Contacts (NL)\n[Winsorized]",
    "Mean:\nInteraction Quality",
    "Mean:\nOutgroup Attitudes (NL)"
  )
)
```

```{r medicalModelOlsAttFreqQual, include=FALSE}
# create list to store Worker models
mdlMedical <- list()

# regression
mdlMedical$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtMedicalSupp$medicalContactFreq)

summ(
  mdlMedical$lmAttFreqQualX,
  confint = TRUE,
  digits = 3
)

mdlMedical$lmAttFreqQualXEta <-
  effectsize::eta_squared(mdlMedical$lmAttFreqQualX, partial = TRUE)

interactions::interact_plot(
  mdlMedical$lmAttFreqQualX,
  pred = SumContactNL_c,
  modx = AvQuality_c,
  interval = TRUE,
  partial.residuals = TRUE
)

interactions::johnson_neyman(mdlMedical$lmAttFreqQualX,
                             pred = SumContactNL_c,
                             modx = AvQuality_c,
                             alpha = .05)
```

```{r medicalModelMLAttNull, include=FALSE}
# Create and save Model
mdlMedical$lmerAttNullType <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
             data = dtMedical$full %>%
               filter(complete.cases(
                 OutgroupInteraction, NonOutgroupInteraction
               ))) # use optim if it does not converge

mdlMedical$lmeAttNullType <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtMedical$full %>%
      filter(complete.cases(
        OutgroupInteraction, NonOutgroupInteraction
      )),
    na.action = na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(mdlMedical$lmerAttNull) #or with the lme function
summ(mdlMedical$lmerAttNullType, digits = 3)

# Save variances
mdlMedical$varAttNullType <- 
  VarCorr(mdlMedical$lmeAttNullType) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlMedical$tauAttNullType <- 
  as.numeric(mdlMedical$varAttNullType[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlMedical$sigmaAttNullType <- 
  as.numeric(mdlMedical$varAttNullType[2])
# The ICC estimate (between/between+within) is:
mdlMedical$IccAttNullType <-
  (as.numeric(mdlMedical$varAttNullType[1]) / (as.numeric(mdlMedical$varAttNullType[1]) + as.numeric(mdlMedical$varAttNullType[2])))
mdlMedical$IccPercAttNull <-
  ((as.numeric(mdlMedical$varAttNullType[1]) / (as.numeric(mdlMedical$varAttNullType[1]) + as.numeric(mdlMedical$varAttNullType[2])))) * 100
```

```{r medicalModelInterceptAttType, include = FALSE}
# Create and save Model
mdlMedical$lmeInterceptAttType <-
  lme(
    AttitudesDutch ~ OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM,
    random =  ~ 1 | PID,
    na.action=na.omit,
    data = dtMedical$full
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedical$lmerInterceptAttType <- lmer(
    AttitudesDutch ~ OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM + (1 | PID),
    data = dtMedical$full
  ),
  confint = TRUE,
  digits = 3
)

mdlMedical$lmerInterceptAttTypeCI <- 
  confint(method = "Wald", mdlMedical$lmerInterceptAttType)

# Compare new model to previous step
anova(mdlMedical$lmeAttNullType, 
      mdlMedical$lmeInterceptAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedical$varInterceptAttType <- 
  lme4::VarCorr(mdlMedical$lmeInterceptAttType)
```

```{r medicalModelSlopesInteractionType, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedical$lmeSlopesAttType <- lme(
  AttitudesDutch ~
    OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM,
  random = ~ 1 + OutgroupInteractionC + NonOutgroupInteractionC | PID,
  control = lmeControl(opt = "optim"),
  na.action = na.omit,
  data = dtMedical$full
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedical$lmerSlopesAttType <- lmer(
    AttitudesDutch ~
      OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM +
      (1 + OutgroupInteractionC + NonOutgroupInteractionC | PID),
    data = dtMedical$full
  ), 
  confint = TRUE,
  digits = 3
)

mdlMedical$lmerSlopesAttTypeCI <- 
  confint(method = "Wald", mdlMedical$lmerSlopesAttType)

# Compare new model to previous step
anova(mdlMedical$lmeAttNullType,
      mdlMedical$lmeInterceptAttType, 
      mdlMedical$lmeSlopesAttType) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedical$varSlopesAttType <- 
  lme4::VarCorr(mdlMedical$lmeSlopesAttType)

# Assumption Checks:
mdlMedical$diagSlopesAttType <-
  sjPlot::plot_model(mdlMedical$lmerSlopesAttType, type = "diag")
grid.arrange(
  mdlMedical$diagSlopesAttType[[1]],
  mdlMedical$diagSlopesAttType[[2]]$`PID`,
  mdlMedical$diagSlopesAttType[[3]],
  mdlMedical$diagSlopesAttType[[4]]
)

# Plot prediction model
mdlMedical$predSlopesAttType <-
  dtMedical$full %>%
  filter(complete.cases(OutgroupInteraction, NonOutgroupInteraction)) %>%
  select(AttitudesDutch, TIDnum, PID) %>%
  mutate(measure = predict(
    mdlMedical$lmeSlopesAttType,
    dtMedical$full %>%
      filter(complete.cases(
        OutgroupInteraction, NonOutgroupInteraction
      )),
    re.form = NA
  ))

(
  mdlMedical$predPltSlopesAttType <-
    ggplot(data = mdlMedical$predSlopesAttType %>% filter(PID %in% dtMedicalSupp$medicalPltIDs), 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Medical_PredictionPlot_SlopesAttType.png",
  mdlMedical$predPltSlopesAttType,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

\subsubsection{Contact Hypothesis}
<!-- As in Studies 1 and 2, we first conducted a general contact hypothesis test. We found no correlation between the overall number of intergroup contacts and average outgroup attitudes --- for neither the total number of outgroup interactions nor the number of measurement beeps with an interaction (|\textit{r}| < `r cor(dtMedicalSupp$medicalContactFreq$SumContactNL, dtMedicalSupp$medicalContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} > `r cor.test(dtMedicalSupp$medicalContactFreq$SumContactNL, dtMedicalSupp$medicalContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`). However, we did find a significant correlation between the participants' average interaction quality and their average outgroup attitudes (\textit{r} = `r cor(dtMedicalSupp$medicalContactFreq$AvQuality, dtMedicalSupp$medicalContactFreq$AvAttitude) %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r cor.test(dtMedicalSupp$medicalContactFreq$AvQuality, dtMedicalSupp$medicalContactFreq$AvAttitude)$p.value %>% round(3) %>% format(nsmall=3)`). When considering the number of interactions and average interaction quality jointly in a linear regression, we only found a main effect of average perceived interaction quality on outgroup attitudes (\textit{b} = `r coef(summary(mdlMedical$lmAttFreqQualX))["AvQuality_c","Estimate"] %>% round(2) %>% format(nsmall=2)`, \textit{t}(`r mdlMedical$lmAttFreqQualX$df.residual`) = `r coef(summary(mdlMedical$lmAttFreqQualX))["AvQuality_c","t value"] %>% round(2) %>% format(nsmall=2)`, \textit{p} = `r coef(summary(mdlMedical$lmAttFreqQualX))["AvQuality_c","Pr(>|t|)"] %>% round(3) %>% format(nsmall=3)`, $\eta_p^2$ = `r mdlMedical$lmAttFreqQualXEta %>% filter(Parameter == "AvQuality_c") %>% select(Eta2_partial) %>% as.numeric %>% round(2) %>% format(nsmall=2)`) but no significant effect of the number of contacts nor an interaction effect. This result mirrors that of Study 1 but is inconsistent with the second study.  -->
Additionally, in a multilevel regression to check for contemporaneous within person effects, we found that having an outgroup interaction was indeed associated with significantly more positive outgroup attitudes within the participants (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttType, lmerCI = mdlMedical$lmerSlopesAttTypeCI, varName = "OutgroupInteractionC")`), even after controlling for having an interaction with a non-Dutch (which did not relate to outgroup attitudes independently; for full results see Table \ref{tab:intergroupGeneralTblLong}, Figure \ref{fig:ContactHypothesis}, and Online Supplementary Material A). Thus, in our third data set we found within person contemporaneous effect of intergroup contact was consistent across all three studies.  

\subsubsection{Core Need}

```{r medicalOutModelMLAttNull, include=FALSE}
# create empty list to organize models
mdlMedicalOut <- 
  list(
    Att = list(),
    Qlt = list()
  )

# Create and save Model
mdlMedicalOut$Att$lmerNull <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
             data = dtMedicalSupp$medicalOutWithinBetween) # use optim if it does not converge
mdlMedicalOut$Att$lmeNull <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.ML.r) #or with the lme function
summ(mdlMedicalOut$Att$lmerNull, digits = 3, center = TRUE)

# Save variances
mdlMedicalOut$Att$varNull <- 
  VarCorr(mdlMedicalOut$Att$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlMedicalOut$Att$tauNull <- 
  as.numeric(mdlMedicalOut$Att$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlMedicalOut$Att$sigmaNull <- 
  as.numeric(mdlMedicalOut$Att$varNull[2])
# The ICC estimate (between/between+within) is:
mdlMedicalOut$Att$IccNull <-
  (as.numeric(mdlMedicalOut$Att$varNull[1]) / (as.numeric(mdlMedicalOut$Att$varNull[1]) + as.numeric(mdlMedicalOut$Att$varNull[2])))
mdlMedicalOut$Att$IccPercNull <-
  ((as.numeric(mdlMedicalOut$Att$varNull[1]) / (as.numeric(mdlMedicalOut$Att$varNull[1]) + as.numeric(mdlMedicalOut$Att$varNull[2])))) * 100
```

```{r medicalOutModelMLQltNull, include=FALSE}
# Create and save Model
mdlMedicalOut$Qlt$lmerNull <-
  lme4::lmer(qualityOverall ~ 1 + (1 | PID), 
             data = dtMedicalSupp$medicalOutWithinBetween) # use optim if it does not converge
mdlMedicalOut$Qlt$lmeNull <-
  mdlMedicalOut$Qlt$lmeNull <-lme(
    qualityOverall ~ 1,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.Qual.ML.r) #or with the lme function
summ(mdlMedicalOut$Qlt$lmerNull, digits = 3)

# Save variances
mdlMedicalOut$Qlt$varNull <- 
  VarCorr(mdlMedicalOut$Qlt$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlMedicalOut$Qlt$tauNull <- 
  as.numeric(mdlMedicalOut$Qlt$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlMedicalOut$Qlt$sigmaNull <- 
  as.numeric(mdlMedicalOut$Qlt$varNull[2])
# The ICC estimate (between/between+within) is:
mdlMedicalOut$Qlt$IccNull <-
  (as.numeric(mdlMedicalOut$Qlt$varNull[1]) / (as.numeric(mdlMedicalOut$Qlt$varNull[1]) + as.numeric(mdlMedicalOut$Qlt$varNull[2])))
mdlMedicalOut$Qlt$IccPercNull <-
  ((as.numeric(mdlMedicalOut$Qlt$varNull[1]) / (as.numeric(mdlMedicalOut$Qlt$varNull[1]) + as.numeric(mdlMedicalOut$Qlt$varNull[2])))) * 100
```

```{r medicalOutModelInterceptAttCore, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptCore <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptCore <-
    lmer(
      AttitudesDutch ~ KeyNeedFulfillment_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Att$lmerInterceptCoreCI <-
  confint(method = "Wald", mdlMedicalOut$Att$lmerInterceptCore)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeNull,
      mdlMedicalOut$Att$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptCore <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptCore)
```

```{r medicalOutModelSlopesAttCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesCore <-
  lme(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesCore <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc +
      (1 + KeyNeedFulfillment_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# all variables standardized within PPT
summ(
  mdlMedicalOut$Att$lmerSlopesCoreZ <- lmer(
    AttitudesDutch_zwc ~
      KeyNeedFulfillment_zwc +
      (1 + KeyNeedFulfillment_zwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# standardized coefficients
stdCoef.merMod(mdlMedicalOut$Att$lmerSlopesCore)

# 95%CIs
mdlMedicalOut$Att$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesCore)

# Attempts at R^2
r2mlm::r2mlm(mdlMedicalOut$Att$lmerSlopesCore, bargraph = TRUE)
mitml::multilevelR2(mdlMedicalOut$Att$lmerSlopesCore)
performance::r2(mdlMedicalOut$Att$lmerSlopesCore)
performance::model_performance(mdlMedicalOut$Att$lmerSlopesCore)
performance::compare_performance(mdlMedicalOut$Att$lmerNull, 
                                 mdlMedicalOut$Att$lmerInterceptCore, 
                                 mdlMedicalOut$Att$lmerSlopesCore)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeNull, 
      mdlMedicalOut$Att$lmeInterceptCore, 
      mdlMedicalOut$Att$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varSlopesCore <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesCore)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesCore <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesCore[[1]],
  mdlMedicalOut$Att$diagSlopesCore[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesCore[[3]],
  mdlMedicalOut$Att$diagSlopesCore[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesCore <- 
  dtMedicalSupp$medicalOutWithinBetween %>% 
  filter(complete.cases(KeyNeedFulfillment)) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesCore,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(KeyNeedFulfillment)) %>% 
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesCore <-
    ggplot(data = mdlMedicalOut$Att$predSlopesCore, 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttCore.png",
  mdlMedicalOut$Att$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

```{r medicalOutModelInterceptQltCore, include=FALSE}
# Create and save Model
mdlMedicalOut$Qlt$lmeInterceptCore <-
  lme(
    qualityOverall ~ KeyNeedFulfillment_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Qlt$lmerInterceptCore <-
    lmer(
      qualityOverall ~ KeyNeedFulfillment_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Qlt$lmerInterceptCoreCI <- 
  confint(method = "Wald", mdlMedicalOut$Qlt$lmerInterceptCore)

# Compare new model to previous step
anova(mdlMedicalOut$Qlt$lmeNull, 
      mdlMedicalOut$Qlt$lmeInterceptCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Qlt$varInterceptCore <-
  lme4::VarCorr(mdlMedicalOut$Qlt$lmeInterceptCore)
```

```{r medicalOutModelSlopesQltCore, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Qlt$lmeSlopesCore <-
  lme(
    qualityOverall ~
      KeyNeedFulfillment_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Qlt$lmerSlopesCore <-
    lmer(
      qualityOverall ~
        KeyNeedFulfillment_cwc +
        (1 + KeyNeedFulfillment_cwc | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Qlt$lmerSlopesCoreCI <- 
  confint(method = "Wald", mdlMedicalOut$Qlt$lmerSlopesCore)

# Compare new model to previous step
anova(mdlMedicalOut$Qlt$lmeNull, 
      mdlMedicalOut$Qlt$lmeInterceptCore, 
      mdlMedicalOut$Qlt$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Qlt$varSlopesCore <- 
  lme4::VarCorr(mdlMedicalOut$Qlt$lmeSlopesCore)

# Assumption Checks:
mdlMedicalOut$Qlt$diagSlopesCore <-
  sjPlot::plot_model(mdlMedicalOut$Qlt$lmerSlopesCore, type = "diag")
grid.arrange(
  mdlMedicalOut$Qlt$diagSlopesCore[[1]],
  mdlMedicalOut$Qlt$diagSlopesCore[[2]]$`PID`,
  mdlMedicalOut$Qlt$diagSlopesCore[[3]],
  mdlMedicalOut$Qlt$diagSlopesCore[[4]]
)

# Plot prediction model
mdlMedicalOut$Qlt$predSlopesCore <- 
  dtMedicalSupp$medicalOutWithinBetween %>%
  filter(complete.cases(KeyNeedFulfillment)) %>% 
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Qlt$lmeSlopesCore,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(KeyNeedFulfillment)) %>% 
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Qlt$predPltSlopesCore <-
    ggplot(data = mdlMedicalOut$Qlt$predSlopesCore %>% filter(PID %in% dtMedicalSupp$medicalOutPltIDs), 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesCore.png",
  mdlMedicalOut$Qlt$predPltSlopesCore,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

```

```{r medicalOutModelInterceptAttCoreQlt, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptCoreQlt <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc + qualityOverall_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptCoreQlt <-
    lmer(
      AttitudesDutch ~ KeyNeedFulfillment_cwc + qualityOverall_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerInterceptCoreQltCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerInterceptCoreQlt)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull, 
  mdlMedicalOut$Att$lmeInterceptCoreQlt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptCoreQlt <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptCoreQlt)
```

```{r medicalOutModelSlopesAttCoreQlt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesCoreQlt <-
  lme(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + qualityOverall_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc + qualityOverall_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesCoreQlt <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + qualityOverall_cwc +
      (1 + KeyNeedFulfillment_cwc + qualityOverall_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween,
    control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
  ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerSlopesCoreQltCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesCoreQlt)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull,
  mdlMedicalOut$Att$lmeInterceptCoreQlt,
  mdlMedicalOut$Att$lmeSlopesCoreQlt
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varSlopesCoreQlt <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesCoreQlt)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesCoreQlt <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesCoreQlt, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesCoreQlt[[1]],
  mdlMedicalOut$Att$diagSlopesCoreQlt[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesCoreQlt[[3]],
  mdlMedicalOut$Att$diagSlopesCoreQlt[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesCoreQlt <- 
  dtMedicalSupp$medicalOutWithinBetween %>% 
  filter(complete.cases(KeyNeedFulfillment, qualityOverall)) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesCoreQlt,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(KeyNeedFulfillment, qualityOverall)) %>%
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesCoreQlt <-
    ggplot(data = mdlMedicalOut$Att$predSlopesCoreQlt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttCoreQlt.png",
  mdlMedicalOut$Att$predPltSlopesCoreQlt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

Similarly to the previous studies, we again sequentially tested whether the fulfillment of the core need during an interaction was (1) related to more positive outgroup attitudes, (2) higher perceived interaction quality, and (3) whether the variance explained by the core need is assumed by the perceived interaction quality if considered jointly. We find that the fulfillment of the core need during outgroup contacts was associated with more positive outgroup attitudes (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCore, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreCI, varName = "KeyNeedFulfillment_cwc")`) and also predicted higher perceived interaction quality (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Qlt$lmeSlopesCore, lmerCI = mdlMedicalOut$Qlt$lmerSlopesCoreCI, varName = "KeyNeedFulfillment_cwc")`). Additionally, once we consider the influences of core need fulfillment and interaction quality on outgroup attitudes jointly, we find that perceived interaction quality is a substantially stronger predictor (random slopes mode; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreQlt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreQltCI, varName = "qualityOverall_cwc")`) and the unique variance explained by core need fulfillment was roughly half of its original effect size (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreQlt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreQltCI, varName = "KeyNeedFulfillment_cwc")`; for full results see Table \ref{tab:intergroupNeedsTblLong} and Figure \ref{fig:AllportNeedFulfillment}). These results indicate that in this data set outgroup attitudes were significantly predicted by the fulfillment of core situational needs and this effect partially emerged via its effect on perceived interaction quality. 

<!-- \faQuestionCircle\ Are we sure that we don't want some sort of bootstrapped indirect effect?  -->

\subsubsection{Allport's Conditions}

```{r medicalOutModelInterceptAttAllport, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptAllport <-
  lme(
    AttitudesDutch ~ AllportsCondition_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptAllport <-
    lmer(
      AttitudesDutch ~ AllportsCondition_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Att$lmerInterceptAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerInterceptAllport)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeNull, 
      mdlMedicalOut$Att$lmeInterceptAllport) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptAllport <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptAllport)
```

```{r medicalOutModelSlopesAttAllport, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesAllport <-
  lme(
    AttitudesDutch ~
      AllportsCondition_cwc,
    random = ~ 1 + AllportsCondition_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesAllport <- lmer(
    AttitudesDutch ~
      AllportsCondition_cwc +
      (1 + AllportsCondition_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# all variables standardized within PPT
summ(
  mdlMedicalOut$Att$lmerSlopesAllportZ <- lmer(
    AttitudesDutch_zwc ~
      AllportsCondition_zwc +
      (1 + AllportsCondition_zwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

# standardized coefficients
stdCoef.merMod(mdlMedicalOut$Att$lmerSlopesAllport)

# 95%CIs
mdlMedicalOut$Att$lmerSlopesAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesAllport)

# Attempts at R^2
#r2mlm::r2mlm(mdlMedicalOut$Att$lmerSlopesAllport, bargraph = TRUE)
mitml::multilevelR2(mdlMedicalOut$Att$lmerSlopesAllport)
performance::r2(mdlMedicalOut$Att$lmerSlopesAllport)
performance::model_performance(mdlMedicalOut$Att$lmerSlopesAllport)
performance::compare_performance(mdlMedicalOut$Att$lmerNull, 
                                 mdlMedicalOut$Att$lmerInterceptAllport, 
                                 mdlMedicalOut$Att$lmerSlopesAllport)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeNull, 
      mdlMedicalOut$Att$lmeInterceptAllport, 
      mdlMedicalOut$Att$lmeSlopesAllport) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varSlopesAllport <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesAllport)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesAllport <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesAllport, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesAllport[[1]],
  mdlMedicalOut$Att$diagSlopesAllport[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesAllport[[3]],
  mdlMedicalOut$Att$diagSlopesAllport[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesAllport <- 
  dtMedicalSupp$medicalOutWithinBetween %>% 
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesAllport,
                           dtMedicalSupp$medicalOutWithinBetween %>% filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesAllport <-
    ggplot(data = mdlMedicalOut$Att$predSlopesAllport, 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttAllport.png",
  mdlMedicalOut$Att$predPltSlopesAllport,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

```{r medicalOutModelInterceptQltAllport, include=FALSE}
# Create and save Model
mdlMedicalOut$Qlt$lmeInterceptAllport <-
  lme(
    qualityOverall ~ AllportsCondition_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Qlt$lmerInterceptAllport <-
    lmer(
      qualityOverall ~ AllportsCondition_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Qlt$lmerInterceptAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Qlt$lmerInterceptAllport)

# Compare new model to previous step
anova(mdlMedicalOut$Qlt$lmeNull, 
      mdlMedicalOut$Qlt$lmeInterceptAllport) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Qlt$varInterceptAllport <-
  lme4::VarCorr(mdlMedicalOut$Qlt$lmeInterceptAllport)
```

```{r medicalOutModelSlopesQltAllport, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Qlt$lmeSlopesAllport <-
  lme(
    qualityOverall ~
      AllportsCondition_cwc,
    random = ~ 1 + AllportsCondition_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Qlt$lmerSlopesAllport <-
    lmer(
      qualityOverall ~
        AllportsCondition_cwc +
        (1 + AllportsCondition_cwc | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3,
  center = FALSE
)

mdlMedicalOut$Qlt$lmerSlopesAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Qlt$lmerSlopesAllport)

# Compare new model to previous step
anova(mdlMedicalOut$Qlt$lmeNull, 
      mdlMedicalOut$Qlt$lmeInterceptAllport, 
      mdlMedicalOut$Qlt$lmeSlopesAllport) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Qlt$varSlopesAllport <- 
  lme4::VarCorr(mdlMedicalOut$Qlt$lmeSlopesAllport)

# Assumption Checks:
mdlMedicalOut$Qlt$diagSlopesAllport <-
  sjPlot::plot_model(mdlMedicalOut$Qlt$lmerSlopesAllport, type = "diag")
grid.arrange(
  mdlMedicalOut$Qlt$diagSlopesAllport[[1]],
  mdlMedicalOut$Qlt$diagSlopesAllport[[2]]$`PID`,
  mdlMedicalOut$Qlt$diagSlopesAllport[[3]],
  mdlMedicalOut$Qlt$diagSlopesAllport[[4]]
)

# Plot prediction model
mdlMedicalOut$Qlt$predSlopesAllport <- 
  dtMedicalSupp$medicalOutWithinBetween %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Qlt$lmeSlopesAllport,
                           dtMedicalSupp$medicalOutWithinBetween %>% filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Qlt$predPltSlopesAllport <-
    ggplot(data = mdlMedicalOut$Qlt$predSlopesAllport %>% filter(PID %in% dtMedicalSupp$medicalOutPltIDs), 
           aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAllport.png",
  mdlMedicalOut$Qlt$predPltSlopesAllport,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

```

```{r medicalOutModelInterceptAttAllportQlt, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptAllportQlt <-
  lme(
    AttitudesDutch ~ AllportsCondition_cwc + qualityOverall_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptAllportQlt <-
    lmer(
      AttitudesDutch ~ AllportsCondition_cwc + qualityOverall_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerInterceptAllportQltCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerInterceptAllportQlt)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull, 
  mdlMedicalOut$Att$lmeInterceptAllportQlt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptAllportQlt <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptAllportQlt)
```

```{r medicalOutModelSlopesAttAllportQlt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesAllportQlt <-
  lme(
    AttitudesDutch ~
      AllportsCondition_cwc + qualityOverall_cwc,
    random = ~ 1 + AllportsCondition_cwc + qualityOverall_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesAllportQlt <- lmer(
    AttitudesDutch ~
      AllportsCondition_cwc + qualityOverall_cwc +
      (1 + AllportsCondition_cwc + qualityOverall_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween,
    control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
  ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerSlopesAllportQltCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesAllportQlt)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull,
  mdlMedicalOut$Att$lmeInterceptAllportQlt,
  mdlMedicalOut$Att$lmeSlopesAllportQlt
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varSlopesAllportQlt <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesAllportQlt)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesAllportQlt <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesAllportQlt, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesAllportQlt[[1]],
  mdlMedicalOut$Att$diagSlopesAllportQlt[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesAllportQlt[[3]],
  mdlMedicalOut$Att$diagSlopesAllportQlt[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesAllportQlt <- 
  dtMedicalSupp$medicalOutWithinBetween %>% 
  filter(complete.cases(AllportsCondition, qualityOverall)) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesAllportQlt,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(AllportsCondition, qualityOverall)) %>%
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesAllportQlt <-
    ggplot(data = mdlMedicalOut$Att$predSlopesAllportQlt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttAllportQlt.png",
  mdlMedicalOut$Att$predPltSlopesAllportQlt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

As we did with core need fulfillment, we sequentially tested whether the fulfillment of Allport's contact conditions was (1) related to more positive outgroup attitudes, (2) higher perceived interaction quality, and (3) whether the variance explained by Allport's Conditions is assumed by the perceived interaction quality if considered jointly. In the multilevel models we find that the fulfillment of Allport's Conditions during outgroup contacts was associated with more positive outgroup attitudes (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesAllport, lmerCI = mdlMedicalOut$Att$lmerSlopesAllportCI, varName = "AllportsCondition_cwc")`) and also predicted higher perceived interaction quality (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Qlt$lmeSlopesAllport, lmerCI = mdlMedicalOut$Qlt$lmerSlopesAllportCI, varName = "AllportsCondition_cwc")`). Moreover, when we consider the influences of Allport's Conditions and interaction quality on outgroup attitudes jointly, we find that perceived interaction quality is a substantially stronger predictor (random slopes mode; `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesAllportQlt, lmerCI = mdlMedicalOut$Att$lmerSlopesAllportQltCI, varName = "qualityOverall_cwc")`) and the unique variance explained by Allport's Conditions was less than half of its original effect size (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesAllportQlt, lmerCI = mdlMedicalOut$Att$lmerSlopesAllportQltCI, varName = "AllportsCondition_cwc")`; also see Table \ref{tab:intergroupNeedsTblLong} and Figure \ref{fig:AllportNeedFulfillment}). These results indicate that in this data set the fulfillment of Allport's conditions had a significant influence on outgroup attitudes and this effect is likely, in parts, explained by its effect through perceived interaction quality. 

<!-- \faQuestionCircle\ Are we sure that we don't want some sort of bootstrapped indirect effect?  -->


\subsubsection{Compare Fulfillment of Core Need and Allport's Conditions}

```{r AllportVsCore, include=FALSE}

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeSlopesAllport, 
      mdlMedicalOut$Att$lmeSlopesCore) %>%
  as.data.frame() %>%
  select(-call) %>%
  kbl(
    .,
    caption = "Medical: Comparison of Allport's Conditions to Core Situational Need",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

AIC(
  mdlMedicalOut$Att$lmerSlopesAllport,
  mdlMedicalOut$Att$lmerSlopesCore
)

BIC(
  mdlMedicalOut$Att$lmerSlopesAllport,
  mdlMedicalOut$Att$lmerSlopesCore
)

performance::compare_performance(
  mdlMedicalOut$Att$lmerSlopesAllport,
  mdlMedicalOut$Att$lmerSlopesCore
)
```

```{r medicalOutModelInterceptAttCoreAllport, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptCoreAllport <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc + AllportsCondition_cwc,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptCoreAllport <-
    lmer(
      AttitudesDutch ~ KeyNeedFulfillment_cwc + AllportsCondition_cwc + (1 | PID),
      data = dtMedicalSupp$medicalOutWithinBetween
    ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerInterceptCoreAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerInterceptCoreAllport)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull, 
  mdlMedicalOut$Att$lmeInterceptAllport,
  mdlMedicalOut$Att$lmeInterceptCoreAllport
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptCoreAllport <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptCoreAllport)
```

```{r medicalOutModelSlopesAttCoreAllport, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesCoreAllport <-
  lme(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + AllportsCondition_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc + AllportsCondition_cwc | PID,
    na.action = na.omit,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesCoreAllport <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + AllportsCondition_cwc +
      (1 + KeyNeedFulfillment_cwc + AllportsCondition_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerSlopesCoreAllportCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesCoreAllport)

# Compare new model to previous step
anova(
  mdlMedicalOut$Att$lmeNull,
  mdlMedicalOut$Att$lmeInterceptCoreAllport,
  mdlMedicalOut$Att$lmeSlopesCoreAllport
) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varSlopesCoreAllport <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesCoreAllport)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesCoreAllport <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesCoreAllport, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesCoreQlt[[1]],
  mdlMedicalOut$Att$diagSlopesCoreQlt[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesCoreQlt[[3]],
  mdlMedicalOut$Att$diagSlopesCoreQlt[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesCoreAllport <- 
  dtMedicalSupp$medicalOutWithinBetween %>% 
  filter(complete.cases(KeyNeedFulfillment, AllportsCondition)) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesCoreAllport,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(KeyNeedFulfillment, AllportsCondition)) %>%
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesCoreAllport <-
    ggplot(data = mdlMedicalOut$Att$predSlopesCoreQlt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttCoreAllport.png",
  mdlMedicalOut$Att$predPltSlopesCoreAllport,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

To test wether Allport's conditions or the core need fulfillment are better at predicting outgroup attitudes, we first assess relative model performance indices (i.e., Akaike information criterion, and Bayesian information criterion), and then consider the two predictors in a joint model to see whether the two approaches predict the same variance in outgroup attitudes. When comparing the model selection indices, we find that the fulfillment of the situational core need indeed performs slightly better than the model using Allport's conditions ($AIC_{CoreNeed}$ `r format(round(AIC(mdlMedicalOut$Att$lmerSlopesCore), 2), nsmall = 2)` < `r format(round(AIC(mdlMedicalOut$Att$lmerSlopesAllport), 2), nsmall = 2)` $AIC_{Allport}$, and $BIC_{CoreNeed}$ `r format(round(BIC(mdlMedicalOut$Att$lmerSlopesCore), 2), nsmall = 2)` < `r format(round(BIC(mdlMedicalOut$Att$lmerSlopesAllport), 2), nsmall = 2)` $BIC_{Allport}$). Additionally, when considering the predictors jointly, we find that both significantly predict outgroup attitudes with similar sized regression parameters (random slopes model; Allport's Conditions: `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreAllport, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreAllportCI, varName = "AllportsCondition_cwc")`, Core Need: `r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreAllport, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreAllportCI, varName = "KeyNeedFulfillment_cwc")`; also see Table \ref{tab:intergroupNeedsTblLong} and Figure \ref{fig:AllportNeedFulfillment}). This indicates that, although both Allport's conditions and the core need fulfillment seem to (in part) work through perceived interaction quality, they explain different aspects of the variance in outgroup attitudes and do not constitute one another.  

\subsubsection{Robustness}

```{r medicalModelAttNullInt, include=FALSE}
# Create and save Model
mdlMedical$lmerAttNullInt <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
             data = dtMedical$full %>%
               filter(complete.cases(
                 OutgroupInteraction
               ))) # use optim if it does not converge

mdlMedical$lmeAttNullInt <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtMedical$full %>%
      filter(complete.cases(
        OutgroupInteraction
      )),
    na.action = na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(mdlMedical$lmerAttNull) #or with the lme function
summ(mdlMedical$lmerAttNullInt, digits = 3)
```

```{r medicalModelInterceptAttCoreInt, include=FALSE}
# Create and save Model
mdlMedical$lmeInterceptAttCoreInt <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc * OutgroupInteraction,
    random =  ~ 1 | PID,
    na.action = na.omit,
    data = dtMedical$full
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedical$lmerInterceptAttCoreInt <- lmer(
    AttitudesDutch ~ KeyNeedFulfillment_cwc * OutgroupInteraction + (1 | PID),
    data = dtMedical$full
  ),
  confint = TRUE,
  digits = 3
)

mdlMedical$lmerInterceptAttCoreIntCI <- 
  confint(method = "Wald", mdlMedical$lmerInterceptAttCoreInt)

# Compare new model to previous step
anova(mdlMedical$lmeAttNullInt, 
      mdlMedical$lmeInterceptAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedical$varInterceptAttCoreInt <- 
  lme4::VarCorr(mdlMedical$lmeInterceptAttCoreInt)
```
```{r medicalModelSlopesAttCoreIntX, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedical$lmeSlopesAttCoreInt <- lme(
  AttitudesDutch ~
    KeyNeedFulfillment_cwc * OutgroupInteraction,
  random = ~ 1 + KeyNeedFulfillment_cwc + OutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  na.action = na.omit,
  data = dtMedical$full
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedical$lmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc * OutgroupInteraction +
      (1 + KeyNeedFulfillment_cwc + OutgroupInteraction | PID),
    data = dtMedical$full
  ), 
  confint = TRUE,
  digits = 3
)

mdlMedical$lmerSlopesAttCoreIntCI <- 
  confint(method = "Wald", mdlMedical$lmerSlopesAttCoreInt)

# Compare new model to previous step
anova(mdlMedical$lmeAttNullInt, 
      mdlMedical$lmeInterceptAttCoreInt,
      mdlMedical$lmeSlopesAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedical$varSlopesAttCoreInt <- 
  lme4::VarCorr(mdlMedical$lmeSlopesAttCoreInt)

# Assumption Checks:
mdlMedical$diagSlopesAttCoreInt <-
  sjPlot::plot_model(mdlMedical$lmerSlopesAttCoreInt, type = "diag")
grid.arrange(
  mdlMedical$diagSlopesAttCoreInt[[1]],
  mdlMedical$diagSlopesAttCoreInt[[2]]$`PID`,
  mdlMedical$diagSlopesAttCoreInt[[3]],
  mdlMedical$diagSlopesAttCoreInt[[4]]
)

# Plot prediction model
mdlMedical$predSlopesAttCoreInt <- 
  dtMedical$full %>%
  filter(complete.cases(KeyNeedFulfillment, OutgroupInteraction)) %>%
  filter(PID %in% dtMedicalSupp$medicalPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedical$lmeSlopesAttCoreInt,
                           dtMedical$full %>% 
                             filter(complete.cases(KeyNeedFulfillment, OutgroupInteraction)) %>%
                             filter(PID %in% dtMedicalSupp$medicalPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedical$predPltSlopesAttCoreInt <-
    ggplot(data = mdlMedical$predSlopesAttCoreInt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Medical_PredictionPlot_SlopesAttCoreInt.png",
  mdlMedical$predPltSlopesAttCoreInt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

We again checked for alternative models of the key need fulfillment. First, when considering generalized situational core need fulfillment together with whether an intergroup contact took place, we find that there is no significant main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "KeyNeedFulfillment_cwc")`) but a stronger interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "KeyNeedFulfillment_cwc:OutgroupInteractionYes")`). Together with a significant main effect of having an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "OutgroupInteractionYes")`), this indicates that it is not key need fulfillment in general --- but key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. This finding is consistent with the results of the previous studies.

```{r medicalOutModelInterceptAttCoreSdt, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptCoreSdt <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptCoreSdt <- lmer(
    AttitudesDutch ~ KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# To be compared against a model with only the self-determination theory needs
mdlMedicalOut$Att$lmeInterceptSdt <-
  lme(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

summ(
  mdlMedicalOut$Att$lmerInterceptSdt <- lmer(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous steps
anova(
  mdlMedicalOut$Att$lmeInterceptSdt,
  mdlMedicalOut$Att$lmeInterceptCoreSdt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptCoreSdt <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptCoreSdt)
```

```{r medicalOutModelSlopesAttCoreSdt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesCoreSdt <-
  lme(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc + Competence_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim", maxIter = 100, msMaxIter = 100),
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerSlopesCoreSdtCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesCoreSdt)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeInterceptSdt,
      mdlMedicalOut$Att$lmeInterceptCoreSdt, 
      mdlMedicalOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# model with SDT only
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesSdt <-
  lme(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesSdt <- lmer(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeInterceptSdt,
      mdlMedicalOut$Att$lmeSlopesSdt, 
      mdlMedicalOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")


# Save variances
mdlMedicalOut$Att$varSlopesCoreSdt <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesCoreSdt)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesCoreSdt <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesCoreSdt, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesCoreSdt[[1]],
  mdlMedicalOut$Att$diagSlopesCoreSdt[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesCoreSdt[[3]],
  mdlMedicalOut$Att$diagSlopesCoreSdt[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesCoreSdt <- 
  dtMedicalSupp$medicalOutWithinBetween %>%
  filter(complete.cases(
    KeyNeedFulfillment,
    Autonomy, Competence, Relatedness
    )) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID, Autonomy, Competence, Relatedness) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesCoreSdt,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(
                               KeyNeedFulfillment,
                               Autonomy, Competence, Relatedness
                             )) %>%
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesCoreSdt <-
    ggplot(data = mdlMedicalOut$Att$predSlopesCoreSdt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttCoreStd.png",
  mdlMedicalOut$Att$predPltSlopesCoreSdt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

# Model comparison
medicalSdtComp <-
  anova(
    mdlMedicalOut$Att$lmerSlopesSdt, 
    mdlMedicalOut$Att$lmerSlopesCoreSdt
  ) %>%
  as.data.frame()
medicalSdtCompDf <- medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Df"]
medicalSdtCompN <- sapply(ranef(mdlMedicalOut$Att$lmerSlopesCoreSdt), nrow)
medicalSdtCompChi <- medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2)
medicalSdtCompP <-
  ifelse(medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001,
         "< .001",
         paste0("= ", medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3)))

medicalSdtCompChiSq <- paste0("$\\chi^2$(", medicalSdtCompDf, ", \\textit{N} = ", medicalSdtCompN, ") = ", medicalSdtCompChi, ", \\textit{p} ", medicalSdtCompP)
```

In a final step, we again checked whether during the interaction the core situational need remains a meaningful predictor even when taking other fundamental psychological needs into account. We find that the core need fulfillment adds additional variance above a model with only the self-determination theory needs (random slopes models; `r medicalSdtCompChiSq`). We find that the core need explains the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "KeyNeedFulfillment_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all of the three fundamental needs. However, similar to the previous study, in this large sample relatedness (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Relatedness_cwc")`), competence (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Competence_cwc")`) and autonomy (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Autonomy_cwc")`) each also predicted positive outgroup attitudes independently. This being said, the regression coefficient for the core need was three times larger (with all scaling being equal). For full results see Table \ref{tab:robustnessTblLong} and Figure \ref{fig:Robustness} as well as Online Supplementary Material A. Across all three studies, psychological need fulfillment, thus, remained a robust and flexible predictor of positive outgroup attitudes.

\section{Embeddedness and Stability across Studies}

\begin{center}
    \noindent\rule{8cm}{0.4pt}\\
    \hl{\textit{New Section:}}\\
    \vspace{-0.25cm}
    \noindent\rule{8cm}{0.4pt}
\end{center}

Beyond the individual results of the three studies, we conducted three additional analyses to test the broader cross-study claims and contextualize our results. In particular, we aim to gain a broader picture of the individual results by considering them jointly, and we leverage the data from all participants to test between-participant contact effects and explore the content of the participants' situational contact needs.

\subsection{Stability}
We begin by assessing the stability of our main analyses across the three studies. To do so, we plot the effect sizes of each parameter of interest in a forest plot. Forest plots are a popular form of evidence synthesis and are commonly found within meta-analytic efforts. By plotting a standardized effect size and confidence interval of key parameters for each study, forest plots offer a visual method of identifying broader patterns across studies. This affords us a chance to spot stable as well as unreliable effects more easily. While not the focus of our efforts here, forest plots are commonly accompanied with a meta-analytic effect size that summarizes the effect size across studies. 

We assess forest plots of the basic contact hypothesis test (Figure \ref{fig:ContactHypothesis}), the core need fulfillment proposal (Figure \ref{fig:AllportNeedFulfillment}), as well as the robustness analyses (Figure \ref{fig:Robustness}). For the basic contact hypothesis test we see that outgroup contact has a strong and consistent effect on outgroup attitudes while interactions with non-outgroup members consistently have no meaningful effect on outgroup attitudes. While this would be expected from the general intergroup contact literature, this is not a trivial finding. We are among the first to assess the contact hypothesis using real-life intensive longitudinal data and these close to event assessments are comparable but not equivalent to the assessments found in cross-sectional data (also see below). When looking at Figure \ref{fig:AllportNeedFulfillment}, we see that the fulfillment of core needs during intergroup contacts is consistently a meaningful predictor of outgroup attitudes and interaction quality perceptions (see Figure \ref{fig:AllportNeedFulfillment} A and B). We also see that the effect of core need fulfillment on outgroup attitudes is strongly reduced when modeled together with interaction quality perceptions, supporting our assertion that interaction quality offers a psychological mechanism for the direct effect. Additionally, the core need fulfillment is also consistently outgroup contact specific (Figure \ref{fig:Robustness} A) and remains a meaningful predictor of outgroup attitudes even when controlling for traditional psychological need fulfillments (Figure \ref{fig:Robustness} B).

\subsection{General contact hypothesis}

```{r join data sets for analysis, include=FALSE}
# Join aggregated data
avS1 <- dtWorkerSupp$workerAvFreQual %>%
  select(
    -ExternalReference
  ) %>%
  mutate(
    PID = c(1:nrow(.)),
    study = "S1"
  ) %>%
  select(PID, everything())
avS2 <- dtStudentSupp$studentContactFreq %>%
  mutate(
    study = "S2"
  )
avS3 <- dtMedicalSupp$medicalContactFreq %>%
  mutate(
    study = "S3"
  )

avAll <- bind_rows(avS1, avS2, avS3) %>%
  mutate(
    ID = c(1:nrow(.)),
    studyNum1 = ifelse(study == "S1", 1, 0),
    studyNum3 = ifelse(study == "S3", 1, 0)
  )
avAll$study2 <- relevel(as.factor(avAll$study),"S2")
```
```{r OLS regression across the three studies, include=FALSE}
lmAllAttFreqQualX <-
  lm(
    AvAttitude ~ SumContactNL_c * AvQualityOut_c + SumContactNL_c * study2 + AvQualityOut_c * study2,
    data = avAll
  )

summ(
  lmAllAttFreqQualX,
  confint = TRUE,
  digits = 3
)

# prepare F stat for manuscript
fit <- summary(lmAllAttFreqQualX)
lmAllFstatLatex <- paste(
  "\\textit{F}(",
  fit$fstatistic["numdf"],
  ", ",
  fit$fstatistic["dendf"],
  ") = ",
  format(round(fit$fstatistic["value"], 2), nsmall = 2),
  ", \\textit{p} = ",
  format(round(
    pf(
      fit$fstatistic["value"],
      fit$fstatistic["numdf"],
      fit$fstatistic["dendf"],
      lower.tail = FALSE
    ),
    3
  ), nsmall = 3),
  ", \\textit{R\\textsuperscript{2}} = ",
  format(round(fit$r.squared, 2), nsmall = 2),
  sep = ""
)
```

During the main analyses, we have thus far shown that participants held more positive outgroup attitudes following intergroup contacts and that a perceived interaction quality was associated with more positive outgroup attitudes following an intergroup contact. We have, however, not brought the two elements of the contact hypothesis together in a single analysis. This is mainly due to the difficulty that interaction quality ratings are only possible when participants had an interaction --- which means that the two factors cannot be assessed in a multilevel analysis that models individual measurement occasions. This has not been an issue in the past literature because experimental and cross-sectional data collections have only considered cases in which intergroup contacts were present. Outside of the lab, the most common method has been to ask participants to recall how many interactions they had over the past month, how positive these interactions were, and how positive they feel towards the outgroup in general. The effects of intergroup contacts, interaction quality, and outgroup attitudes are thus summarized by the participant in a cognitive recall aggregation. Intensive longitudinal data also allows for aggregation of all three variables, with the differences that the measurements are aggregated from individual reports that are close to the actual experience. However, this aggregation process summarizes the dense multitude of measurement occasions as single summary statistics per participants. This, by extension, means that we face statistical power restrictions on the person level and have thus decided to only present this analysis based on a combined data set of all three studies.

We run a linear regression model where average outgroup attitudes are predicted by the number of interactions and the average interaction quality ratings of all participants across the three studies. We do so while controlling for the possible effects of study-specific differences. To include the study-membership as a control variable, we use the student sample (Study 2) as the reference group because it is both the largest and the most homogeneous study. Looking at the overall model, we find that the model predicts a statistically significant amount of variance in average outgroup attitudes (`r lmAllFstatLatex`). Looking at the individual effects, we find that only the number of outgroup interactions has a clear association with average outgroup attitudes (`r LmCoeffLatex(lmMdl = lmAllAttFreqQualX, varName = "SumContactNL_c", ci = TRUE)`). The average interaction quality perceptions had a much smaller effect (`r LmCoeffLatex(lmMdl = lmAllAttFreqQualX, varName = "AvQualityOut_c", ci = TRUE)`), and we do not find the most important interaction effect at all. In short, the effect of outgroup interactions did not depend on the average interaction quality, so that participants who on average had more positive interactions were not statistically more likely to show higher average outgroup attitudes than those with more negative interactions. This result is surprising because it contradicts the tenet of the intergroup contact hypothesis that intergroup contact depends on positive contact. 

\subsection{Contact key need content}
Finally, we use the qualitative data from the participants’ self-identified core needs to contextualize the results of our main analysis. However, because our participants jointly reported on thousands of intergroup contacts, it would not be feasible to analyse these qualitative responses in a traditional qualitative content analysis. We instead rely on recent machine learning advances within the natural language processing domain. For our analysis we use the BERT language model. BERT (Bidirectional Encoder Representations from Transformers) was developed by Google in 2018 and today forms a key elements of many natural language processing workflows. In its essence, BERT is a framework that allows users to codify every word in relation to every other word within a large set of documents. This task is immensely computationally intensive and most users of the framework don't create their own model. We use the "all-mpnet-base-v2" language model for our embedding. The model is a community-based version of BERT that uses Microsoft's "mpnet-base" model and is fine-tuned with 1 Billion diverse sentence pairs. The model was trained with a 768 dimensional dense vector space (a relatively high number) to represent every word. As a result, the model is widely considered to be one of the most accurate all-purpose language models within the open-source BERT framework. We extracted 47 topics from the 2,983 interaction goal free-text entries --- a relatively large number of topics. The higher number of topics allows us to retain more of the smaller topics and leaves a relatively low number of 308 free-text entries unclassified (10.33%). A full write up of the topic modeling process is available in Online Supplemental Material C.

In terms of the content of the topics, we find that a number of topics are primarily task-oriented, where participants hope to increase their study, research, presentation, or work performance. Opposing the task and work oriented needs, are a wide variety of leisure-related wishes. Specifically, relaxation and entertainment wishes were prominent terms across several topics. Additionally, a number of clusters is primarily relationship-oriented, so that participants sought contact with outgroup members for intimate and casual social contact in itself. Similarly, socializing and celebrations were also explicit social needs (incl., parties). Another set of topics was more practically oriented, when participants sought to share food and cook cook together, or had organizational needs (e.g., housing, cleaning, and living). 

A reasonable set of contact goals were specifically migration-specific (e.g., wish to learn about culture, politics, and language) or were concerned inquiry and information needs more generally (e.g., seeking answers, bureaucratic information). A further set of topics was specifically geared towards a wish to experience cultural products (e.g., music, theater, food) or had travel related goals in their interactions with the majority group members.

One interesting observation was the importance of contact goals specific to contact through the medical and public health system. This goal type was partly specific to our young medical professionals sample (e.g., working with patients, treatment), but also more broadly interactions of newcomers with the outgroup majority as patients themselves (e.g., therapeutic goals). Also health, fitness, and personal improvement goals (e.g., sports and music) were common goals that participants shared during the interactions with the majority group members. A final topic was that of spiritual, religious, and otherwise transcendental needs (incl. meditation, prayer, religious services). 

Thus, almost all other extracted topics fall into broader or narrower need concepts that are commonly discussed within the psychological needs literature \citep[e.g.,][]{Orehek2018a} and offer insight into a core aspect of the migration experience that has remained broadly under-explored \citep[][]{Kreienkamp2022d}.


```{r intergroupGeneralTblLong, include=FALSE}
# Table of intergroup contact in ESM data:
# lm
#    #Contact
#     AvQual
#     #Contact*AvQual
# lme
#     OutgroupInteraction
#     NonOutgroupInteraction

# OLS 
# Study 1:
mdlWorker$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtWorkerSupp$workerAvFreQual)
# Study 2:
mdlStudent$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtStudentSupp$studentContactFreq)
# Study 3: 
mdlMedical$lmAttFreqQualX <-
  lm(AvAttitude ~ SumContactNL_c * AvQuality_c, data = dtMedicalSupp$medicalContactFreq)

# tabModelTest <- tab_model(mdlWorker$lmAttFreqQualX,
#                           mdlStudent$lmAttFreqQualX,
#                           mdlMedical$lmAttFreqQualX)

# summ(mdlWorker$lmAttFreqQualX)

mdlTblElementsGeneralLm <- list(mdlWorker$lmAttFreqQualX,
                                mdlStudent$lmAttFreqQualX,
                                mdlMedical$lmAttFreqQualX)

mdlPrepLmGeneral <- list()
for (i in 1:length(mdlTblElementsGeneralLm)) {
  mdlPrepLmGeneral[[i]] <- lmTblPrep(mdlTblElementsGeneralLm[[i]])
}
mdlTblGeneralLm <- data.frame(
  coef = c(
    sapply(mdlPrepLmGeneral, function(x) x[1]$coeficients$coef) %>% as.character %>% unique,
    names(mdlPrepLmGeneral[[1]]$fit)
  )
)
for (i in 1:length(mdlPrepLmGeneral)){
  mdlTblGeneralLm <- join(mdlTblGeneralLm, mdlPrepLmGeneral[[i]]$mdlTbl, by = "coef")
}

# lme
# Study 1: 
dtWorkerSupp$workerWithinBetween$AttitudesDutch <- dtWorkerSupp$workerWithinBetween$thermometerDutch_1
mdlWorker$lmerInterceptAttTypeTbl <- lmer(
    AttitudesDutch ~ OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM + (1 | PID),
    data = dtWorkerSupp$workerWithinBetween
  )
dtWorkerSupp$workerWithinBetween$AttitudesDutch_zwc <- dtWorkerSupp$workerWithinBetween$thermometerDutch_1
mdlWorker$lmerInterceptAttTypeTblZ <- lmer(
    AttitudesDutch_zwc ~ OutgroupInteraction_zwc + NonOutgroupInteraction_zwc + OutgroupInteractionM_gmz + NonOutgroupInteractionM_gmz + (1 | PID),
    data = dtWorkerSupp$workerWithinBetween
  )
# Study 2:
mdlStudent$lmerSlopesAttType <- lmer(
    AttitudesDutch ~
      OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM +
      (1 + OutgroupInteractionC + NonOutgroupInteractionC | PID),
    data = dtStudentSupp$studentWithinBetween
  )
mdlStudent$lmerSlopesAttTypeZ <- lmer(
    AttitudesDutch_zwc ~
      OutgroupInteraction_zwc + NonOutgroupInteraction_zwc + OutgroupInteractionM_gmz + NonOutgroupInteractionM_gmz +
      (1 + OutgroupInteraction_zwc + NonOutgroupInteraction_zwc | PID),
    data = dtStudentSupp$studentWithinBetween
  )
# Study 3:
mdlMedical$lmerSlopesAttType <- lmer(
    AttitudesDutch ~
      OutgroupInteractionC + NonOutgroupInteractionC + OutgroupInteractionM + NonOutgroupInteractionM +
      (1 + OutgroupInteractionC + NonOutgroupInteractionC | PID),
    data = dtMedicalSupp$medicalWithinBetween
  )
mdlMedical$lmerSlopesAttTypeZ <- lmer(
    AttitudesDutch_zwc ~
      OutgroupInteraction_zwc + NonOutgroupInteraction_zwc + OutgroupInteractionM_gmz + NonOutgroupInteractionM_gmz +
      (1 + OutgroupInteraction_zwc + NonOutgroupInteraction_zwc | PID),
    data = dtMedicalSupp$medicalWithinBetween
  )

mdlTblElementsGeneralLmer <- list(
  c(mdlWorker$lmerInterceptAttTypeTbl, mdlWorker$lmerInterceptAttTypeTblZ),
  c(mdlStudent$lmerSlopesAttType, mdlStudent$lmerSlopesAttTypeZ),
  c(mdlMedical$lmerSlopesAttType, mdlMedical$lmerSlopesAttTypeZ)
  )

mdlPrepGeneral <- list()
for (i in 1:length(mdlTblElementsGeneralLmer)) {
  mdlPrepGeneral[[i]] <- lmerTblPrep(mdlTblElementsGeneralLmer[[i]][[1]], mdlTblElementsGeneralLmer[[i]][[2]])
}

mdlTblGeneralLmer <- data.frame(
  coef = c(
    sapply(mdlPrepGeneral, function(x) x[1]$coeficients$coef) %>% as.character %>% unique,
    names(mdlPrepGeneral[[1]]$random),
    names(mdlPrepGeneral[[1]]$fit)
  )
)
for (i in 1:length(mdlPrepGeneral)){
  mdlTblGeneralLmer <- join(mdlTblGeneralLmer, mdlPrepGeneral[[i]]$mdlTbl, by = "coef")
}

names(mdlTblGeneralLmer) <- make.unique(names(mdlTblGeneralLmer))
names(mdlTblGeneralLmer) <- gsub("Beta", "ES", names(mdlTblGeneralLmer))
names(mdlTblGeneralLm) <- make.unique(names(mdlTblGeneralLm))
names(mdlTblGeneralLm) <- gsub("Eta2_partial", "ES", names(mdlTblGeneralLm))

lmAllAttFreqQualX2 <-
  lm(
    AvAttitude ~ 
      SumContactNL_c * AvQualityOut_c + 
      SumContactNL_c * studyNum1 + 
      SumContactNL_c * studyNum3 + 
      AvQualityOut_c * studyNum1 + 
      AvQualityOut_c * studyNum3,
    data = avAll
  )

mdlTblGeneralLmAll <- lmTblPrep(lmAllAttFreqQualX2)$mdlTbl %>%
  rename(., ES = Eta2_partial) %>%
  replace(is.na(.), "") %>%
  mutate(
    B = ifelse(ES != "", paste(B, "; $\\eta_{partial}$ = ", ES, sep = ""), B),
    ES = ""
  )

mdlTblGeneralLong <- 
  rbind(mdlTblGeneralLmer %>%
                             filter(
                               coef %in% c(
                                 "(Intercept)",
                                 "OutgroupInteraction",
                                 "NonOutgroupInteraction",
                                 "OutgroupInteractionM",
                                 "NonOutgroupInteractionM",
                                 "R2Marg_R2Cond"
                               )
                             ),
        mdlTblGeneralLmAll %>%
                             filter(
                               coef %in% c(
                                 "(Intercept)",
                                 "AvQualityOut",
                                 "AvQuality",
                                 "studyNum1",
                                 "studyNum3",
                                 "SumContactNL:AvQualityOut",
                                 "SumContactNL:studyNum1",
                                 "SumContactNL:studyNum3", 
                                 "AvQualityOut:studyNum1",
                                 "AvQualityOut:studyNum3",
                                 "R2_R2_adjusted"
                               )
                             ) %>%
          mutate(
            B.1 = "",
            ES.1 = "",
            B.2 = "",
            ES.2 =  ""
          )
                           )
mdlTblGeneralLong$coef <- mapvalues(
  mdlTblGeneralLong$coef,
  from = c(
    "R2_R2_adjusted",
    "R2Marg_R2Cond"
  ),
  to = c(
    "$R^2 / R^2_{adjusted}$",
    "$R^2_{marginal} / R^2_{conditional}$"
  )
)

library(huxtable)
testTbl <- mdlTblGeneralLong %>%
  replace(is.na(.), "") %>%
  hux(.) %>%
  set_contents(1, 1:7, c("", rep(c("$B$", "$\\beta$"), (ncol(.)-1)/2))) %>%
  insert_row("", "Study 1", "", "Study 2", "", "Study 3", "", after = 0) %>%
  merge_cells(1, 2:3) %>% 
  merge_cells(1, 4:5) %>% 
  merge_cells(1, 6:7) %>% 
  set_align(1:2, everywhere, "center") %>%
  set_escape_contents(everywhere, everywhere, FALSE) %>%
  set_header_rows(1, TRUE) %>%
  theme_article %>%
  set_bottom_border(1, 2:3, brdr(0.5, "solid", "black")) %>%
  set_bottom_border(1, 4:5, brdr(0.5, "solid", "black")) %>%
  set_bottom_border(1, 6:7, brdr(0.5, "solid", "black")) %>%
  insert_column(after = 3, fill = "") %>%
  set_bottom_border(1, 4, 0) %>%
  insert_column(after = 6, fill = "") %>%
  set_bottom_border(1, 7, 0) %>%
  set_col_width(., 7, 0) %>%
  insert_row(after = 2, "\\textbf{Within Participants [multilevel linear regression]}", fill = "", copy_cell_props = FALSE) %>%
  merge_cells(3, 1:ncol(.)) %>%
  insert_row(after = 9, "\\textbf{Between Participant [aggregated linear regression]}", fill = "", copy_cell_props = FALSE) %>%
  merge_cells(10, 1:ncol(.)) %>%
  set_left_padding(4:9, 1, 12) %>%
  set_left_padding(11:nrow(.), 1, 12) %>%
  add_footnote(., "Note:<br>**** p < .0001, *** p < .001, ** p < .01, * p < .05") %>%
  set_font_size(9) 

for (i in 11:(nrow(testTbl)-1)) {
  testTbl <- testTbl %>%
    merge_cells(i, 2:ncol(.)) %>%
    set_align(i, 2:ncol(.), "center")
}
testTbl %>% 
  as_flextable

capture.output(print_latex(testTbl), file = 'TableOnly.tex')

quick_latex(testTbl, file = "Table.tex", open = FALSE)



mdlTblGeneralLong %>%
  replace(is.na(.), "") %>%
  mutate(
    B = ifelse(
      B.1 == "", paste("\\multicolumn{6}{c}{", B, sep=""),
      B
    )
  ) %>%
  kbl(
    .,
    caption = "Intergroup General",
    format = "latex",
    linesep = "",
    booktabs = TRUE,
    col.names = c("", rep(c("$B$", "$\\beta$"), (ncol(.)-1)/2)),
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  )  %>%
  kable_classic() %>%
  add_header_above(
    .,
    c(
      "",
      "Study 1" = 2,
      "Study 2" = 2,
      "Study 3" = 2
    )
  ) %>%
  pack_rows("Within Participants [multilevel linear regression] (Effect Size = $\\beta$)", 1, 6, escape = FALSE) %>%
  pack_rows("Between Participant [aggregated linear regression] (Effect Size = $\\eta_{partial}$)", 7, nrow(mdlTblGeneralLong), escape = FALSE) %>%
  kableExtra::footnote(
    .,
    general = c("**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"), 
    escape = FALSE
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  gsub(" &  &  &  &  & \\", "}\\", ., fixed = TRUE) %>% # fix table position
  kableExtra::landscape() %>%
  save_kable("Tables/mdlContactGeneralLong.tex")
```


```{r intergroupGeneralTblWide, include=FALSE}
mdlTblGeneral <-
  merge(mdlTblGeneralLm,
        mdlTblGeneralLmer %>% 
          mutate(coef = gsub("R2Marg_R2Cond", "R2_R2_adjusted", coef)),
        by = "coef",
        all = TRUE) 
names(mdlTblGeneral) <- make.unique(names(mdlTblGeneral))
mdlTblGeneral <- mdlTblGeneral %>%
  arrange(match(coef, c(
    sapply(mdlPrepLmGeneral, function(x) x[1]$coeficients$coef) %>% as.character %>% unique,
    sapply(mdlPrepGeneral, function(x) x[1]$coeficients$coef) %>% as.character %>% unique %>% setdiff(., "(Intercept)"),
    names(mdlPrepGeneral[[1]]$random),
    "Groups",
    names(mdlPrepLmGeneral[[1]]$fit),
    setdiff(names(mdlPrepGeneral[[1]]$fit), c(names(mdlPrepLmGeneral[[1]]$fit), "Groups"))
  ))) %>%
  replace(is.na(.), "")

mdlTblGeneral$coef <- mapvalues(
  mdlTblGeneral$coef,
  from = c(
    "sigmaSq",
    "tau00",
    "tau11",
    "rho01",
    "rho00",
    "fTest",
    "R2",
    "R2_adjusted",
    "R2_R2_adjusted",
    "R2_marginal",
    "R2_conditional",
    "R2Marg_R2Cond"
  ),
  to = c(
    "$\\sigma^2$",
    "$\\tau_{00}$",
    "$\\tau_{11}$",
    "$\\rho_{01}$",
    "$\\rho_{00}$",
    "F Test",
    "$R^2$",
    "$R^2_{adjusted}$",
    "$R^{2 (a)}$",
    "$R^2_{marginal}$",
    "$R^2_{conditional}$",
    "$R^2_{marginal} / R^2_{conditional}$"
  )
)

# Headers
mdlTblGeneralHeader <- data.frame(
  data = as.character(mdlTblGeneral[mdlTblGeneral$coef == "data",]),
  formula = as.character(mdlTblGeneral[mdlTblGeneral$coef == "formula",])
) %>%
  filter(data != "",
         data != "data") %>%
  mutate(study = str_extract(data, "Worker|Student|Medical")) %>%
  mutate(study = gsub("Worker", "Study 1", study)) %>%
  mutate(study = gsub("Student", "Study 2", study)) %>%
  mutate(study = gsub("Medical", "Study 3", study)) %>%
  mutate(dv = sub(" ~.*", "", formula)) %>%
  mutate(dv = gsub("Raw", " ", dv))

mdlTblGeneralHeaderDv <- data.frame(names = mdlTblGeneralHeader$dv, span = 2) %>% 
  mutate(names = as.character(names)) %>%
  rbind(c("", 1), .) %>%
  mutate(span = as.numeric(span))

mdlTblGeneralHeaderStudy <- rbind.data.frame(rle(mdlTblGeneralHeader$study)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)


# Long Table
mdlTblGeneralLong <- mdlTblGeneral %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    #format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  ) %>%
  kable_classic() %>%
  add_header_above(., mdlTblGeneralHeaderStudy) %>%
  add_header_above(
    .,
    c(
      "",
      "Contact [Full Sample]" = 6,
      "Self-Determination Theory [Outgroup Interactions only]" = 6
    )
  ) %>%
  pack_rows("Random", 7, 11) %>%
  pack_rows("Fit", 12, 27) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    ), 
    escape = TRUE
  ) %>%
  gsub("_cwc", "", ., fixed = TRUE) 

# shortened Table
mdlTblGeneralShort <- mdlTblGeneral %>%
  filter(
    !coef %in% c(
      "data",
      "formula",
      "groupId",
      "$R^2$",
      "$R^2_{adjusted}$",
      "$R^2_{marginal}$",
      "$R^2_{conditional}$",
      "logLik",
      "deviance"
    )
  ) %>%
  mutate_all(linebreak) %>%
  kbl(
    .,
    caption = "Intergroup General",
    format = "latex",
    linesep = "",
    booktabs = TRUE,
    col.names = c("", rep(c("$B$", "$\\eta_p$"), (ncol(.)-1)/4), rep(c("$B$", "$\\beta$"), (ncol(.)-1)/4)),
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  )  %>%
  kable_classic() %>%
  add_header_above(., mdlTblGeneralHeaderStudy) %>%
  add_header_above(
    .,
    c(
      "",
      "Aggregated [across participants]" = 6,
      "Contemporaneous [within participants]" = 6
    )
  ) %>%
  pack_rows("Random", 7, 11) %>%
  pack_rows("Fit", 12, 18) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    ),
    alphabet = c("For linear regression: $R^2 / R^2_{adjusted}$, for multilevel regression: $R^2_{marginal} / R^2_{conditional}$ "),
    escape = FALSE
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("_cwc", "", ., fixed = TRUE)   %>%
  gsub("\\makecell[l]", "\\makecell[c]", ., fixed = TRUE) %>%
  gsub("\\makecell[r]", "\\makecell[c]", ., fixed = TRUE) %>%
  gsub("objVar$", "", ., fixed = TRUE) %>%
  gsub("slope_intercept.", "slope.intercept", ., fixed = TRUE) %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  kableExtra::landscape() %>%
  save_kable("Tables/mdlContactGeneral.tex")
mdlTblGeneralShort
```

```{r intergroupNeedsTblLong, include=FALSE}
# Table of core need and Allports Conditions (potentially two tables — e.g., needs + allport)
# all lmer models :-)
# make different options

# collect relevant models
# Study 1:
# Rename variables for consistency
tblDtS1Needs <- dtWorkerSupp$workerOutWithinBetween %>%
  select(
    Attitude = thermometerDutch_1,
    AttitudeZ = thermometerDutch_1_zwc,
    CoreNeed = keymotive_fulfillemt_1_cwc,
    CoreNeedZ = keymotive_fulfillemt_1_zwc,
    QualityRaw = quality_overall_1,
    Quality = quality_overall_1_cwc,
    QualityZ = quality_overall_1_zwc,
    PID = PID
  )
# Quality ~ CoreNeed
tblLmerS1QltInterceptCore <- lmer(
  QualityRaw ~ CoreNeed + (1 | PID),
  data = tblDtS1Needs
)
tblLmerS1QltInterceptCoreZ <- lmer(
  QualityZ ~ CoreNeedZ + (1 | PID),
  data = tblDtS1Needs
)
# Attitude ~ CoreNeed
tblLmerS1AttSlopeCore <- lmer(
  Attitude ~ CoreNeed + (1 + CoreNeed | PID),
  data = tblDtS1Needs
)
tblLmerS1AttSlopeCoreZ <- lmer(
  AttitudeZ ~ CoreNeedZ + (1 + CoreNeedZ | PID),
  data = tblDtS1Needs
)
# Attitude ~ CoreNeed + Quality
tblLmerS1AttSlopeCoreQlt <- lmer(
  Attitude ~ CoreNeed + Quality + (1 + CoreNeed + Quality | PID),
  data = tblDtS1Needs
)
tblLmerS1AttSlopeCoreQltZ <- lmer(
  AttitudeZ ~ CoreNeedZ + QualityZ + (1 + CoreNeedZ + QualityZ | PID),
  data = tblDtS1Needs
)


# Study 2:
# Rename variables for consistency
tblDtS2Needs <- dtStudentSupp$studentOutWithinBetween %>%
  select(
    Attitude = AttitudesDutch,
    AttitudeZ = AttitudesDutch_zwc,
    CoreNeed = KeyNeedFullfillment_cwc,
    CoreNeedZ = KeyNeedFullfillment_zwc,
    QualityRaw = quality_overall,
    Quality = quality_overall_cwc,
    QualityZ = quality_overall_zwc,
    PID = PID
  )
# Quality ~ CoreNeed
tblLmerS2QltSlopesCore <- lmer(
  QualityRaw ~ CoreNeed + (1 + CoreNeed | PID),
  data = tblDtS2Needs
)
tblLmerS2QltSlopesCoreZ <- lmer(
  QualityZ~ CoreNeedZ + (1 + CoreNeedZ | PID),
  data = tblDtS2Needs
)
# Attitude ~ CoreNeed
tblLmerS2AttSlopesCore <- lmer(
  Attitude ~ CoreNeed + (1 + CoreNeed | PID),
  data = tblDtS2Needs
)
tblLmerS2AttSlopesCoreZ <- lmer(
  AttitudeZ ~ CoreNeedZ + (1 + CoreNeedZ | PID),
  data = tblDtS2Needs
)
# Attitude ~ CoreNeed + Quality
tblLmerS2AttSlopesCoreQlt <- lmer(
  Attitude ~ CoreNeed + Quality + (1 + CoreNeed + Quality | PID),
  data = tblDtS2Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
tblLmerS2AttSlopesCoreQltZ <- lmer(
  AttitudeZ ~ CoreNeedZ + QualityZ + (1 + CoreNeedZ + QualityZ | PID),
  data = tblDtS2Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)


# Study 3:
# Rename variables for consistency
tblDtS3Needs <- dtMedicalSupp$medicalOutWithinBetween %>%
  select(
    Attitude = AttitudesDutch,
    AttitudeZ = AttitudesDutch_zwc,
    CoreNeed = KeyNeedFulfillment_cwc,
    CoreNeedZ = KeyNeedFulfillment_zwc,
    Allport = AllportsCondition_cwc,
    AllportZ = AllportsCondition_zwc,
    QualityRaw = qualityOverall,
    Quality = qualityOverall_cwc,
    QualityZ = qualityOverall_zwc,
    PID = PID
  )
# Quality ~ CoreNeed
tblLmerS3QltSlopesCore <- lmer(
  QualityRaw ~ CoreNeed + (1 + CoreNeed | PID),
  data = tblDtS3Needs
)
tblLmerS3QltSlopesCoreZ <- lmer(
  QualityZ ~ CoreNeedZ + (1 + CoreNeedZ | PID),
  data = tblDtS3Needs
)
# Attitude ~ CoreNeed
tblLmerS3AttSlopesCore <- lmer(
  Attitude ~ CoreNeed + (1 + CoreNeed | PID),
  data = tblDtS3Needs
)
tblLmerS3AttSlopesCoreZ <- lmer(
  AttitudeZ ~ CoreNeedZ + (1 + CoreNeedZ | PID),
  data = tblDtS3Needs
)
# Attitude ~ CoreNeed + Quality
tblLmerS3AttSlopesCoreQlt <- lmer(
  Attitude ~ CoreNeed + Quality + (1 + CoreNeed + Quality | PID),
  data = tblDtS3Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
tblLmerS3AttSlopesCoreQltZ <- lmer(
  AttitudeZ ~ CoreNeedZ + QualityZ + (1 + CoreNeedZ + QualityZ | PID),
  data = tblDtS3Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
# Quality ~ Allport
tblLmerS3QltSlopesAllport <- lmer(
  QualityRaw ~ Allport + (1 + Allport | PID),
  data = tblDtS3Needs
)
tblLmerS3QltSlopesAllportZ <- lmer(
  QualityZ ~ AllportZ + (1 + AllportZ | PID),
  data = tblDtS3Needs
)
# Attitude ~ Allport
tblLmerS3AttSlopesAllport <- lmer(
  Attitude ~ Allport + (1 + Allport | PID),
  data = tblDtS3Needs
)
tblLmerS3AttSlopesAllportZ <- lmer(
  AttitudeZ ~ AllportZ + (1 + AllportZ | PID),
  data = tblDtS3Needs
)
# Attitude ~ Allport + Quality
tblLmerS3AttSlopesAllportQlt <- lmer(
  Attitude ~ Allport + Quality + (1 + Allport + Quality | PID),
  data = tblDtS3Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
tblLmerS3AttSlopesAllportQltZ <- lmer(
  AttitudeZ ~ AllportZ + QualityZ + (1 + AllportZ + QualityZ | PID),
  data = tblDtS3Needs,
  control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))
)
# Attitude ~ Allport + CoreNeed
tblLmerS3AttSlopesAllportCore <- lmer(
  Attitude ~ CoreNeed + Allport + (1 + CoreNeed + Allport | PID),
  data = tblDtS3Needs
)
tblLmerS3AttSlopesAllportCoreZ <- lmer(
  AttitudeZ ~ CoreNeedZ + AllportZ + (1 + CoreNeedZ + AllportZ | PID),
  data = tblDtS3Needs
)


mdlTblElements <- list(
  # Study 1:
  c(tblLmerS1QltInterceptCore, tblLmerS1QltInterceptCoreZ),
  c(tblLmerS1AttSlopeCore, tblLmerS1AttSlopeCoreZ),
  c(tblLmerS1AttSlopeCoreQlt, tblLmerS1AttSlopeCoreQltZ),
  # Study 2:
  c(tblLmerS2QltSlopesCore, tblLmerS2QltSlopesCoreZ),
  c(tblLmerS2AttSlopesCore, tblLmerS2AttSlopesCoreZ),
  c(tblLmerS2AttSlopesCoreQlt, tblLmerS2AttSlopesCoreQltZ),
  # Study 3:
  c(tblLmerS3QltSlopesCore, tblLmerS3QltSlopesCoreZ),
  c(tblLmerS3AttSlopesCore, tblLmerS3AttSlopesCoreZ),
  c(tblLmerS3AttSlopesCoreQlt, tblLmerS3AttSlopesCoreQltZ),
  c(tblLmerS3QltSlopesAllport, tblLmerS3QltSlopesAllportZ),
  c(tblLmerS3AttSlopesAllport, tblLmerS3AttSlopesAllportZ),
  c(tblLmerS3AttSlopesAllportQlt, tblLmerS3AttSlopesAllportQltZ),
  c(tblLmerS3AttSlopesAllportCore, tblLmerS3AttSlopesAllportCoreZ)
  )

# lmerTblPrep(mdlTblElements[[1]][[1]], mdlTblElements[[1]][[2]])


mdlPrep <- list()
for (i in 1:length(mdlTblElements)) {
  mdlPrep[[i]] <- lmerTblPrep(mdlTblElements[[i]][[1]], mdlTblElements[[i]][[2]])
}

shortMdlPath <- list()
for(i in 1:length(mdlPrep)){
  study <- gsub("S", "Study", str_extract(mdlPrep[[i]]$fit$data, "S1|S2|S3"))
  dv <- gsub("Raw", "", sub(" ~.*", "", mdlPrep[[i]]$fit$formula)) 
  pred <- gsub("\\(Intercept\\)", "", paste(mdlPrep[[i]]$coeficients$coef, collapse = ''))
  
  name <- paste(study, dv, pred, sep='.')
  shortMdlPath[[name]] <- mdlPrep[[i]]$coeficients[, c("coef", "est", "Bstar", "B", "estBeta", "BetaStar", "Beta")]
}

# Long format
shortMdlPrep <- list()
for(i in 1:length(mdlPrep)){
  study <- gsub("S", "Study", str_extract(mdlPrep[[i]]$fit$data, "S1|S2|S3"))
  dv <- gsub("Raw", "", sub(" ~.*", "", mdlPrep[[i]]$fit$formula)) 
  pred <- gsub("\\(Intercept\\)", "", paste(mdlPrep[[i]]$coeficients$coef, collapse = ''))
  
  name <- paste(study, dv, pred, sep='.')
  tmp <- rbind(
    mdlPrep[[i]]$coeficients[, c("coef", "B", "Beta")],
    data.frame(
      coef = "R2Marg_R2Cond",
      B = mdlPrep[[i]]$fit$R2Marg_R2Cond,
      Beta = ""
    )
  )
  shortMdlPrep[[name]] <- tmp
}

# Manual assembly
emptyNeedTbl <- data.frame(coef = shortMdlPrep$Study3.Attitude.CoreNeedQuality$coef, B = NA, Beta = NA)
tmp <- shortMdlPrep[grepl("Study1", names(shortMdlPrep))]
s1MdlTbl <- data.frame(coef = shortMdlPrep$Study1.Attitude.CoreNeedQuality$coef)
for (i in 1:length(tmp)){
  s1MdlTbl <- join(s1MdlTbl, tmp[[i]], by = "coef")
}
s1MdlTbl <- s1MdlTbl %>%
  join(., emptyNeedTbl, by = "coef")
tmp <- shortMdlPrep[grepl("Study2", names(shortMdlPrep))]
s2MdlTbl <- data.frame(coef = shortMdlPrep$Study2.Attitude.CoreNeedQuality$coef)
for (i in 1:length(tmp)){
  s2MdlTbl <- join(s2MdlTbl, tmp[[i]], by = "coef")
}
s2MdlTbl <- s2MdlTbl %>%
  join(., emptyNeedTbl, by = "coef")

s3NeedMdlTbl <- data.frame(coef = shortMdlPrep$Study3.Attitude.CoreNeedQuality$coef) %>%
  join(., shortMdlPrep$Study3.Quality.CoreNeed, by = "coef") %>%
  join(., shortMdlPrep$Study3.Attitude.CoreNeed, by = "coef") %>%
  join(., shortMdlPrep$Study3.Attitude.CoreNeedQuality, by = "coef") %>%
  join(., emptyNeedTbl, by = "coef")

s3AllportMdlTbl <- data.frame(coef = shortMdlPrep$Study3.Attitude.AllportQuality$coef) %>%
  join(., shortMdlPrep$Study3.Quality.Allport, by = "coef") %>%
  join(., shortMdlPrep$Study3.Attitude.Allport, by = "coef") %>%
  join(., shortMdlPrep$Study3.Attitude.AllportQuality, by = "coef") %>%
  join(., emptyNeedTbl, by = "coef")

emptyNeedAllportTbl <- data.frame(coef = shortMdlPrep$Study3.Attitude.CoreNeedAllport$coef, B = NA, Beta = NA)
s3NeedAllportMdlTbl <- emptyNeedAllportTbl %>%
  join(., emptyNeedAllportTbl, by = "coef") %>%
  join(., emptyNeedAllportTbl, by = "coef") %>%
  join(., shortMdlPrep$Study3.Attitude.CoreNeedAllport, by = "coef")
  
mdlTblLong <- rbind(
  s1MdlTbl,
  s2MdlTbl,
  s3NeedMdlTbl,
  s3AllportMdlTbl,
  s3NeedAllportMdlTbl
)

mdlTblLong$coef <- mapvalues(
  mdlTblLong$coef,
  from = c(
    "R2Marg_R2Cond"
  ),
  to = c(
    "$R^2_{marginal}$ / $R^2_{conditional}$"
  )
)

mdlTblTheoreticalLong <- mdlTblLong %>%
  replace(is.na(.), "") %>%
  #mutate_all(linebreak) %>%
  kbl(
    .,
    caption = "Theoretical Test: Core Need Fulfillment and Allport's Conditions",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    escape = FALSE
  ) %>%
  kable_classic() %>%
  add_header_above(., c(" ", "Quality" = 2, "Attitude" = 6)) %>%
  pack_rows("Study 1: Needs", 1, 4) %>%
  pack_rows("Study 2: Needs", 5, 8) %>%
  pack_rows("Study 3: Needs", 9, 12) %>%
  pack_rows("Study 3: Allport", 13, 16) %>%
  pack_rows("Study 3: Needs & Allport", 17, 20)  %>%
  kable_styling(latex_options = "scale_down") %>%
  kableExtra::landscape() %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/mdlTheorylong.tex")
```

```{r intergroupNeedsTblWide, include=FALSE}
# wide format
mdlTbl <- data.frame(
  coef = c(
    sapply(mdlPrep, function(x) x[1]$coeficients$coef) %>% unlist %>% unique,
    names(mdlPrep[[1]]$random),
    names(mdlPrep[[1]]$fit)
  )
)
for (i in 1:length(mdlPrep)){
  mdlTbl <- join(mdlTbl, mdlPrep[[i]]$mdlTbl, by = "coef")
  #mdlTbl <- merge(mdlTbl, mdlPrep[[i]]$mdlTbl, by = "coef", all = TRUE, sort = FALSE, no.dups = TRUE, suffixes=c("", ""))
}

mdlTblHeader <- data.frame(
  data = as.character(mdlTbl[mdlTbl$coef == "data",]),
  formula = as.character(mdlTbl[mdlTbl$coef == "formula",])
) %>%
  filter(data != "",
         data != "data") %>%
  mutate(study = str_extract(data, "S1|S2|S3")) %>%
  mutate(study = gsub("S", "Study ", study)) %>%
  mutate(dv = sub(" ~.*", "", formula)) %>%
  mutate(dv = gsub("Raw", " ", dv)) %>%
  mutate(pred = str_extract(formula, "(CoreNeed \\+ Allport)|CoreNeed|Allport")) %>%
  mutate(header = paste(study, pred, sep = " - "))

mdlTblHeaderFreq <- rbind.data.frame(rle(mdlTblHeader$header)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)

mdlTblHeader2 <- data.frame(names = mdlTblHeader$dv, span = 2) %>% 
  mutate(names = as.character(names)) %>%
  rbind(c("", 1), .) %>%
  mutate(span = as.numeric(span))

mdlTblHeader2.2 <- rbind.data.frame(rle(mdlTblHeader$dv)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)

mdlTbl$coef <- mapvalues(
  mdlTbl$coef,
  from = c(
    "sigmaSq",
    "tau00",
    "tau11",
    "rho01",
    "rho00",
    "R2_marginal",
    "R2_conditional", 
    "R2Marg_R2Cond"
  ),
  to = c(
    "$\\sigma^2$",
    "$\\tau_{00}$",
    "$\\tau_{11}$",
    "$\\rho_{01}$",
    "$\\rho_{00}$",
    "$R^2_{marginal}$",
    "$R^2_{conditional}$",
    "$R^2_{marginal}$ / $R^2_{conditional}$"
  )
)

# Full Table
mdlTblTheoreticalLong <- mdlTbl %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Theoretical Test: Core Need Fulfillment and Allport's Conditions",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    escape = FALSE,
    digits = 3
  ) %>%
  kable_classic() %>%
  add_header_above(., mdlTblHeader2) %>%
  add_header_above(., mdlTblHeaderFreq) %>%
  pack_rows("Fixed", 1, 4) %>%
  pack_rows("Random", 5, 9) %>%
  pack_rows("Fit", 10, 21)

# shortened Table
mdlTblTheoreticalShort <- mdlTbl %>%
  replace(is.na(.), "")
names(mdlTblTheoreticalShort) <- make.unique(names(mdlTblTheoreticalShort))
mdlTblTheoreticalShort <- mdlTblTheoreticalShort %>%
  filter(
    !coef %in% c(
      "data",
      "formula",
      "groupId",
      "$R^2_{marginal}$",
      "$R^2_{conditional}$",
      "logLik",
      "deviance"
    )
  ) %>%
  mutate_all(linebreak) %>%
  kbl(
    .,
    caption = "Core Need Fulfillment and Allport's Conditions",
    format = "latex",
    linesep = "",
    booktabs = TRUE,
    col.names = c("", rep(c("$B$", "$\\beta$"), (ncol(.)-1)/2)),
    align = c("l", rep("c", ncol(.)-1)),
    escape = FALSE,
    digits = 3
  ) %>%
  kable_classic() %>%
  add_header_above(., mdlTblHeader2) %>%
  add_header_above(., mdlTblHeaderFreq) %>%
  pack_rows("Fixed", 1, 4) %>%
  pack_rows("Random", 5, 9) %>%
  pack_rows("Fit", 10, 15) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    ),
    escape = FALSE
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  kableExtra::landscape() %>%
  gsub("\\makecell[l]", "\\makecell[c]", ., fixed = TRUE) %>%
  gsub("\\makecell[r]", "\\makecell[c]", ., fixed = TRUE) %>%
  gsub("objVar$", "", ., fixed = TRUE) %>%
  gsub("slope_intercept.", "slope.intercept", ., fixed = TRUE) %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/mdlTheory.tex")
mdlTblTheoreticalShort
```

```{r robustnessTblLong, include=FALSE}
# Table of all robustness checks (w/ and w/out SDT only)

# Full Sample
# Study 1:
robustTblWorkerFull <- 
  dtWorkerSupp$workerWithinBetween %>%
  select(
    AttitudesDutch = thermometerDutch_1,
    AttitudesDutch_zwc = thermometerDutch_1_zwc,
    CoreNeed_cwc = keyMotiveFulfilled_cwc,
    CoreNeed_zwc = keyMotiveFulfilled_zwc,
    OutgroupInteraction = OutgroupInteraction,
    OutgroupInteraction_zwc = OutgroupInteraction_zwc,
    PID = PID
  )
mdlWorkerLmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc * OutgroupInteraction +
      (1 + CoreNeed_cwc + OutgroupInteraction | PID),
    data = robustTblWorkerFull
  )
mdlWorkerLmerSlopesAttCoreIntZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc * OutgroupInteraction_zwc +
      (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID),
    data = robustTblWorkerFull
  )
#Study 2:
robustTblStudentFull <- 
  dtStudentSupp$studentWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFullfillment_cwc,
    CoreNeed_zwc = KeyNeedFullfillment_zwc,
    OutgroupInteraction = OutgroupInteraction,
    OutgroupInteraction_zwc = OutgroupInteraction_zwc, 
    PID = PID
  )
mdlStudentLmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc * OutgroupInteraction +
      (1 + CoreNeed_cwc + OutgroupInteraction | PID),
    data = robustTblStudentFull
  )
mdlStudentLmerSlopesAttCoreIntZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc * OutgroupInteraction_zwc +
      (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID),
    data = robustTblStudentFull
  )
#Study 3:
robustTblMedicalFull <- 
  dtMedicalSupp$medicalWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFulfillment_cwc,
    CoreNeed_zwc = KeyNeedFulfillment_zwc,
    OutgroupInteraction = OutgroupInteraction,
    OutgroupInteraction_zwc = OutgroupInteraction_zwc, 
    PID = PID
  )
mdlMedicalLmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc * OutgroupInteraction +
      (1 + CoreNeed_cwc + OutgroupInteraction | PID),
    #data = dtMedical$full
    data = robustTblMedicalFull
  )
mdlMedicalLmerSlopesAttCoreIntZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc * OutgroupInteraction_zwc +
      (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID),
    #data = dtMedical$full
    data = robustTblMedicalFull
  )

# SDT
# Study 1:
robustTblWorkerOut <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  select(
    AttitudesDutch = thermometerDutch_1,
    AttitudesDutch_zwc = thermometerDutch_1_zwc,
    CoreNeed_cwc = keymotive_fulfillemt_1_cwc,
    CoreNeed_zwc = keymotive_fulfillemt_1_zwc,
    Competence_cwc = competence_1_cwc,
    Competence_zwc = competence_1_zwc,
    Autonomy_cwc = autonomy_1_cwc,
    Autonomy_zwc = autonomy_1_zwc,
    Relatedness_cwc = relatedness_1_cwc,
    Relatedness_zwc = relatedness_1_zwc,
    PID = PID
  )
mdlWorkerOutLmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = robustTblWorkerOut
  )
mdlWorkerOutLmerSlopesCoreSdtZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc +
      (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID),
    data = robustTblWorkerOut
  )
# Study 2:
robustTblStudentOut <- 
  dtStudentSupp$studentOutWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFullfillment_cwc,
    CoreNeed_zwc = KeyNeedFullfillment_zwc,
    Competence_cwc = Competence_cwc,
    Competence_zwc = Competence_zwc,
    Autonomy_cwc = Autonomy_cwc,
    Autonomy_zwc = Autonomy_zwc,
    Relatedness_cwc = Relatedness_cwc,
    Relatedness_zwc = Relatedness_zwc,
    PID = PID
  )
mdlStudentOutLmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = robustTblStudentOut
  )
mdlStudentOutLmerSlopesCoreSdtZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc +
      (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID),
    data = robustTblStudentOut
  )
# Study 3:
robustTblMedicalOut <- 
  dtMedicalSupp$medicalOutWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFulfillment_cwc,
    CoreNeed_zwc = KeyNeedFulfillment_zwc,
    Competence_cwc = Competence_cwc,
    Competence_zwc = Competence_zwc,
    Autonomy_cwc = Autonomy_cwc,
    Autonomy_zwc = Autonomy_zwc,
    Relatedness_cwc = Relatedness_cwc,
    Relatedness_zwc = Relatedness_zwc,
    PID = PID
  )
mdlMedicalOutLmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = robustTblMedicalOut
  )
mdlMedicalOutLmerSlopesCoreSdtZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc +
      (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID),
    data = robustTblMedicalOut
  )

# collect models for table
mdlRobustTblElements <- list(
  # full
  c(mdlWorkerLmerSlopesAttCoreInt, mdlWorkerLmerSlopesAttCoreIntZ),
  c(mdlStudentLmerSlopesAttCoreInt, mdlStudentLmerSlopesAttCoreIntZ),
  c(mdlMedicalLmerSlopesAttCoreInt, mdlMedicalLmerSlopesAttCoreIntZ),
  # outgroup
  c(mdlWorkerOutLmerSlopesCoreSdt, mdlWorkerOutLmerSlopesCoreSdtZ),
  c(mdlStudentOutLmerSlopesCoreSdt, mdlStudentOutLmerSlopesCoreSdtZ),
  c(mdlMedicalOutLmerSlopesCoreSdt, mdlMedicalOutLmerSlopesCoreSdtZ)
  )

mdlRobustPrep <- list()
for (i in 1:length(mdlRobustTblElements)) {
  mdlRobustPrep[[i]] <- lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])
}

# manual assembly
shortRobustPrep <- list()
for(i in 1:length(mdlRobustPrep)){
  study <- str_extract(mdlRobustPrep[[i]]$fit$data, "Worker|Student|Medical")
  sample <- str_extract(mdlRobustPrep[[i]]$fit$data, "Full|Out")
  #dv <- sub(" ~.*", "", mdlRobustPrep[[i]]$fit$formula)
  #pred <- gsub("\\(Intercept\\)", "", paste(mdlRobustPrep[[i]]$coeficients$coef, collapse = ''))
  
  name <- paste(study, sample, sep='.')
  tmp <- rbind(
    mdlRobustPrep[[i]]$coeficients[, c("coef", "B", "Beta")],
    data.frame(
      coef = "R2Marg_R2Cond",
      B = mdlRobustPrep[[i]]$fit$R2Marg_R2Cond,
      Beta = ""
    )
  )
  shortRobustPrep[[name]] <- tmp
}


tmp <- shortRobustPrep[grepl("Full", names(shortRobustPrep))]
fullRobustTbl <- data.frame(coef = shortRobustPrep$Medical.Full$coef)
for (i in 1:length(tmp)){
  fullRobustTbl <- join(fullRobustTbl, tmp[[i]], by = "coef")
}

tmp <- shortRobustPrep[grepl("Out", names(shortRobustPrep))]
outRobustTbl <- data.frame(coef = shortRobustPrep$Medical.Out$coef)
for (i in 1:length(tmp)){
  outRobustTbl <- join(outRobustTbl, tmp[[i]], by = "coef")
}

robustTblLong <- rbind(
  fullRobustTbl,
  outRobustTbl
)

robustTblLong$coef <- mapvalues(
  robustTblLong$coef,
  from = c(
    "R2Marg_R2Cond"
  ),
  to = c(
    "$R^2_{marginal}$ / $R^2_{conditional}$"
  )
)

mdlTblRobustLong <- robustTblLong %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    #format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    escape = FALSE
  ) %>%
  kable_classic() %>%
  add_header_above(., c(" ", "Study 1" = 2, "Study 2" = 2, "Study 3" = 2)) %>%
  pack_rows("Contact [Full Sample]", 1, 5) %>%
  pack_rows("Self-Determination Theory [Outgroup Interactions only]", 6, 11) %>%
  kable_styling(latex_options = "scale_down") %>%
  kableExtra::landscape() %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/mdlRobustlong.tex")
```

```{r robustnessTblWide, include=FALSE}
# Wide format
mdlRobustTbl <- data.frame(
  coef = c(
    sapply(mdlRobustPrep, function(x) x[1]$coeficients$coef) %>% unlist %>% unique,
    names(mdlRobustPrep[[1]]$random),
    names(mdlRobustPrep[[1]]$fit)
  )
)
for (i in 1:length(mdlRobustPrep)){
  mdlRobustTbl <- join(mdlRobustTbl, mdlRobustPrep[[i]]$mdlTbl, by = "coef")
  #mdlTbl <- merge(mdlRobustTbl, mdlRobustPrep[[i]]$mdlTbl, by = "coef", all = TRUE, sort = FALSE, no.dups = TRUE, suffixes=c("", ""))
}

mdlRobustTblHeader <- data.frame(
  data = as.character(mdlRobustTbl[mdlRobustTbl$coef == "data",]),
  formula = as.character(mdlRobustTbl[mdlRobustTbl$coef == "formula",])
) %>%
  filter(data != "",
         data != "data") %>%
  mutate(study = str_extract(data, "Worker|Student|Medical")) %>%
  mutate(study = gsub("Worker", "Study 1", study)) %>%
  mutate(study = gsub("Student", "Study 2", study)) %>%
  mutate(study = gsub("Medical", "Study 3", study)) %>%
  mutate(dv = sub(" ~.*", "", formula)) %>%
  mutate(dv = gsub("Raw", " ", dv)) %>%
  mutate(pred = str_extract(formula, "CoreNeed|Allport")) %>%
  mutate(header = paste(study, pred, sep = " - "))

mdlRobustTblHeaderFreq <- rbind.data.frame(rle(mdlRobustTblHeader$header)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)

mdlRobustTblHeaderDv <- data.frame(names = mdlRobustTblHeader$dv, span = 2) %>% 
  mutate(names = as.character(names)) %>%
  rbind(c("", 1), .) %>%
  mutate(span = as.numeric(span))

mdlRobustTblHeaderStudy <- rbind.data.frame(rle(mdlRobustTblHeader$study)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)

mdlRobustTbl$coef <- mapvalues(
  mdlRobustTbl$coef,
  from = c(
    "sigmaSq",
    "tau00",
    "tau11",
    "rho01",
    "rho00",
    "R2_marginal",
    "R2_conditional", 
    "R2Marg_R2Cond"
  ),
  to = c(
    "$\\sigma^2$",
    "$\\tau_{00}$",
    "$\\tau_{11}$",
    "$\\rho_{01}$",
    "$\\rho_{00}$",
    "$R^2_{marginal}$",
    "$R^2_{conditional}$",
    "$R^2_{marginal}$ / $R^2_{conditional}$"
  )
)

# Long Table
mdlTblRobustLong <- mdlRobustTbl %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    #format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  ) %>%
  kable_classic() %>%
  add_header_above(., mdlRobustTblHeaderStudy) %>%
  add_header_above(
    .,
    c(
      "",
      "Contact [Full Sample]" = 6,
      "Self-Determination Theory [Outgroup Interactions only]" = 6
    )
  ) %>%
  pack_rows("Fixed", 1, 7) %>%
  pack_rows("Random", 8, 12) %>%
  pack_rows("Fit", 13, 25) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    ),
    escape = FALSE
  ) %>%
  gsub("_cwc", "", ., fixed = TRUE) 

# shortened Table
mdlTblRobustShort <- mdlRobustTbl %>%
  replace(is.na(.), "")
names(mdlTblRobustShort) <- make.unique(names(mdlTblRobustShort))
mdlTblRobustShort <- mdlTblRobustShort %>%
  filter(
    !coef %in% c(
      "data",
      "formula",
      "groupId",
      "$R^2_{marginal}$",
      "$R^2_{conditional}$",
      "logLik",
      "deviance"
    )
  ) %>%
  mutate_all(linebreak) %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    format = "latex",
    linesep = "",
    booktabs = TRUE,
    col.names = c("", rep(c("$B$", "$\\beta$"), (ncol(.)-1)/2)),
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  )  %>%
  kable_classic() %>%
  add_header_above(., mdlRobustTblHeaderStudy) %>%
  add_header_above(
    .,
    c(
      "",
      "Contact [Full Sample]" = 6,
      "Self-Determination Theory [Outgroup Interactions only]" = 6
    )
  ) %>%
  pack_rows("Fixed", 1, 7) %>%
  pack_rows("Random", 8, 12) %>%
  pack_rows("Fit", 13, 18) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    ), 
    escape = FALSE
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  kableExtra::landscape() %>%
  gsub("_cwc", "", ., fixed = TRUE)  %>%
  gsub("\\makecell[l]", "\\makecell[c]", ., fixed = TRUE) %>%
  gsub("\\makecell[r]", "\\makecell[c]", ., fixed = TRUE) %>%
  gsub("objVar$", "", ., fixed = TRUE) %>%
  gsub("slope_intercept.", "slope.intercept", ., fixed = TRUE) %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/mdlRobustness.tex")
mdlTblRobustShort
```


```{r descrFullLong, include=FALSE}
allMlCor <-
  MlCorMat(
    data = dtAll$mlAll, #%>% filter(OutgroupInteraction == "Yes"),
    id = "ID",
    selection = c("KeyNeedFullfillment", "Competence", "Autonomy", "Relatedness", "qualityOverall", "AttitudesDutch"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Quality", "Attitudes NL")
  )


# Full Sample Descriptives Table [longer format (Descriptives below correlations)]
rbind(
  workerMlCor %>%
    rownames_to_column(., "Variable") %>%
    mutate(Allport = ""),
  studentMlCor %>%
    select(names(workerMlCor)) %>%
    rownames_to_column(., "Variable") %>%
    mutate(Allport = ""),
  medicalMlCor %>%
    select(names(workerMlCor), "Allport") %>%
    rownames_to_column(., "Variable"),
  allMlCor %>%
    select(names(workerMlCor)) %>%
    rownames_to_column(., "Variable") %>%
    mutate(Allport = "")
) %>%
  kbl(.,
      format = "latex",
      caption = "Full Sample: Correlation Table and Descriptive Statistics",
      booktabs = TRUE,
      align = c("l", rep("c", ncol(.) - 1))) %>%
  pack_rows("Study 1", 1, nrow(workerMlCor)) %>%
  pack_rows("Study 2", nrow(workerMlCor) + 1,
            sum(nrow(workerMlCor), nrow(studentMlCor))) %>%
  pack_rows("Study 3", sum(nrow(workerMlCor), nrow(studentMlCor)) + 1,  
            sum(nrow(workerMlCor), nrow(studentMlCor), nrow(medicalMlCor))) %>%
  pack_rows("Across Studies", sum(nrow(workerMlCor), nrow(studentMlCor), nrow(medicalMlCor)) + 1,  
            sum(nrow(workerMlCor), nrow(studentMlCor), nrow(medicalMlCor), nrow(allMlCor))) %>%
  gsub("\\hspace{1em}Grand Mean", "\\addlinespace\n\\hspace{1em}Grand Mean", ., fixed = TRUE) %>% # fix table position
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/descrFullLong.tex")
```

```{r descrFullWide, include=FALSE}
# Full Sample Descriptives Table [wider format (descriptives next to correlation)]
rbind(
  workerMlCor %>%
    t %>%
    as.data.frame %>%
    rownames_to_column(., "Variable") %>%
    add_column(Allport = "",
               .before = "Grand Mean"),
  studentMlCor %>%
    select(names(workerMlCor)) %>%
    t %>%
    as.data.frame %>%
    rownames_to_column(., "Variable") %>%
    add_column(Allport = "",
               .before = "Grand Mean"),
  medicalMlCor %>%
    select(names(workerMlCor), "Allport") %>%
    t %>%
    as.data.frame %>%
    rownames_to_column(., "Variable"),
  allMlCor %>%
    select(names(workerMlCor)) %>%
    t %>%
    as.data.frame %>%
    rownames_to_column(., "Variable") %>%
    add_column(Allport = "",
               .before = "Grand Mean")
) %>%
  kbl(.,
      format = "latex",
      caption = "Full Sample: Correlation Table and Descriptive Statistics",
      booktabs = TRUE,
      align = c("l", rep("c", ncol(.) - 1)))  %>%
  kable_classic() %>%
  add_header_above(
    .,
    c(
      "",
      "Correlations" = ncol(medicalMlCor),
      "Descriptives" = nrow(medicalMlCor) - ncol(medicalMlCor)
    )
  ) %>%
  pack_rows("Study 1", 1, ncol(workerMlCor)) %>%
  pack_rows("Study 2", ncol(workerMlCor) + 1,
            sum(ncol(workerMlCor), ncol(studentMlCor))) %>%
  pack_rows("Study 3", sum(ncol(workerMlCor), ncol(studentMlCor)) + 1,  
            sum(ncol(workerMlCor), ncol(studentMlCor), ncol(medicalMlCor))) %>%
  pack_rows("Across Studies", sum(ncol(workerMlCor), ncol(studentMlCor), ncol(medicalMlCor)) + 1,  
            sum(ncol(workerMlCor), ncol(studentMlCor), ncol(medicalMlCor), ncol(allMlCor))) %>% # fix table position
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/descrFullWide.tex")
```

```{r descrOutLong, include=FALSE}
#
#       OLD!!
#

# Outgroup Interaction Sample Descriptives Table
rbind(
  workerOutMlCor %>%
    rownames_to_column(., "Variable") %>%
    mutate(Allport = ""),
  studentOutMlCor %>%
    select(names(workerOutMlCor)) %>%
    rownames_to_column(., "Variable") %>%
    mutate(Allport = ""),
  medicalOutMlCor %>%
    select(names(workerOutMlCor), "Allport") %>%
    rownames_to_column(., "Variable")
) %>%
  kbl(.,
      format = "latex",
      caption = "Intergroup Contact Sample: Correlation Table and Descriptive Statistics",
      booktabs = TRUE,
      align = c("l", rep("c", ncol(.) - 1))) %>%
  pack_rows("Study 1", 1, nrow(workerOutMlCor)) %>%
  pack_rows("Study 2", nrow(workerOutMlCor) + 1,
            sum(nrow(workerOutMlCor), nrow(studentOutMlCor))) %>%
  pack_rows("Study 3", sum(nrow(workerOutMlCor), nrow(studentOutMlCor)) + 1,  
            sum(nrow(workerOutMlCor), nrow(studentOutMlCor), nrow(medicalOutMlCor))) %>%
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  gsub("\\hspace{1em}Grand Mean", "\\addlinespace\n\\hspace{1em}Grand Mean", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/descrOutLong.tex")
```


```{r descrOutWide, include=FALSE}
allOutMlCor <-
  MlCorMat(
    data = dtAll$mlAll %>% filter(OutgroupInteraction == "Yes"),
    id = "ID",
    selection = c("KeyNeedFullfillment", "Competence", "Autonomy", "Relatedness", "qualityOverall", "AttitudesDutch"),
    labels = c("Core Need", "Competence", "Autonomy", "Relatedness", "Quality", "Attitudes NL")
  )

# Outgroup Interaction Sample Descriptives Table --- wider version
rbind(
  workerOutMlCor %>%
    t %>%
    as.data.frame %>%
    rownames_to_column(., "Variable") %>%
    add_column(Allport = "",
               .before = "Grand Mean"),
  studentOutMlCor %>%
    select(names(workerOutMlCor)) %>%
    t %>%
    as.data.frame %>%
    rownames_to_column(., "Variable") %>%
    add_column(Allport = "",
               .before = "Grand Mean"),
  medicalOutMlCor %>%
    select(names(workerOutMlCor), "Allport") %>%
    t %>%
    as.data.frame %>%
    rownames_to_column(., "Variable"),
  allOutMlCor %>%
    select(names(workerOutMlCor)) %>%
    t %>%
    as.data.frame %>%
    rownames_to_column(., "Variable") %>%
    add_column(Allport = "",
               .before = "Grand Mean")
) %>%
  kbl(.,
      format = "latex",
      caption = "Intergroup Contact Sample: Correlation Table and Descriptive Statistics",
      booktabs = TRUE,
      align = c("l", rep("c", ncol(.) - 1))) %>%
  kable_classic() %>%
  add_header_above(
    .,
    c(
      "",
      "Correlations" = ncol(medicalMlCor),
      "Descriptives" = nrow(medicalMlCor) - ncol(medicalMlCor)
    )
  ) %>%
  pack_rows("Study 1", 1, ncol(workerOutMlCor)) %>%
  pack_rows("Study 2", ncol(workerOutMlCor) + 1,
            sum(ncol(workerOutMlCor), ncol(studentOutMlCor))) %>%
  pack_rows("Study 3", sum(ncol(workerOutMlCor), ncol(studentOutMlCor)) + 1,  
            sum(ncol(workerOutMlCor), ncol(studentOutMlCor), ncol(medicalOutMlCor))) %>% 
  pack_rows("Across Studies", sum(ncol(workerOutMlCor), ncol(studentOutMlCor), ncol(medicalOutMlCor)) + 1,  
            sum(ncol(workerOutMlCor), ncol(studentOutMlCor), ncol(medicalOutMlCor), ncol(allOutMlCor))) %>% 
  footnote(
    general = c(
      "Upper triangle: Between-person correlations;",
      "Lower triangle: Within-person correlations;",
      "*** p < .001, ** p < .01,  * p < .05"
    )
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/descrOutWide.tex")

```




<!-- FIGURES: -->

```{r metaGeneralLm, include=FALSE}
mdlTblElementsGeneralLm <- list(mdlWorker$lmAttFreqQualX,
                                mdlStudent$lmAttFreqQualX,
                                mdlMedical$lmAttFreqQualX)

lmMetaTbl <- data.frame()
for (i in 1:length(mdlTblElementsGeneralLm)){
  lmTblTmp <- lmTblPrep(mdlTblElementsGeneralLm[[i]])$coeficients %>%
  select(
    coef,
    B = est,
    se,
    lwr,
    upr,
    tval,
    Rsq
  ) %>%
  mutate(
    n = lmTblPrep(mdlTblElementsGeneralLm[[i]])$fit$N,
    m = nrow(.)-1, 
    sample = str_match(lmTblPrep(mdlTblElementsGeneralLm[[i]])$fit$data, "dt(.*?)Supp")[2],
    coef = gsub(":", ".", coef)
  )
  lmMetaTbl <- rbind(lmMetaTbl, lmTblTmp)
}

lmMetaTbl <- lmMetaTbl %>% arrange(coef)

# extract parameter names
  name <- "Contact Hypothesis — Aggregate Linear Regression"
  var <- as.character(unique(lmMetaTbl$coef))[!as.character(unique(lmMetaTbl$coef)) %in% c("(Intercept)")]
  names <- qdap::mgsub(c("SumContactNL", "AvQuality", "SumContactNL.AvQuality"),
                       c("Number of Outgroup Contacts","Average Interaction Quality", "Contact X Quality"), 
                       var)
  studies <- as.character(unique(lmMetaTbl$sample))
  
### Parametric Meta-Analysis
    meta.parametric <- list()
    meta.parametric.sum <- data.frame(effect = var, 
                                      name = names, 
                                      beta.Worker = NA, 
                                      lwr.Worker = NA, 
                                      upr.Worker = NA, 
                                      CI.Worker = NA,
                                      beta.Student = NA, 
                                      lwr.Student = NA, 
                                      upr.Student = NA, 
                                      CI.Student = NA,
                                      beta.Medical = NA,
                                      lwr.Medical = NA,
                                      upr.Medical = NA,
                                      CI.Medical = NA, 
                                      RE.beta = NA,
                                      lwr.RE = NA,
                                      upr.RE = NA,
                                      RE.CI = NA,
                                      RE.pval = NA,
                                      RE.star = NA)

# i = 1
for(i in 1:length(var)){
      md <- escalc(data = lmMetaTbl[lmMetaTbl$coef==var[i],],
                   measure = "SPCOR",
                   ti = tval,
                   ni = n,
                   mi = m,
                   r2i = Rsq,
                   var.names = c(paste(var[i],".yi",sep=""),paste(var[i],".vi",sep="")))
      
      meta.parametric[[var[i]]] <- rma(yi = get(paste(var[i],".yi",sep="")),
                                       vi = get(paste(var[i],".vi",sep="")), 
                                       data = md, 
                                       method = "REML", #"FE", 
                                       slab = sample)
      #metafor::forest(meta.parametric[[var[i]]],
      #                main = paste("Meta Analysis ",names[i],sep = ""))
      
      meta.parametric.sum$effect[i] <- var[i]
      meta.parametric.sum$beta.Worker[i] <- meta.parametric[[var[i]]]$yi[1]
      meta.parametric.sum$beta.Student[i] <- meta.parametric[[var[i]]]$yi[2]
      meta.parametric.sum$beta.Medical[i] <- meta.parametric[[var[i]]]$yi[3]
      
      meta.parametric.sum$lwr.Worker[i] <- meta.parametric[[var[i]]]$yi[1]-1.96*sqrt(meta.parametric[[var[i]]]$vi[1])
      meta.parametric.sum$lwr.Student[i] <- meta.parametric[[var[i]]]$yi[2]-1.96*sqrt(meta.parametric[[var[i]]]$vi[2])
      meta.parametric.sum$lwr.Medical[i] <- meta.parametric[[var[i]]]$yi[3]-1.96*sqrt(meta.parametric[[var[i]]]$vi[3])
      
      meta.parametric.sum$upr.Worker[i] <- meta.parametric[[var[i]]]$yi[1]+1.96*sqrt(meta.parametric[[var[i]]]$vi[1])
      meta.parametric.sum$upr.Student[i] <- meta.parametric[[var[i]]]$yi[2]+1.96*sqrt(meta.parametric[[var[i]]]$vi[2])
      meta.parametric.sum$upr.Medical[i] <- meta.parametric[[var[i]]]$yi[3]+1.96*sqrt(meta.parametric[[var[i]]]$vi[3])
      
      meta.parametric.sum$CI.Worker[i] <- paste("[", sprintf("%0.2f", round(meta.parametric[[var[i]]]$yi[1]-1.96*sqrt(meta.parametric[[var[i]]]$vi[1]),2)),", ", sprintf("%0.2f", round(meta.parametric[[var[i]]]$yi[1]+1.96*sqrt(meta.parametric[[var[i]]]$vi[1]),2)),"]",sep="")
      meta.parametric.sum$CI.Student[i] <- paste("[", sprintf("%0.2f", round(meta.parametric[[var[i]]]$yi[2]-1.96*sqrt(meta.parametric[[var[i]]]$vi[2]),2)),", ", sprintf("%0.2f", round(meta.parametric[[var[i]]]$yi[2]+1.96*sqrt(meta.parametric[[var[i]]]$vi[2]),2)),"]",sep="")
      meta.parametric.sum$CI.Medical[i] <- paste("[", sprintf("%0.2f", round(meta.parametric[[var[i]]]$yi[3]-1.96*sqrt(meta.parametric[[var[i]]]$vi[3]),2)),", ", sprintf("%0.2f", round(meta.parametric[[var[i]]]$yi[3]+1.96*sqrt(meta.parametric[[var[i]]]$vi[3]),2)),"]",sep="")
      
      meta.parametric.sum$RE.beta[i] <- meta.parametric[[var[i]]]$b
      meta.parametric.sum$lwr.RE[i] <- meta.parametric[[var[i]]]$ci.lb
      meta.parametric.sum$upr.RE[i] <- meta.parametric[[var[i]]]$ci.ub
      meta.parametric.sum$RE.CI[i] <- paste("[",
                                            round(meta.parametric[[var[i]]]$ci.lb, 2),
                                            ", ", round(meta.parametric[[var[i]]]$ci.ub,2),"]", sep="")
      meta.parametric.sum$RE.pval[i] <- meta.parametric[[var[i]]]$pval
      meta.parametric.sum$RE.star[i] <- ifelse(meta.parametric.sum$RE.pval[i]<0.001,"***",ifelse(meta.parametric.sum$RE.pval[i]<0.01,"**",ifelse(meta.parametric.sum$RE.pval[i]<0.05,"*","")))
      
}
    #meta.parametric
    
    meta.parametric.plt.data <- meta.parametric.sum
    
    meta.parametric.sum <- meta.parametric.sum %>%
      select(-starts_with("lwr"),
             -starts_with("upr"))
    
    eff <- escalc(data = lmMetaTbl, 
                  slab = coef,
                  measure = "SPCOR",
                  ti = tval,
                  ni = n,
                  mi = m,
                  r2i = Rsq)  %>%
    mutate(effLwr = yi - 1.96 * sqrt(vi),
           effUpr = yi + 1.96 * sqrt(vi),
           effCI = paste("[", format(round(effLwr, 2), nsmall = 2), ", ", format(round(effUpr, 2), nsmall = 2), "]", sep = ""),
           name = strLabFix(coef),
           study = strStudyFix(sample))
    
    meta <- rma(yi = yi,
                vi = vi, 
                data = eff, 
                method = "REML", #"FE", 
                slab = paste(coef, sample, sep=" - "))

    k <- length(var) * length(studies)
    png(file = "Figures/forestParametricGeneralLmOld.png", height = 200 + 40*k^.85) 
      metafor::forest(meta, xlim=c(-2, 2), cex=0.75, ylim=c(-1, 20), rows=c(22:20,16:14,10:8,4:2), 
                      slab = rep(c("Study 1","Study 2", "Study 3"),length(studies)+1),
                      mlab="", main=paste0("Meta Analysis: Forest Plot [Parametric] \n(",name,")")) # , xlab = "Standardized Beta"
      par(font=2)
      text(-2.05, c(17,11,5), cex=0.75, pos=4, names)
      m=1
      for(i in 3:1){
        addpoly(meta.parametric[[i]], row=m, cex=0.75, mlab="► Fixed Effect")
        m <- m+6
      }
      text(-2.05, 19, "Predictors by study",  cex=.8, pos=4)
      text(2, 19, "Semi-Partial Correlation [95% CI]", cex=.8, pos=2)
    dev.off()
    
    meta.parametric.plt.data <- data.table(meta.parametric.plt.data) %>% 
        mutate(
          beta.RE = RE.beta,
          CI.RE = RE.CI,
          pval.RE = RE.pval,
          star.RE = RE.star
        ) %>%
      select(-starts_with("RE."))
    
  library(splitstackshape)
    meta.parametric.plt.longdata <-
      merged.stack(
        meta.parametric.plt.data,
        var.stubs = c("beta", "lwr", "upr", "CI", "pval", "star"),
        sep = "."
      ) %>%
      rename(sample = .time_1) %>%
      mutate(sample = gsub('Worker', 'Study 1',
                      gsub('Student', 'Study 2',
                      gsub('Medical', 'Study 3', sample)
                           ))) %>%
    arrange(match(effect, c("SumContactNL", "AvQuality", "SumContactNL.AvQuality")), 
            match(sample, c("Study 1", "Study 2", "Study 3", "RE")))
  
    alpha <- 0.05
    
  meta.parametric.plt.longdata2 <- meta.parametric.plt.longdata %>%
    mutate(
      index = as.integer(sapply(seq(from = 2, by=6, length.out = 3), seq, length.out=4)),
      vi = ((upr - lwr)/(2 * qnorm(alpha/2, lower.tail = FALSE)))^2,
      wi = 1/sqrt(vi),
      psize = wi/sum(wi, na.rm = TRUE),
      psize2 = (psize - min(psize, na.rm = TRUE))/(max(psize, na.rm = TRUE) - min(psize, na.rm = TRUE)),
      psize3 = (psize2 * 1) + 0.5
    )
  
  polyDat <- data.frame(
    y = c(
      meta.parametric.plt.longdata2$index[meta.parametric.plt.longdata2$sample == "RE"],
      meta.parametric.plt.longdata2$index[meta.parametric.plt.longdata2$sample == "RE"] - .25,
      meta.parametric.plt.longdata2$index[meta.parametric.plt.longdata2$sample == "RE"],
      meta.parametric.plt.longdata2$index[meta.parametric.plt.longdata2$sample == "RE"] + .25
    ),
    x = c(
      meta.parametric.plt.longdata2$lwr[meta.parametric.plt.longdata2$sample == "RE"],
      meta.parametric.plt.longdata2$beta[meta.parametric.plt.longdata2$sample == "RE"],
      meta.parametric.plt.longdata2$upr[meta.parametric.plt.longdata2$sample == "RE"],
      meta.parametric.plt.longdata2$beta[meta.parametric.plt.longdata2$sample == "RE"]
    ),
    lab = rep(paste("RE", 1:3), 4)
  )
  
  lab <- lapply(unique(meta.parametric.plt.longdata2$name), append, c(unique(meta.parametric.plt.longdata2$sample), "")) %>% unlist 
          
  plot1 <- ggplot() +
    geom_point(
      data = meta.parametric.plt.longdata2[sample != "RE",],
      aes(y = index, x = beta),
      shape = 15,
      size = meta.parametric.plt.longdata2[sample != "RE", psize3] * 3
    ) +
    geom_errorbarh(data = meta.parametric.plt.longdata2[sample != "RE",],
                   aes(y = index, xmin = lwr, xmax = upr),
                   height = 0.25) +
    geom_polygon(data = polyDat, 
                 mapping = aes(x = x, y = y, group = lab)) +
    geom_vline(
      xintercept = 0,
      color = "black",
      linetype = "dashed",
      cex = 0.5,
      alpha = 1
    ) +
    scale_y_continuous(
      name = "",
      expand  = expansion(add = 1),
      breaks = seq(lab),
      labels = lab,
      trans = "reverse"
    ) +
    scale_x_continuous(
      limits = c(-1, 1),
      breaks = seq(-1, 1, 0.5),
      expand = c(0, 0)
    ) +
    xlab("Semi-Partial Correlation (95% CI)") +
    ggtitle("Predictors by Study") +
    theme_Publication() +
    theme(
      plot.title = element_text(hjust = 0, size=12, face = "bold"),
      plot.title.position = "plot",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.line.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.text.y = element_text(size = 12, colour = "black", hjust=0, face = rep(c("bold", rep("plain", 5)),3)),
      axis.line.x = element_line(colour = "black"),
      axis.text.x.bottom = element_text(size = 12, colour = "black"),
      axis.title.x = element_text(size = 12, colour = "black")
    )

## Estiamte and CI table
  tab1 <- ggplot(meta.parametric.plt.longdata2, aes(y = lab)) +
    ylab(NULL) + xlab("  ") +
    labs(title = "space") +
    geom_text(aes(
      y = rev(index),
      x = 1,
      label = paste(sprintf("%0.2f", round(beta, digits = 2)), CI)
    ),
    size = 4,
    hjust = 1) + 
    scale_x_continuous(
      limits = c(-1, 1)
    ) +
    ggtitle("Estimate [95% CI]") +
    theme_Publication() +
    theme(
      plot.title = element_text(hjust = 1, size = 12),
      axis.line = element_blank(),
      axis.text.x = element_text(color = "white"),
      axis.text.y = element_blank(),
      axis.ticks = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "none",
      panel.background = element_blank(),
      panel.border = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      plot.background = element_blank()
    )
  
grid.arrange(plot1, tab1, layout_matrix = matrix(c(1,1,1,2), nrow = 1))

png(file = "Figures/forestParametricGeneralLm.png", width = 700) 
  grid.arrange(plot1, tab1, layout_matrix = matrix(c(1,1,1,2), nrow = 1))
dev.off()


### Bootstrapped Meta-Analysis
    var.boot <- var
    names.boot <- names
    meta.bootstrapped <- list()
    meta.bootstrapped.sum <- data.frame(effect = var.boot, 
                                      name = names.boot, 
                                      beta.Worker = NA, 
                                      CI.Worker = NA,
                                      beta.Student = NA, 
                                      CI.Student = NA,
                                      beta.Medical = NA,
                                      CI.Medical = NA, 
                                      RE.beta = NA,
                                      RE.CI = NA,
                                      RE.pval = NA,
                                      RE.star = NA)
    
    # i = 3
    for(i in 1:length(var.boot)){
      md <- escalc(data = lmMetaTbl[lmMetaTbl$coef==var.boot[i],],
                   measure = "SPCOR",
                   yi = B,
                   sei = se,
                   ni = n,
                   mi = m,
                   var.names = c(paste(var.boot[i],".yi",sep=""),paste(var.boot[i],".vi",sep="")))
      
      meta.bootstrapped[[var.boot[i]]] <- rma(yi = get(paste(var.boot[i],".yi",sep="")),
                                              vi = get(paste(var.boot[i],".vi",sep="")),
                                              data = md,
                                              method =  "REML", #"FE", 
                                              slab = sample)
      #metafor::forest(meta.bootstrapped[[var.boot[i]]],
      #                main = paste("Meta Analysis ",names.boot[i],sep = ""))
      meta.bootstrapped.sum$effect[i] <- var[i]
      meta.bootstrapped.sum$beta.Worker[i] <-
        meta.bootstrapped[[var[i]]]$yi[1]
      meta.bootstrapped.sum$beta.Student[i] <-
        meta.bootstrapped[[var[i]]]$yi[2]
      meta.bootstrapped.sum$beta.Medical[i] <-
        meta.bootstrapped[[var[i]]]$yi[3]
      meta.bootstrapped.sum$CI.Worker[i] <-
        paste(
          "[",
          round(meta.bootstrapped[[var[i]]]$yi[1] -
                  1.96 * sqrt(meta.bootstrapped[[var[i]]]$vi[1]), 2),
          ", ",
          round(meta.bootstrapped[[var[i]]]$yi[1] + 1.96 * sqrt(meta.bootstrapped[[var[i]]]$vi[1]), 2),
          "]",
          sep = ""
        )
      meta.bootstrapped.sum$CI.Student[i] <-
        paste(
          "[",
          round(meta.bootstrapped[[var[i]]]$yi[2] -
                  1.96 * sqrt(meta.bootstrapped[[var[i]]]$vi[2]), 2),
          ", ",
          round(meta.bootstrapped[[var[i]]]$yi[2] + 1.96 * sqrt(meta.bootstrapped[[var[i]]]$vi[2]), 2),
          "]",
          sep = ""
        )
      meta.bootstrapped.sum$CI.Medical[i] <-
        paste(
          "[",
          round(meta.bootstrapped[[var[i]]]$yi[3] -
                  1.96 * sqrt(meta.bootstrapped[[var[i]]]$vi[3]), 2),
          ", ",
          round(meta.bootstrapped[[var[i]]]$yi[3] + 1.96 * sqrt(meta.bootstrapped[[var[i]]]$vi[3]), 2),
          "]",
          sep = ""
        )
      meta.bootstrapped.sum$RE.beta[i] <- meta.bootstrapped[[var[i]]]$b
      meta.bootstrapped.sum$RE.CI[i] <- paste(
        "[",
        round(meta.bootstrapped[[var[i]]]$ci.lb, 2),
        ", ",
        round(meta.bootstrapped[[var[i]]]$ci.ub, 2),
        "]",
        sep = ""
      )
      meta.bootstrapped.sum$RE.pval[i] <- meta.bootstrapped[[var[i]]]$pval
      meta.bootstrapped.sum$RE.star[i] <-
        ifelse(
          meta.bootstrapped.sum$RE.pval[i] < 0.001,
          "***",
          ifelse(
            meta.bootstrapped.sum$RE.pval[i] < 0.01,
            "**",
            ifelse(meta.bootstrapped.sum$RE.pval[i] < 0.05, "*", "")
          )
        )
    }
    #meta.bootstrapped
    
    eff.boot <- escalc(data = lmMetaTbl %>% filter(coef != "(Intercept)"), 
                       slab = coef,
                       measure = "SPCOR",
                       yi = B,
                       sei = se,
                       ni = n,
                       mi = m)
    meta.boot <- rma(yi = yi,
                     vi = vi, 
                     data = eff.boot, 
                     method = "REML", #"FE", 
                     slab = paste(coef, sample, sep=" - "))

    k <- 3*3
    png(file = "Figures/forestBootstrappedGeneralLm.png", height = 200 + 40*k^.85)
      metafor::forest(meta.boot, cex=0.75, xlim=c(-2, 2.5), ylim=c(-1, 20), rows=c(16:14,10:8,4:2), 
                      slab = rep(c("Study 1","Study 2", "Study 3"),length(studies)),
                      mlab="", main=paste0("Meta Analysis: Forest Plot [Bootstrapped] \n(",name,")")) # , xlab = "Standardized Beta")
      par(font=2)
      text(-2.05, c(17,11,5), cex=0.75, pos=4, names)
      m=1
      for(i in 3:1){
        addpoly(meta.bootstrapped[[i]], row=m, cex=0.75, mlab="► Fixed Effect")
        m <- m+6
      }
      text(-2.05, 19, "Predictors by study",  cex=.8, pos=4)
      text(2.5, 19, "Semi-Partial Correlation [95% CI]", cex=.8, pos=2)
    dev.off()    
```

```{r metaGeneralLmer, include=FALSE}
mdlTblElementsGeneralLmer <- list(
  c(mdlWorker$lmerInterceptAttTypeTbl, mdlWorker$lmerInterceptAttTypeTblZ),
  c(mdlStudent$lmerSlopesAttType, mdlStudent$lmerSlopesAttTypeZ),
  c(mdlMedical$lmerSlopesAttType, mdlMedical$lmerSlopesAttTypeZ)
  )

# i =1
GeneralLmerMetaTbl <- data.frame()
for (i in 1:length(mdlTblElementsGeneralLmer)){
  lmerTblTmp <- lmerTblPrep(mdlTblElementsGeneralLmer[[i]][[1]], mdlTblElementsGeneralLmer[[i]][[2]])$beta %>%
  select(
    coef,
    B = est,
    se,
    lwr,
    upr,
    tval,
    Rsq
  ) %>%
  mutate(
    n = lmerTblPrep(mdlTblElementsGeneralLmer[[i]][[1]], mdlTblElementsGeneralLmer[[i]][[2]])$fit$N,
    m = nrow(.), 
    sample = str_match(lmerTblPrep(mdlTblElementsGeneralLmer[[i]][[1]], mdlTblElementsGeneralLmer[[i]][[2]])$fit$data, "dt(.*?)Supp")[2],
    coef = gsub(":", ".", coef)
  )
  GeneralLmerMetaTbl <- rbind(GeneralLmerMetaTbl, lmerTblTmp)
}

GeneralLmerMetaTbl <- GeneralLmerMetaTbl %>% arrange(coef)
     
GeneralLmerMeta <- metaLmerOut(GeneralLmerMetaTbl,
                               type = "REML", #"FE", 
                               name = "GeneralLmer",
                               title = "Contact Hypothesis — Mixed Effects Regression")

      
```

```{generalForestPltComb, include=FALSE}
effGeneral <- rbind(
  eff %>%
    filter(coef != "(Intercept)") %>%
    mutate(analysis = "(A) Aggregate Linear Regression",
           metaId = paste(coef, analysis, sep = ".")) %>%
    as.data.frame,
  GeneralLmerMeta$eff %>%
    mutate(analysis = "(B) Mixed Effects Regression",
           metaId = paste(coef, analysis, sep = ".")) %>%
    as.data.frame
)

metaSubForest(effGeneral, 
              title = "Meta Analysis: Forest Plot Contact Hypothesis \n[Parametric]",
              filename = "GeneralLmer",
              type = "REML",
              addAbove = 5,
              width = 600,
              height = 600)
```

```{r metaTheory, include=FALSE}
mdlTblElementsTheoryLmer <- list(
  # Study 1:
  c(tblLmerS1QltInterceptCore, tblLmerS1QltInterceptCoreZ),
  c(tblLmerS1AttSlopeCore, tblLmerS1AttSlopeCoreZ),
  c(tblLmerS1AttSlopeCoreQlt, tblLmerS1AttSlopeCoreQltZ),
  # Study 2:
  c(tblLmerS2QltSlopesCore, tblLmerS2QltSlopesCoreZ),
  c(tblLmerS2AttSlopesCore, tblLmerS2AttSlopesCoreZ),
  c(tblLmerS2AttSlopesCoreQlt, tblLmerS2AttSlopesCoreQltZ),
  # Study 3:
  c(tblLmerS3QltSlopesCore, tblLmerS3QltSlopesCoreZ),
  c(tblLmerS3AttSlopesCore, tblLmerS3AttSlopesCoreZ),
  c(tblLmerS3AttSlopesCoreQlt, tblLmerS3AttSlopesCoreQltZ),
  c(tblLmerS3QltSlopesAllport, tblLmerS3QltSlopesAllportZ),
  c(tblLmerS3AttSlopesAllport, tblLmerS3AttSlopesAllportZ),
  c(tblLmerS3AttSlopesAllportQlt, tblLmerS3AttSlopesAllportQltZ),
  c(tblLmerS3AttSlopesAllportCore, tblLmerS3AttSlopesAllportCoreZ)
  )

# i =1
theoryMetaTbl <- data.frame()
for (i in 1:length(mdlTblElementsTheoryLmer)){
  lmerTblTmp <- lmerTblPrep(mdlTblElementsTheoryLmer[[i]][[1]], mdlTblElementsTheoryLmer[[i]][[2]])$beta %>%
  select(
    coef,
    B = est,
    se,
    lwr,
    upr,
    tval,
    Rsq
  ) %>%
  mutate(
    n = lmerTblPrep(mdlTblElementsTheoryLmer[[i]][[1]], mdlTblElementsTheoryLmer[[i]][[2]])$fit$N,
    m = nrow(.), 
    dv = gsub("Raw", "", str_extract(lmerTblPrep(mdlTblElementsTheoryLmer[[i]][[1]], mdlTblElementsTheoryLmer[[i]][[2]])$fit$formula,".+?(?= ~)")),
    sample = gsub("S", "Study", str_extract(lmerTblPrep(mdlTblElementsTheoryLmer[[i]][[1]], mdlTblElementsTheoryLmer[[i]][[2]])$fit$data, "S1|S2|S3")),
    formula = lmerTblPrep(mdlTblElementsTheoryLmer[[i]][[1]], mdlTblElementsTheoryLmer[[i]][[2]])$fit$formula,
    coef = gsub(":", ".", coef)
  )
  theoryMetaTbl <- rbind(theoryMetaTbl, lmerTblTmp)
}

theoryMetaTblNoAllport <- theoryMetaTbl %>%
  filter(!grepl("Allport",formula)) %>% 
  mutate(formula = gsub(" \\+ \\(.*", "", formula)) %>%
  arrange(formula, coef, sample)

TheoryMetaQualityNeed <-
  metaLmerOut(
    lmerDataTbl = theoryMetaTblNoAllport %>% filter(formula == "QualityRaw ~ CoreNeed"),
    type = "REML", #"FE", 
    name = "TheoryQualityCore",
    title = "Quality ~ CoreNeed"
  )

TheoryMetaAttitudeNeed <-
  metaLmerOut(
    lmerDataTbl = theoryMetaTblNoAllport %>% filter(formula == "Attitude ~ CoreNeed"),
    type = "REML", #"FE", 
    name = "TheoryAttitudeCore",
    title = "Attitude ~ CoreNeed"
  )

TheoryMetaAttitudeNeedQuality <-
  metaLmerOut(
    lmerDataTbl = theoryMetaTblNoAllport %>% filter(formula == "Attitude ~ CoreNeed + Quality"),
    type = "REML", #"FE", 
    name = "TheoryAttitudeCoreQuality",
    title = "Attitude ~ CoreNeed + Quality"
  )
```

```{theoryForestPltComb, include=FALSE}
effTheory <- rbind(
  TheoryMetaQualityNeed$eff %>%
    filter(coef != "(Intercept)") %>%
    mutate(analysis = "(A) Quality ~ Core Need",
           metaId = paste(coef, analysis, sep = ".")) %>%
    as.data.frame,
  TheoryMetaAttitudeNeed$eff %>%
    mutate(analysis = "(B) Attitude ~ Core Need",
           metaId = paste(coef, analysis, sep = ".")) %>%
    as.data.frame,
  TheoryMetaAttitudeNeedQuality$eff %>%
    mutate(analysis = "(C) Attitude ~ Core Need + Quality",
           metaId = paste(coef, analysis, sep = ".")) %>%
    as.data.frame
)

metaSubForest(effTheory, 
              title = "Meta Analysis: Forest Plot Core Need Fulfillment \n[Parametric]",
              filename = "TheoryComb",
              addAbove = 5,
              type = "REML",
              width = 600,
              height = 600)
```

```{r metaRobust, include=FALSE}
mdlRobustTblElements <- list(
  # full
  c(mdlWorkerLmerSlopesAttCoreInt, mdlWorkerLmerSlopesAttCoreIntZ),
  c(mdlStudentLmerSlopesAttCoreInt, mdlStudentLmerSlopesAttCoreIntZ),
  c(mdlMedicalLmerSlopesAttCoreInt, mdlMedicalLmerSlopesAttCoreIntZ),
  # outgroup
  c(mdlWorkerOutLmerSlopesCoreSdt, mdlWorkerOutLmerSlopesCoreSdtZ),
  c(mdlStudentOutLmerSlopesCoreSdt, mdlStudentOutLmerSlopesCoreSdtZ),
  c(mdlMedicalOutLmerSlopesCoreSdt, mdlMedicalOutLmerSlopesCoreSdtZ)
  )

# i =1
robustMetaTbl <- data.frame()
for (i in 1:length(mdlRobustTblElements)){
  lmerTblTmp <- lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$beta %>%
  select(
    coef,
    B = est,
    se,
    lwr,
    upr,
    tval,
    Rsq
  ) %>%
  mutate(
    n = lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$N,
    m = nrow(.), 
    #dv = gsub("Dutch", "", str_extract(lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$formula,".+?(?= ~)")),
    sample = str_match(lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$data, "Tbl(.*?)(Full|Out)")[2],
    formula = lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$formula,
    coef = gsub(":", ".", coef)
  )
  robustMetaTbl <- rbind(robustMetaTbl, lmerTblTmp)
}

robustMetaTbl <- robustMetaTbl %>%
  arrange(formula, match(
    coef,
    c(
      "CoreNeed_zwc",
      "OutgroupInteraction_zwc",
      "CoreNeed_zwc.OutgroupInteraction_zwc",
      "Autonomy_zwc",
      "Competence_zwc",
      "Relatedness_zwc"
    )
  )) %>% 
  mutate(formula = gsub(" \\+ \\(.*", "", formula))

robustMetaContact <-
  metaLmerOut(
    lmerDataTbl = robustMetaTbl %>% filter(formula == "AttitudesDutch ~ CoreNeed_cwc * OutgroupInteraction"),
    type = "REML", #"FE", 
    name = "RobustContact",
    title = "Robustness — Contact and Need Fulfillment"
  )

robustMetaSDT <-
  metaLmerOut(
    lmerDataTbl = robustMetaTbl %>% filter(formula == "AttitudesDutch ~ CoreNeed_cwc + Competence_cwc + Autonomy_cwc +      Relatedness_cwc"),
    type = "REML", #"FE", 
    name = "RobustSDT",
    title = "Robustness — Other Needs"
  )
```

```{r robustForestPltComb, include=FALSE}
effRobust <- rbind(
  robustMetaContact$eff %>%
    filter(coef != "(Intercept)") %>%
    mutate(analysis = "(A) Attitude ~ Contact and Need Fulfillment",
           metaId = paste(coef, analysis, sep = ".")) %>%
    as.data.frame,
  robustMetaSDT$eff %>%
    mutate(analysis = "(B) Attitude ~ Other Needs",
           metaId = paste(coef, analysis, sep = ".")) %>%
    as.data.frame
)

metaSubForest(effRobust, 
              title = "Meta Analysis: Forest Plot Robustness Analysis \n[Parametric]",
              filename = "RobustnessComb",
              addAbove = 5,
              width = 600,
              height = 800)
```


```{r Export Path Models, include=FALSE}
save(shortMdlPath, 
     file = "data/theoryMdlTabl.RData")
```

```{r OsfExport, include=FALSE}
# export individual minimal CSV files 
# STUDY 1:
write.csv(
  dtWorkerSupp$workerInteractionType %>%
    select(
      "PID",
      "keyMotiveFulfilled",
      "competence.daily.all",
      "autonomy.daily.all",
      "relatedness.daily.all",
      "thermometerDutch_1",
      "keymotive_fulfillemt_1",
      "competence_1",
      "autonomy_1",
      "relatedness_1",
      "quality_overall_1",
      "OutgroupInteraction",
      "NonOutgroupInteraction"
    ),
  file = "OSF Files/Data/Study1_minimal.csv"
)

#STUDY 2:
write.csv(
  dtStudentSupp$studentInteractionType %>%
    select(
      "PID",
      "TIDnum",
      "KeyNeedFullfillment",
      "Competence",
      "Autonomy",
      "Relatedness",
      "AttitudesDutch",
      "quality_overall",
      "OutgroupInteraction",
      "NonOutgroupInteraction"
    ),
  file = "OSF Files/Data/Study2_minimal.csv"
)

# STUDY 3:
write.csv(
  dtMedicalSupp$medicalWithinBetween %>%
    select(
      "PID",
      "TIDnum",
      "OutgroupInteraction",
      "NonOutgroupInteraction",
      "AttitudesDutch",
      "qualityOverall",
      "AllportsCondition",
      "KeyNeedFulfillment",
      "Competence",
      "Autonomy",
      "Relatedness"
    ),
  file = "OSF Files/Data/Study3_minimal.csv"
)


# export joint minimal data as RData file 
# create environment for joint export
osfExport <- new.env()

# STUDY 1:
osfExport$dtWorkerSupp$workerInteractionType <- dtWorkerSupp$workerInteractionType %>%
  select(
    "PID",
    "keyMotiveFulfilled",
    "competence.daily.all",
    "autonomy.daily.all",
    "relatedness.daily.all",
    "thermometerDutch_1",
    "keymotive_fulfillemt_1",
    "competence_1",
    "autonomy_1",
    "relatedness_1", 
     "quality_overall_1", 
    "OutgroupInteraction",
    "NonOutgroupInteraction"
  )

osfExport$dtWorker$full <- dtWorker$full %>%
  select(
    "PID",
    "thermometerDutch_1"
  )

osfExport$dtWorkerSupp$workerAvFreQual <- dtWorkerSupp$workerAvFreQual


#STUDY 2:
osfExport$dtStudentSupp$studentInteractionType <- dtStudentSupp$studentInteractionType %>%
  select(
    "PID",
    "TIDnum", 
    "KeyNeedFullfillment",
    "Competence",
    "Autonomy",
    "Relatedness",
    "AttitudesDutch",
    "quality_overall",
    "OutgroupInteraction",
    "NonOutgroupInteraction"
  )

osfExport$dtStudents$full <- dtStudents$full %>%
  select(
    "PID",
    "AttitudesDutch"
  )

osfExport$dtStudentSupp$studentOutgroupInteraction <- dtStudentSupp$studentOutgroupInteraction %>%
  select(
    "PID",
    "AttitudesDutch"
  )

osfExport$dtStudentSupp$studentContactFreq <- dtStudentSupp$studentContactFreq

osfExport$dtStudentSupp$studentPltIDs <- dtStudentSupp$studentPltIDs

osfExport$dtStudentSupp$studentOutPltIDs <- dtStudentSupp$studentOutPltIDs


# STUDY 3:
osfExport$dtMedicalSupp$medicalWithinBetween <- dtMedicalSupp$medicalWithinBetween %>%
  select(
    "PID",
    "TIDnum",
    "OutgroupInteraction",
    "OutgroupInteraction_cwc",
    "OutgroupInteraction_zwc",
    "NonOutgroupInteraction",
    "NonOutgroupInteraction_cwc",
    "NonOutgroupInteraction_zwc",
    "AttitudesDutch",
    "AttitudesDutch_cwc",
    "AttitudesDutch_zwc",
    "qualityOverall",
    "qualityOverall_cwc",
    "qualityOverall_zwc",
    "AllportsCondition",
    "AllportsCondition_cwc",
    "AllportsCondition_zwc",
    "KeyNeedFulfillment",
    "KeyNeedFulfillment_cwc",
    "KeyNeedFulfillment_zwc",
    "Competence",
    "Competence_cwc",
    "Competence_zwc",
    "Autonomy",
    "Autonomy_cwc", 
    "Autonomy_zwc", 
    "Relatedness",
    "Relatedness_cwc",
    "Relatedness_zwc"
  )

osfExport$dtMedicalSupp$medicalOutWithinBetween <- dtMedicalSupp$medicalOutWithinBetween %>%
  select(
    "PID",
    "TIDnum",
    "AttitudesDutch",
    "AttitudesDutch_cwc",
    "AttitudesDutch_zwc",
    "qualityOverall",
    "qualityOverall_cwc",
    "qualityOverall_zwc",
    "AllportsCondition",
    "AllportsCondition_cwc",
    "AllportsCondition_zwc",
    "KeyNeedFulfillment",
    "KeyNeedFulfillment_cwc",
    "KeyNeedFulfillment_zwc",
    "Competence",
    "Competence_cwc",
    "Competence_zwc",
    "Autonomy",
    "Autonomy_cwc", 
    "Autonomy_zwc", 
    "Relatedness",
    "Relatedness_cwc",
    "Relatedness_zwc"
  )

osfExport$dtMedical$full <- dtMedical$full %>% 
  select(
    "PID",
    "TIDnum",
    "AttitudesDutch",
    "OutgroupInteraction", 
    "NonOutgroupInteraction",
    "KeyNeedFulfillment",
    "KeyNeedFulfillment_cwc",
    "Competence",
    "Autonomy", 
    "Relatedness", 
    "AllportsCondition", 
    "qualityOverall"
  )

osfExport$dtMedicalSupp$medicalContactFreq <- dtMedicalSupp$medicalContactFreq

osfExport$dtMedicalSupp$medicalPltIDs <- dtMedicalSupp$medicalPltIDs

osfExport$dtMedicalSupp$medicalOutPltIDs <- dtMedicalSupp$medicalOutPltIDs


# Export all relevant data for OSF
save(list = ls(osfExport),
     envir = osfExport,
     file = "OSF Files/Data/wrangled.RData")
```
