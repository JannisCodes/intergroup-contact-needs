---
output: latex_fragment
editor_options:
  chunk_output_type: console
bibliography: references.bib
csl: apa.csl
---

```{r}
#| label: setup
#| include: false

# R Studio Clean-Up
cat("\014") # clear console
# rm(list=ls()) # clear workspace - use restart R instead [cmd/alt + shift + F10]
gc() # garbage collector

# Install and Load Packages
# !IMPORTANT!
# BEFORE FIRST RENDER:
# To install all relevant packages please run "renv::restore()" (or renv::init() and then initiate from lockfile) in the console before the first use to ensure that all packages are using the correct version.
# to store the packages in a contained library within the project folder: renv::settings$use.cache(FALSE) and add 'RENV_CONFIG_SANDBOX_ENABLED = FALSE' to an '.Renviron' file
lib <- c(
  "rmarkdown",
  "knitr",
  "berryFunctions",
  "remedy",
  "bookdown",
  "brms",
  "psych",
  "ggplot2",
  "ggthemes",
  "purrr",
  "haven",
  "RColorBrewer",
  "plotly",
  "gridExtra",
  "ggpattern",
  "lme4",
  "nlme",
  "jtools",
  "gtsummary",
  "sessioninfo",
  "tibble",
  "pander",
  "devtools",
  "mada",
  "data.table",
  "plyr",
  "dplyr",
  "tidyr",
  "Hmisc",
  "kableExtra",
  "papaja",
  "stringr",
  "stringi",
  "reshape2",
  "lubridate",
  "misty",
  "sjPlot",
  "sjmisc",
  "metafor"
)
invisible(lapply(lib, library, character.only = TRUE))
rm(lib)

# Load Custom Packages
source("./scripts/functions/fun.panel.R")
source("./scripts/functions/themes.R")
source("./scripts/functions/binaryCor.R")
source("./scripts/functions/MlCorMat.R")
source("./scripts/functions/MlTbl.R")
source("./scripts/functions/metaLmer.R")

# Markdown Options
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # set working directory
knitr::opts_knit$get("root.dir") # check working directory
options(
  scipen = 999,
  digits = 4,
  width = 400
) # removes scientific quotation
# knitr::opts_chunk$set(echo = TRUE, cache = F, cache.path = rprojroot::find_rstudio_root_file('cache/')) # cache settings

# Global Chunk Options
knitr::opts_chunk$set(
  fig.width = 12,
  fig.height = 8,
  fig.path = "Figures/",
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)
```

```{r}
#| label: import
#| include: false

load("data/wrangled.RData")
# remove accidental surplus to avoid conflicts
# rm(list = ls(pattern = "mdl|medicalSdtComp"))
```

As with the main analyses, full surveys are available in our OSF repository \citep{KreienkampMasked2022a} and the full data description is available in Online Supplementary Material A. Correlations and descriptive statistics of the included variables are available in \tblref{tab:descrFullWide} and \tblref{tab:descrOutWide}.

\subsection{Additional Materials}

In addition to the measurement of whether or not participants had an intergroup interaction and their situational core need fulfillment, we also included a number of variables that allowed us to assess the robustness of our results.  

\subsubsection{Specific Psychological Needs} In addition to the intergroup contact dummy and situational core need reported in the main text, we included a common measure of three self-determination theory needs \citep[see][]{Downie2008}. The measurement was identical in all three studies. The items were introduced either by “\textit{During the interaction:}” or “\textit{This morning [/afternoon]:}” and measured autonomy (“\textit{I was myself.}”), competence (“\textit{I felt competent.}”), and relatedness (without intergroup contact “\textit{I had a strong need to belong}”; with intergroup contact: “\textit{I shared information about myself.}” and “\textit{The other(s) shared information about themselves.}”). All items were rated on a continuous slider scale from very little (-50) to a great deal (+50).

\subsubsection{Interaction Intend} To assess whether an interaction was accidental (vs. planned), we asked participants with a single item to report the extend to which "The interaction with -X- was accidental". The respondents were asked to report this context variable for all interactions they reported on using a continuous slider ranging from "not at all" (0), through "very little" (33) and "somewhat" (66), to "a great deal" (100). In all studies the scale showed a right skew (\textit{mean} = `r format(round(mean(dt_goal_directedness$InteractionAccidental, na.rm = TRUE), 2), nsmall = 2)`, \textit{sd} = `r format(round(sd(dt_goal_directedness$InteractionAccidental, na.rm = TRUE), 2), nsmall = 2)`).

\subsubsection{Goal-directedness}
```{r}
#| label: goal_directedness_descr
#| include: false

kappa.full <- function(x, name, ...){
  xtab <- table(x)
  diagonal.counts <- diag(xtab)
  N <- sum(xtab)
  row.marginal.props <- rowSums(xtab)/N
  col.marginal.props <- colSums(xtab)/N
  # Compute kappa (k)
  Po <- sum(diagonal.counts)/N
  Pe <- sum(row.marginal.props*col.marginal.props)
  k <- (Po - Pe)/(1 - Pe)
  se <- sqrt((Po*(1-Po))/(N*(1-Pe)^2)) # according to PMID: 23092060
  lwr <- k-1.96*se
  upr <- k+1.96*se
  
  data.frame(name,Po,Pe,k,se,lwr,upr)
}

irr_practical <- dt_topic_coding %>%
  select(practical_need_01, 
         practical_need_02) %>%
  kappa.full(., "practical_need")

irr_practical_dum <- dt_topic_coding %>%
  transmute(
    practical_need_01_dum = ifelse(practical_need_01 == 2, 1, practical_need_01), 
    practical_need_02_dum = ifelse(practical_need_02 == 2, 1, practical_need_02)
  ) %>%
  kappa.full(., "practical_need_dum")
  

irr_psychological <- dt_topic_coding %>%
  select(psychological_need_01, 
         psychological_need_02) %>%
  kappa.full(., "psychological_need")

irr_psychological_dum <- dt_topic_coding %>%
  transmute(
    practical_need_01_dum = ifelse(psychological_need_01 == 2, 1, psychological_need_01), 
    practical_need_02_dum = ifelse(psychological_need_02 == 2, 1, psychological_need_02)
  ) %>%
  kappa.full(., "psychological_need_dum")

irr <- rbind(
  irr_practical,
  irr_practical_dum,
  irr_psychological, 
  irr_psychological_dum
)

dt_topic_coding %>%
  transmute(
    practical_need_dum = ifelse(practical_need == 2, 1, practical_need), 
    psychological_need_dum = ifelse(psychological_need == 2, 1, psychological_need)
  )

lab_mapping <- c("no need", "need")
goal_directedness_dist <- dt_goal_directedness %>%
  transmute(
    practical_need_dum = ifelse(practical_need == 2, 1, practical_need), 
    psychological_need_dum = ifelse(psychological_need == 2, 1, psychological_need)
  ) %>% 
  mutate(
    practical_need_label = lab_mapping[match(practical_need_dum, c(0, 1))],
    psychological_need_label = lab_mapping[match(psychological_need_dum, c(0, 1))]
  ) %>%
  group_by(
    practical_need_dum,
    practical_need_label,
    psychological_need_dum,
    psychological_need_label
  ) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  na.omit %>%
  mutate(
    perc = count/sum(count)*100
  )

ggplot(
  goal_directedness_dist,
  aes (
    x = reorder(practical_need_label, practical_need_dum),
    y = reorder(psychological_need_label, psychological_need_dum),
    fill = count,
    label = paste0(format(round(perc, 2), nsmall = 2), "%")
  )) +
  geom_tile() +
  geom_text(col = "white") +
  labs(x = "Practical Motive",
       y = "Psychological Motive",
       title = "Goal Directedness Coding") +
  theme(legend.key.size = unit(0.75, "cm"))
```
To assess whether the need content (i.e., the motives) would impact the effect of the need fulfillment experiences, we manually coded the topics we extracted during the topic modeling on two dimensions of how much they reflect a practical and a psychological goal-directedness. We chose practical and psychological needs specifically as our dimensions to account for differences in the types of needs that participants commonly reported. With practical motives we refer to specific, tangible goals or tasks that participants aimed to accomplish during the interaction. These instrumental goals are usually observable, concrete, and often centered on external outcomes, such as acquiring resources, completing tasks, and addressing immediate challenges \citep[][]{}. With psychological motives we refer to underlying motives or desires that are more abstract and relate to personal fulfillment and well-being. In contrast to practical needs, psychological needs delve into the subjective and internal aspects of human experiences. These needs pertain to emotions, social connections, and cognitive processes, reflecting individuals' quest for personal growth, well-being, and thriving in social relationships \citep[][]{}. Note that with this approach any particular motive can include a practical and/or a psychological goal-directedness but can also be classified as not having any goal at all. The full coding protocol we developed with examples for each of the codes is available in our Online Supplemental Material D. After an initial training, each of the two coders independently coded the 47 topics on the two dimensions, using one of three options each (i.e., 0 = no goal, 1 = vague goal, 2 = clear goal). Inter-rater reliability assessments showed that for both the practical as well as the psychological needs, agreement was not optimal using the three answer options (agreement practical = `r irr$Po[irr$name == "practical_need"] %>% round(2) %>% format(nsmall = 2)`\%, agreement psychological = `r irr$Po[irr$name == "psychological_need"] %>% round(2) %>% format(nsmall = 2)`\%). However, most disagreements were, if a need was present, whether that need was vague (1) or concrete (2). We, thus, collapsed these two categories making the ratings binary (need absent vs. need present). With the simpler coding, inter-rater agreement for practical needs (`r irr$Po[irr$name == "practical_need_dum"] %>% round(2) %>% format(nsmall = 2)`\%) and the psychological need (`r irr$Po[irr$name == "psychological_need_dum"] %>% round(2) %>% format(nsmall = 2)`\%) were much more reliable. Using Cohen’s $\kappa$ as our measure of inter-rater reliability, we find that both the practical need coding (\textit{Cohen's} $\kappa$ = `r irr$k[irr$name == "practical_need_dum"] %>% round(2) %>% format(nsmall = 2)`, 95\%CI[`r irr$lwr[irr$name == "practical_need_dum"] %>% round(2) %>% format(nsmall = 2)`, `r ifelse(irr$upr[irr$name == "practical_need_dum"]>1, 1 %>% round(2) %>% format(nsmall = 2), irr$upr[irr$name == "practical_need_dum"] %>% round(2) %>% format(nsmall = 2))`]) as well as the psychological need coding (\textit{Cohen's} $\kappa$ = `r irr$k[irr$name == "psychological_need_dum"] %>% round(2) %>% format(nsmall = 2)`, 95\%CI[`r irr$lwr[irr$name == "psychological_need_dum"] %>% round(2) %>% format(nsmall = 2)`, `r ifelse(irr$upr[irr$name == "psychological_need_dum"]>1, 1 %>% round(2) %>% format(nsmall = 2), irr$upr[irr$name == "psychological_need_dum"] %>% round(2) %>% format(nsmall = 2))`]) were very good. We thus proceeded with this collapsed coding. After resolving coder disagreements and merging the codings back to the free-text responses, we found that a majority of responses showed both a practical as well as a psychological need (`r goal_directedness_dist$perc[goal_directedness_dist$practical_need_dum==1 & goal_directedness_dist$psychological_need_dum==1] %>% round(2) %>% format(nsmall=2)`\%) and only few responses had no goal at all (`r goal_directedness_dist$perc[goal_directedness_dist$practical_need_dum==0 & goal_directedness_dist$psychological_need_dum==0] %>% round(2) %>% format(nsmall=2)`\%) with the remaining `r goal_directedness_dist$perc[goal_directedness_dist$practical_need_dum+goal_directedness_dist$psychological_need_dum==1] %>% sum %>% round(2) %>% format(nsmall=2)`\% having either a practical or a psychological need only (see Online Supplemental Material A for more detailed tables and visualizations).

\subsubsection{Well-being} We measured experienced well-being using a visual analog scale adapted from \citet{davies2022}. Participants were asked to respond to the the question "How do you feel right now?" using a continuous visual slider ranging from "very sad"(-100) to "very happy" (100). The well-being ratings were generally normally distributed (\textit{mean} = `r format(round(mean(dt_goal_directedness$WellBeing, na.rm = TRUE), 2), nsmall = 2)`, \textit{sd} = `r format(round(sd(dt_goal_directedness$WellBeing, na.rm = TRUE), 2), nsmall = 2)`).

\subsection{Results}

To build further confidence in our results, we assessed a number of additional models that might offer alternative explanations. We will discuss the results in sequential order --- in every case first considering the a global test of the model across the three studies and only then assessing whether the global three-level regression model suppresses any important person-level variations within the studies.

\subsubsection{Contact specific}

```{r}
#| label: contact_overall
#| include: false

dt_exp_all <- dt_exp_all %>%
  mutate(
    OutgroupInteraction = (OutgroupInteraction-1.5)
  )

contact_overall <- select_best_lmer_model(
  data = dt_exp_all,
  prediction_form = "CoreNeed * OutgroupInteraction",
  structure = "study/PID",
  dependent_var = "Attitude",
  lmer_scale = TRUE
)

# contact_overall$anova
# contact_overall$choice
# contact_overall$lmer_model %>% summ(., confint = TRUE, digits = 3)
# contact_overall$lmer_model %>% summ(., confint = TRUE, digits = 3, scale = TRUE)

# interactions::sim_slopes(mdl_contact$lmerAttSlopeOverall, pred = CoreNeedC, modx = OutgroupInteraction, jnplot = TRUE)
# interactions::interact_plot(contact_overall$lmer_model, pred = CoreNeed, modx = OutgroupInteraction, interval = TRUE)
```

We begin our robustness analysis by testing whether the effect of core need fulfillment is specific to an actual outgroup contact, rather than need fulfillment in general. For this, we analyzed the generalized situational core need fulfillment (either during a contact or about the daytime in general) and tested whether the effect differed during experience sampling measurements with and without outgroup contacts. We start this test by assessing the effect across all three studies, using a three-level hierarchical model, where measurements are nested within participants, and participants are nested within studies. In this overall model, we found no main effect of core need fulfillment (random slopes model, grand-mean standardized to account for all levels of variance; `r get_latex_coef(contact_overall$lmer_coef, "CoreNeed")`) but a significant interaction effect of core need fulfillment and outgroup contact (`r get_latex_coef(contact_overall$lmer_coef, "CoreNeed:OutgroupInteraction")`; also see \tblref{tab:robustnessTblLong} and \fgrref{fig:Robustness}). While the three-level hierarchical model can be sensitive to scaling issues, this already indicates that it is not key need fulfillment in general --- but only key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. 

```{r}
#| label: contact_s1
#| include: false

contact_s1 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 1),
  prediction_form = "CoreNeedC * OutgroupInteraction",
  structure = "PID",
  dependent_var = "Attitude"
)
# contact_s1$anova
# contact_s1$choice
# contact_s1$lmer_model %>% summ(., confint = TRUE, digits = 3)
# contact_s1$lmer_model_z %>% summ(., confint = TRUE, digits = 3)

# interactions::sim_slopes(mdl_contact$lmerAttSlopeOverall, pred = CoreNeedC, modx = OutgroupInteraction, jnplot = TRUE)
# interactions::interact_plot(contact_s1$lmer_model, pred = CoreNeedC, modx = OutgroupInteraction, interval = TRUE)
```

```{r}
#| label: contact_s2
#| include: false

contact_s2 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 2),
  prediction_form = "CoreNeedC * OutgroupInteraction",
  structure = "PID",
  dependent_var = "Attitude"
)
# contact_s2$anova
# contact_s2$choice
# contact_s2$lmer_model %>% summ(., confint = TRUE, digits = 3)
# contact_s2$lmer_model_z %>% summ(., confint = TRUE, digits = 3)

# interactions::sim_slopes(mdl_contact$lmerAttSlopeOverall, pred = CoreNeedC, modx = OutgroupInteraction, jnplot = TRUE)
# interactions::interact_plot(contact_s2$lmer_model, pred = CoreNeedC, modx = OutgroupInteraction, interval = TRUE)
```

```{r}
#| label: contact_s3
#| include: false

contact_s3 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 3),
  prediction_form = "CoreNeedC * OutgroupInteraction",
  structure = "PID",
  dependent_var = "Attitude"
)
# contact_s3$anova
# contact_s3$choice
# contact_s3$lmer_model %>% summ(., confint = TRUE, digits = 3)
# contact_s3$lmer_model_z %>% summ(., confint = TRUE, digits = 3)

# interactions::sim_slopes(mdl_contact$lmerAttSlopeOverall, pred = CoreNeedC, modx = OutgroupInteraction, jnplot = TRUE)
# interactions::interact_plot(contact_s3$lmer_model, pred = CoreNeedC, modx = OutgroupInteraction, interval = TRUE)
```

```{r}
#| label: contact_study_coef
#| include: false

contact_study_coef <- 
  rbind(
    contact_s1$lmer_coef %>% mutate(study = 1),
    contact_s2$lmer_coef %>% mutate(study = 2),
    contact_s3$lmer_coef %>% mutate(study = 3)
  )
```

To ensure that the results are not affected by scaling issues (e.g., study-level variances suppressing person-level variances) or a similar Simpson's paradox, we additionally assess the model within each of the three studies. Within each of the three studies, the effects are more pronounced, so that we also see a significant effect of core need fulfillemnt (all \textit{b} > `r min(abs(contact_study_coef[contact_study_coef$coef == "CoreNeedC", "b"])) %>% round(2) %>% format(nsmall=2)`, all \textit{p} < `r max(contact_study_coef[contact_study_coef$coef == "CoreNeedC", "p"]) %>% round(3) %>% format(nsmall=3)`) as well as outgroup contact itself (all |\textit{b}| > `r min(abs(contact_study_coef[contact_study_coef$coef == "OutgroupInteraction", "b"])) %>% round(2) %>% format(nsmall=2)`, all \textit{p} < `r max(contact_study_coef[contact_study_coef$coef == "OutgroupInteraction", "p"]) %>% round(3) %>% format(nsmall=3)`) but the interaction effect consistently remains the most reliable predictor of outgroup attitudes (all |\textit{b}| > `r min(abs(contact_study_coef[contact_study_coef$coef == "CoreNeedC:OutgroupInteraction", "b"])) %>% round(2) %>% format(nsmall=2)`, all \textit{p} < `r max(contact_study_coef[contact_study_coef$coef == "CoreNeedC:OutgroupInteraction", "p"]) %>% round(3) %>% format(nsmall=3)`, also see \tblref{tab:robustnessTblLong} and \fgrref{fig:Robustness}). There is thus consistent evidence that need fulfillment relates to outgroup attitudes for outgroup contacts in particular but not need fulfillment in general. 


\subsubsection{Interaction intend}

```{r}
#| label: accidental_overall
#| include: false

accidental_overall <- select_best_lmer_model(
  data = dt_exp_all %>% filter(OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeed * InteractionAccidental",
  structure = "study/PID",
  dependent_var = "Attitude",
  lmer_scale = TRUE
)
# accidental_overall$anova
# accidental_overall$choice
# accidental_overall$lmer_model %>% summ(., confint = TRUE, digits = 3)
# accidental_overall$lmer_model %>% summ(., confint = TRUE, digits = 3, scale = TRUE)
```

Secondly, to assess whether the need fulfillment mechanism affected by whether the interaction was accidental or planned we ran an exploratory moderation analysis using the participants' ratings of how much they perceived the interaction as 'accidental'. It should be noted that we asked our participants to focus on most the important interaction (i.e., "\textit{The following questions will be about the interaction \underline{you consider most significant}.}"''"; emphasis as in original). We again start our analysis approach by assessing the model across all three studies, using a three-level hierarchical model. In this overall model, we retain the main effect of core need fulfillment (random slopes model, grand-mean standardized to account for all levels of variance; `r get_latex_coef(accidental_overall$lmer_coef, "CoreNeed")`) but neither contact intend nor the moderation effect affect the results (all |\textit{b}| < `r max(abs(accidental_overall$lmer_coef[accidental_overall$lmer_coef$coef != c("(Intercept)", "CoreNeed"), "b"])) %>% round(2) %>% format(nsmall=2)` and all \textit{p} > `r min(accidental_overall$lmer_coef[accidental_overall$lmer_coef$coef != c("(Intercept)", "CoreNeed"), "p"]) %>% round(3) %>% format(nsmall=3)`; see \tblref{tab:robustnessTblLong} for full results). 

```{r}
#| label: accidental_s1
#| include: false

accidental_s1 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 1, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC * InteractionAccidentalC",
  structure = "PID",
  dependent_var = "Attitude"
)
# accidental_s1$anova
# accidental_s1$choice
# accidental_s1$lmer_model %>% summ(., confint = TRUE, digits = 3)
# accidental_s1$lmer_model_z %>% summ(., confint = TRUE, digits = 3)

# interactions::sim_slopes(accidental_s1$lmer_model, pred = CoreNeedC, modx = InteractionAccidentalC, jnplot = TRUE)
# interactions::interact_plot(accidental_s1$lmer_model, pred = CoreNeedC, modx = InteractionAccidentalC, interval = TRUE)
```

```{r}
#| label: accidental_s2
#| include: false

accidental_s2 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 2, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC * InteractionAccidentalC",
  structure = "PID",
  dependent_var = "Attitude",
  return = "slope"
)
# accidental_s2$anova
# accidental_s2$choice
# accidental_s2$lmer_model %>% summ(., confint = TRUE, digits = 3)
# accidental_s2$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
# 
# interactions::sim_slopes(accidental_s2$lmer_model, pred = CoreNeedC, modx = InteractionAccidentalC, jnplot = TRUE)
# interactions::interact_plot(accidental_s2$lmer_model, pred = CoreNeedC, modx = InteractionAccidentalC, interval = TRUE)
```

```{r}
#| label: accidental_s3
#| include: false

accidental_s3 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 3, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC * InteractionAccidentalC",
  structure = "PID",
  dependent_var = "Attitude"
)
# accidental_s3$anova
# accidental_s3$choice
# accidental_s3$lmer_model %>% summ(., confint = TRUE, digits = 3)
# accidental_s3$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
# 
# interactions::sim_slopes(accidental_s3$lmer_model, pred = CoreNeedC, modx = InteractionAccidentalC, jnplot = TRUE)
# interactions::interact_plot(accidental_s3$lmer_model, pred = CoreNeedC, modx = InteractionAccidentalC, interval = TRUE)
```

```{r}
#| label: accidental_study_coef
#| include: false

accidental_study_coef <- 
  rbind(
    accidental_s1$lmer_coef %>% mutate(study = 1),
    accidental_s2$lmer_coef %>% mutate(study = 2),
    accidental_s3$lmer_coef %>% mutate(study = 3)
  )
```

We again sought to ensure that the results were not affected by scaling issues by additionally assessing the interaction intentionality model within each of the three studies. Within each of the three studies, the effect of core need fulfillemnt became even clearer (all |\textit{b}| > `r min(abs(accidental_study_coef[accidental_study_coef$coef == "CoreNeedC", "b"])) %>% round(2) %>% format(nsmall=2)`, all \textit{p} < `r ifelse(max(accidental_study_coef[accidental_study_coef$coef == "CoreNeedC", "p"]) %>% round(3) %>% format(nsmall=3)<.001, ".001", max(accidental_study_coef[accidental_study_coef$coef == "CoreNeedC", "p"]) %>% round(3) %>% format(nsmall=3))`). But in none of the studies neither outgroup contact intention nor the moderation effect explained a significant amount of variance in outgroup attitudes (all |\textit{b}| < `r max(abs(accidental_study_coef[accidental_study_coef$coef != c("(Intercept)", "CoreNeedC"), "b"])) %>% round(2) %>% format(nsmall=2)` and all \textit{p} > `r min(accidental_study_coef[accidental_study_coef$coef != c("(Intercept)", "CoreNeedC"), "p"]) %>% round(3) %>% format(nsmall=3)`; also see \tblref{tab:robustnessTblLong}). There is thus consistent evidence that need fulfillment is related to outgroup attitudes, even when taking the intentionality of the interaction into account --- at least in our three samples and with a focus on the most significant interactions.


\subsubsection{Well-being outcome}

```{r}
#| label: wellbeing_core_overall
#| include: false

wellbeing_core_overall <- select_best_lmer_model(
  data = dt_exp_all %>% filter(OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeed",
  structure = "study/PID",
  dependent_var = "WellBeing",
  lmer_scale = TRUE
)
# wellbeing_core_overall$anova
# wellbeing_core_overall$choice
# wellbeing_core_overall$lmer_model %>% summ(., confint = TRUE, digits = 3)
# wellbeing_core_overall$lmer_model %>% summ(., confint = TRUE, digits = 3, scale = TRUE)
```

```{r}
#| label: wellbeing_full_overall
#| include: false

wellbeing_full_overall <- select_best_lmer_model(
  data = dt_exp_all %>% filter(OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeed + Quality",
  structure = "study/PID",
  dependent_var = "WellBeing",
  lmer_scale = TRUE
)
# wellbeing_full_overall$anova
# wellbeing_full_overall$choice
# wellbeing_full_overall$lmer_model %>% summ(., confint = TRUE, digits = 3)
# wellbeing_full_overall$lmer_model %>% summ(., confint = TRUE, digits = 3, scale = TRUE)
```


```{r}
#| label: wellbeing_core_s1
#| include: false

wellbeing_core_s1 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 1, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC",
  structure = "PID",
  dependent_var = "WellBeing"
)
# wellbeing_core_s1$anova
# wellbeing_core_s1$choice
# wellbeing_core_s1$lmer_model %>% summ(., confint = TRUE, digits = 3)
# wellbeing_core_s1$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```

```{r}
#| label: wellbeing_full_s1
#| include: false

wellbeing_full_s1 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 1, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC + QualityC",
  structure = "PID",
  dependent_var = "WellBeing"
)
# wellbeing_full_s1$anova
# wellbeing_full_s1$choice
# wellbeing_full_s1$lmer_model %>% summ(., confint = TRUE, digits = 3)
# wellbeing_full_s1$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```


```{r}
#| label: wellbeing_core_s2
#| include: false

wellbeing_core_s2 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 2, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC",
  structure = "PID",
  dependent_var = "WellBeing"
)
# wellbeing_core_s2$anova
# wellbeing_core_s2$choice
# wellbeing_core_s2$lmer_model %>% summ(., confint = TRUE, digits = 3)
# wellbeing_core_s2$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```

```{r}
#| label: wellbeing_full_s2
#| include: false

wellbeing_full_s2 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 2, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC + QualityC",
  structure = "PID",
  dependent_var = "WellBeing"
)
# wellbeing_full_s2$anova
# wellbeing_full_s2$choice
# wellbeing_full_s2$lmer_model %>% summ(., confint = TRUE, digits = 3)
# wellbeing_full_s2$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```


```{r}
#| label: wellbeing_core_s3
#| include: false

wellbeing_core_s3 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 3, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC",
  structure = "PID",
  dependent_var = "WellBeing"
)
# wellbeing_core_s3$anova
# wellbeing_core_s3$choice
# wellbeing_core_s3$lmer_model %>% summ(., confint = TRUE, digits = 3)
# wellbeing_core_s3$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```

```{r}
#| label: wellbeing_full_s3
#| include: false

wellbeing_full_s3 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 3, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC + QualityC",
  structure = "PID",
  dependent_var = "WellBeing"
)
# wellbeing_full_s3$anova
# wellbeing_full_s3$choice
# wellbeing_full_s3$lmer_model %>% summ(., confint = TRUE, digits = 3)
# wellbeing_full_s3$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```

```{r}
#| label: wellbeing_core_study_coef
#| include: false

wellbeing_core_study_coef <- 
  rbind(
    wellbeing_core_s1$lmer_coef %>% mutate(study = 1),
    wellbeing_core_s2$lmer_coef %>% mutate(study = 2),
    wellbeing_core_s3$lmer_coef %>% mutate(study = 3)
  )
```

Thirdly, to build a stronger case for the relevance of need fulfillment to minority group members, we exploratorily assessed the effect of need fulfilling outgroup interactions on self-reported well-being. We, thus, re-ran our main analysis but substituted the outgroup attitudes outcome with situational well-being. As with the previous robustness analyses, we begin with a global three-level hierarchical model (across the three studies). We find that need fulfillment during outgroup contacts, indeed, has a similar effect on experienced well-being (random slopes model, grand-mean standardized to account for all levels of variance; `r get_latex_coef(wellbeing_core_overall$lmer_coef, "CoreNeed")`). We found the same result when we assessed each of the three studies individually. In each of the studies situational need fulfillment during the outgroup interaction was related with higher well-being ratings by the participants (random slopes model, centered within participants; all |\textit{b}| > `r min(abs(wellbeing_core_study_coef[wellbeing_core_study_coef$coef == "CoreNeedC", "b"])) %>% round(2) %>% format(nsmall=2)`, all \textit{p} < `r ifelse(max(wellbeing_core_study_coef[wellbeing_core_study_coef$coef == "CoreNeedC", "p"]) %>% round(3) %>% format(nsmall=3)<.001, ".001", max(wellbeing_core_study_coef[wellbeing_core_study_coef$coef == "CoreNeedC", "p"]) %>% round(3) %>% format(nsmall=3))`). We, thus, find consistent and meaningful evidence that need fulfilling outgroup interactions also relate to higher everyday well-being. 

\subsubsection{Need types}

\paragraph{overall}
```{r}
#| label: need_type_overall
#| include: false

need_type_overall <- select_best_lmer_model(
  data = dt_goal_directedness,
  prediction_form = "CoreNeed * practical_need_dum + CoreNeed * psychological_need_dum",
  structure = "study/PID",
  dependent_var = "Attitude",
  lmer_scale = TRUE
)
# need_type_overall$anova
# need_type_overall$choice
# need_type_overall$lmer_model %>% summ(., confint = TRUE, digits = 3)
# need_type_overall$lmer_model %>% summ(., confint = TRUE, digits = 3, scale = TRUE)
```

Fourthly, to assess the role of different types of motives reported by our participants, we added our coding of practical and psychological goal-directedness as additional predictors to our base model. We thus had core need fulfillment predicting outgroup attitudes while also accounting for whether the reported motives were capturing practical and/or psychological motives. We again ran a global model, across the three studies first. We found that core need fulfillment remain a core predictor of outgroup attitudes (random slopes model, grand-mean standardized to account for all levels of variance; `r get_latex_coef(need_type_overall$lmer_coef, "CoreNeed")`), even after accounting for different types of motives. None of the motive types nor the moderation effects reached statistical significance within the overall analysis (all |\textit{b}| < `r max(abs(need_type_overall$lmer_coef[need_type_overall$lmer_coef$coef != c("(Intercept)", "CoreNeed"), "b"])) %>% round(2) %>% format(nsmall=2)` and all \textit{p} > `r min(need_type_overall$lmer_coef[need_type_overall$lmer_coef$coef != c("(Intercept)", "CoreNeed"), "p"]) %>% round(3) %>% format(nsmall=3)`; see \tblref{tab:robustnessTblLong} for full results). 

\paragraph{Study follow-up}
```{r}
#| label: need_type_s1
#| include: false

need_type_s1 <- select_best_lmer_model(
  data = dt_goal_directedness %>% filter(study == 1),
  prediction_form = "CoreNeedC * practical_need_dum + CoreNeedC * psychological_need_dum",
  structure = "PID",
  dependent_var = "Attitude",
  return = "slope"
)
# need_type_s1$anova
# need_type_s1$choice
# need_type_s1$lmer_model %>% summ(., confint = TRUE, digits = 3)
# need_type_s1$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```

```{r}
#| label: need_type_s2
#| include: false

need_type_s2 <- select_best_lmer_model(
  data = dt_goal_directedness %>% filter(study == 2),
  prediction_form = "CoreNeedC * practical_need_dum + CoreNeedC * psychological_need_dum",
  structure = "PID",
  dependent_var = "Attitude"
)
# need_type_s2$anova
# need_type_s2$choice
# need_type_s2$lmer_model %>% summ(., confint = TRUE, digits = 3)
# need_type_s2$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```

```{r}
#| label: need_type_s3
#| include: false

need_type_s3 <- select_best_lmer_model(
  data = dt_goal_directedness %>% filter(study == 3),
  prediction_form = "CoreNeedC * practical_need_dum + CoreNeedC * psychological_need_dum",
  structure = "PID",
  dependent_var = "Attitude"
)
# need_type_s3$anova
# need_type_s3$choice
# need_type_s3$lmer_model %>% summ(., confint = TRUE, digits = 3)
# need_type_s3$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```

```{r}
#| label: need_type_study_coef
#| include: false

need_type_study_coef <- 
  rbind(
    need_type_s1$lmer_coef %>% mutate(study = 1),
    need_type_s2$lmer_coef %>% mutate(study = 2),
    need_type_s3$lmer_coef %>% mutate(study = 3)
  )
```

When looking at the individual studies, we again saw that the effect of core need fulfillemnt remained the on only clear effect (all |\textit{b}| > `r min(abs(need_type_study_coef[need_type_study_coef$coef == "CoreNeedC", "b"])) %>% round(2) %>% format(nsmall=2)`, all \textit{p} < `r ifelse(max(need_type_study_coef[need_type_study_coef$coef == "CoreNeedC", "p"]) %>% round(3) %>% format(nsmall=3)<.001, ".001", max(need_type_study_coef[need_type_study_coef$coef == "CoreNeedC", "p"]) %>% round(3) %>% format(nsmall=3))`). Additionally, in none of the studies neither motive type dummies nor the moderation effect explained a significant amount of variance in outgroup attitudes (all |\textit{b}| < `r max(abs(need_type_study_coef[need_type_study_coef$coef != c("(Intercept)", "CoreNeedC"), "b"])) %>% round(2) %>% format(nsmall=2)` and all \textit{p} > `r min(need_type_study_coef[need_type_study_coef$coef != c("(Intercept)", "CoreNeedC"), "p"]) %>% round(3) %>% format(nsmall=3)`; also see \tblref{tab:robustnessTblLong}). We, thus, find consistent evidence that need fulfillment is related to outgroup attitudes, even when taking the type of need into account --- at least in our three samples.

\subsubsection{Specific psychological needs}

```{r}
#| label: need_sdt_overall
#| include: false

need_sdt_overall <- select_best_lmer_model(
  data = dt_exp_all %>% filter(OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeed + Competence + Autonomy + Relatednesss",
  structure = "study/PID",
  dependent_var = "Attitude",
  lmer_scale = TRUE
)
# need_sdt_overall$anova
# need_sdt_overall$choice
# need_sdt_overall$lmer_model %>% summ(., confint = TRUE, digits = 3)
# need_sdt_overall$lmer_model %>% summ(., confint = TRUE, digits = 3, scale = TRUE)
```

In a final step, we checked whether during the interaction the core situational need remains a meaningful predictor even when taking other fundamental psychological needs into account. We again take a two-step approach, starting with cross-study global three-level test and then assessing the effects within the individual studies. Within the overall model we find that across the studies core need fulfillment remained a strong predictor of outgroup attitudes, even after controlling for the three self-determination theory need (random slopes model, grand-mean standardized to account for all levels of variance; `r get_latex_coef(need_sdt_overall$lmer_coef, "CoreNeed")`). Within this overall analysis, none of the self-determination theory needs independently predicted outgroup attitudes to a statistically significant extent (all \textit{p} > `r min(need_sdt_overall$lmer_coef[need_sdt_overall$lmer_coef$coef != c("(Intercept)", "CoreNeed"), "p"]) %>% round(3) %>% format(nsmall=3)`). However, some of the effect sizes were largely comparable to that of the core need fulfillment (all |\textit{b}| < `r max(abs(need_sdt_overall$lmer_coef[need_sdt_overall$lmer_coef$coef != c("(Intercept)", "CoreNeed"), "b"])) %>% round(2) %>% format(nsmall=2)`, particularly that of relatedness fulfillment; see \tblref{tab:robustnessTblLong} for full results). 

```{r}
#| label: need_sdt_s1
#| include: false

need_sdt_s1 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 1, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC + CompetenceC + AutonomyC + RelatednesssC",
  structure = "PID",
  dependent_var = "Attitude"
)
# need_sdt_s1$anova
# need_sdt_s1$choice
# need_sdt_s1$lmer_model %>% summ(., confint = TRUE, digits = 3)
# need_sdt_s1$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```

```{r}
#| label: need_sdt_s2
#| include: false

# need_sdt_s2 <- select_best_lmer_model(
#   data = dt_exp_all %>% filter(study == 2, OutgroupInteractionLab == "Yes"),
#   prediction_form = "CoreNeedC + CompetenceC + AutonomyC + RelatednesssC",
#   structure = "PID",
#   dependent_var = "Attitude",
#   control = lmeControl(opt = "nlminb", msMaxIter = 500, tolerance = 1e-6)
# )
model0 <- lmer(
  Attitude ~ 1 + (1 | PID),
  data = dt_exp_all %>% filter(study == 2, OutgroupInteractionLab == "Yes")
)
model1 <- lmer(
  Attitude ~ CoreNeedC + CompetenceC + AutonomyC + RelatednesssC + (1 | PID),
  data = dt_exp_all %>% filter(study == 2, OutgroupInteractionLab == "Yes")
)
model2 <- lmer(
  Attitude ~ CoreNeedC + CompetenceC + AutonomyC + RelatednesssC + (1 + CoreNeedC + CompetenceC + AutonomyC + RelatednesssC | PID),
  data = dt_exp_all %>% filter(study == 2, OutgroupInteractionLab == "Yes")
)
test <- anova(model0, model1, model2)
test$`Pr(>Chisq)`[3] < 0.05
rm(model0, model1, model2, test)

need_sdt_s2 <- list()
need_sdt_s2$lmer_model <- lmer(
  Attitude ~ CoreNeedC + CompetenceC + AutonomyC + RelatednesssC + (1 | PID),
  data = dt_exp_all %>% filter(study == 2, OutgroupInteractionLab == "Yes")
)
need_sdt_s2$lmer_model_z <- lmer(
  AttitudeZ ~ CoreNeedZ + CompetenceZ + AutonomyZ + RelatednesssZ + (1 | PID),
  data = dt_exp_all %>% filter(study == 2, OutgroupInteractionLab == "Yes")
)

need_sdt_s2$lmer_model %>% summ(., confint = TRUE, digits = 3)
need_sdt_s2$lmer_model_z %>% summ(., confint = TRUE, digits = 3)

need_sdt_s2$lmer_coef <- 
    summ(need_sdt_s2$lmer_model, confint = TRUE, scale = FALSE)$coeftable %>%
    as_tibble %>%
    transmute(
      coef = rownames(summ(need_sdt_s2$lmer_model)$coeftable),
      b = Est.,
      df = d.f.,
      t = `t val.`,
      p = p,
      lwr = `2.5%`,
      upr = `97.5%`,
      coef_latex = paste0(
        "\\textit{b} = ", format(round(b, 2), nsmall = 2), 
        ", \\textit{t}(", format(df, big.mark=","), ") = ", format(round(t, 2), nsmall = 2),
        ", \\textit{p} ", ifelse(p < .001, "< .001", paste0("= ", format(round(p, 3), nsmall = 3))),
        ", \\textit{95\\%CI}[",  format(round(lwr, 2), nsmall = 2), ", ",  format(round(upr, 2), nsmall = 2), "]"
      ),
      coef_html = paste0(
        "<i>b</i> = ", format(round(b, 2), nsmall = 2), 
        ", <i>t</i>(", format(df, big.mark=","), ") = ", format(round(t, 2), nsmall = 2),
        ", <i>p</i> ", ifelse(p < .001, "< .001", paste0("= ", format(round(p, 3), nsmall = 3))),
        ", <i>95%CI</i>[",  format(round(lwr, 2), nsmall = 2), ", ",  format(round(upr, 2), nsmall = 2), "]"
      )
    )
```

```{r}
#| label: need_sdt_s3
#| include: false

need_sdt_s3 <- select_best_lmer_model(
  data = dt_exp_all %>% filter(study == 3, OutgroupInteractionLab == "Yes"),
  prediction_form = "CoreNeedC + CompetenceC + AutonomyC + RelatednesssC",
  structure = "PID",
  dependent_var = "Attitude"
)
# need_sdt_s3$anova
# need_sdt_s3$choice
# need_sdt_s3$lmer_model %>% summ(., confint = TRUE, digits = 3)
# need_sdt_s3$lmer_model_z %>% summ(., confint = TRUE, digits = 3)
```

```{r}
#| label: need_sdt_study_coef
#| include: false

need_sdt_study_coef <- 
  rbind(
    need_sdt_s1$lmer_coef %>% mutate(study = 1),
    need_sdt_s2$lmer_coef %>% mutate(study = 2),
    need_sdt_s3$lmer_coef %>% mutate(study = 3)
  )

need_sdt_study_coef_other <- need_sdt_study_coef %>%
  filter(
    coef != "(Intercept)",
    coef != "CoreNeedC"
  ) 
```


When looking at the individual studies, we again saw that core need fulfillemnt remained a consistent predictor of outgroup attitudes, even after accounting for the self-determination theory need (all |\textit{b}| > `r min(abs(need_sdt_study_coef[need_sdt_study_coef$coef == "CoreNeedC", "b"])) %>% round(2) %>% format(nsmall=2)`, all \textit{p} < `r ifelse(max(need_sdt_study_coef[need_sdt_study_coef$coef == "CoreNeedC", "p"]) %>% round(3) %>% format(nsmall=3)<.001, ".001", max(need_sdt_study_coef[need_sdt_study_coef$coef == "CoreNeedC", "p"]) %>% round(3) %>% format(nsmall=3))`). However, across all three studies the fulfillment of relatedness motives also emerged as a consistent predictor of outgroup attitudes (all |\textit{b}| > `r min(abs(need_sdt_study_coef[need_sdt_study_coef$coef == "RelatednesssC", "b"])) %>% round(2) %>% format(nsmall=2)`, all \textit{p} < `r ifelse(max(need_sdt_study_coef[need_sdt_study_coef$coef == "RelatednesssC", "p"]) %>% round(3) %>% format(nsmall=3)<.001, ".001", max(need_sdt_study_coef[need_sdt_study_coef$coef == "RelatednesssC", "p"]) %>% round(3) %>% format(nsmall=3))`). Additionally, in the larger studies 2 and 3 competence fulfillment was also related to more positive outgroup attitudes (study 2: `r get_latex_coef(need_sdt_study_coef %>% filter(study == 2), "CompetenceC")`, study 3: `r get_latex_coef(need_sdt_study_coef %>% filter(study == 3), "CompetenceC")`). None of the autonomy fulfillment effects reached statistical significance nor did the competence fulfillment during study 1 (see \tblref{tab:robustnessTblLong} for the full results). In short, find that across our samples, relatedness fulfillment (and to a smaller extend competence fulfillment) are instrumental in understanding when an outgroup contact leads to more positive outgroup attitudes. Importantly, even when considering these effects situational core need fulfillment remains a strong and consistent predictor of outgroup attitudes. In some cases, we even find that core need fulfillment takes on some of the variance that would otherwise be explained by the self-determination theory needs (see Online Supplemental Material A).


<!-- TABLES -->

```{r}
#| label: robustnessTblLong
#| include: false

# collect models for table
mdlRobustTblElements <- list(
  # Contact specific
  contact_overall = c(contact_overall$lmer_model, contact_overall$lmer_model_z),
  contact_s1 = c(contact_s1$lmer_model, contact_s1$lmer_model_z),
  contact_s2 = c(contact_s2$lmer_model, contact_s2$lmer_model_z),
  contact_s3 = c(contact_s3$lmer_model, contact_s3$lmer_model_z),
  # Accidental
  accidental_overall = c(accidental_overall$lmer_model, accidental_overall$lmer_model_z),
  accidental_s1 = c(accidental_s1$lmer_model, accidental_s1$lmer_model_z),
  accidental_s2 = c(accidental_s2$lmer_model, accidental_s2$lmer_model_z),
  accidental_s3 = c(accidental_s3$lmer_model, accidental_s3$lmer_model_z),
  # well-being core
  wellbeing_core_overall = c(wellbeing_core_overall$lmer_model, wellbeing_core_overall$lmer_model_z),
  wellbeing_core_s1 = c(wellbeing_core_s1$lmer_model, wellbeing_core_s1$lmer_model_z),
  wellbeing_core_s2 = c(wellbeing_core_s2$lmer_model, wellbeing_core_s2$lmer_model_z),
  wellbeing_core_s3 = c(wellbeing_core_s3$lmer_model, wellbeing_core_s3$lmer_model_z),
  # # POTENTIALLT well-being full
  # c(wellbeing_full_overall$lmer_model, wellbeing_full_s1$lmer_model_z),
  # c(wellbeing_full_s1$lmer_model, wellbeing_full_s1$lmer_model_z),
  # c(wellbeing_full_s2$lmer_model, wellbeing_full_s2$lmer_model_z),
  # c(wellbeing_full_s3$lmer_model, wellbeing_full_s3$lmer_model_z),
  # Need type
  need_type_overall = c(need_type_overall$lmer_model, need_type_overall$lmer_model_z),
  need_type_s1 = c(need_type_s1$lmer_model, need_type_s1$lmer_model_z),
  need_type_s2 = c(need_type_s2$lmer_model, need_type_s2$lmer_model_z),
  need_type_s3 = c(need_type_s3$lmer_model, need_type_s3$lmer_model_z),
  # Need SDT
  need_sdt_overall = c(need_sdt_overall$lmer_model, need_sdt_overall$lmer_model_z),
  need_sdt_s1 = c(need_sdt_s1$lmer_model, need_sdt_s1$lmer_model_z),
  need_sdt_s2 = c(need_sdt_s2$lmer_model, need_sdt_s2$lmer_model_z),
  need_sdt_s3 = c(need_sdt_s3$lmer_model, need_sdt_s3$lmer_model_z)
  )



mdlRobustPrep <- list()
for (i in 1:length(mdlRobustTblElements)) {
  mdlRobustPrep[[names(mdlRobustTblElements)[[i]]]] <- lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]], name = names(mdlRobustTblElements)[[i]])
}

# extract important elements
shortRobustPrep <- list()
for(i in 1:length(mdlRobustPrep)){
  tmp <- rbind(
    mdlRobustPrep[[i]]$coeficients[, c("coef", "B", "Beta")],
    data.frame(
      coef = "R2Marg_R2Cond",
      B = mdlRobustPrep[[i]]$fit$R2Marg_R2Cond,
      Beta = ""
    )
  )
  shortRobustPrep[[mdlRobustPrep[[i]]$fit$name]] <- tmp
}

analyses <- unique(sub("_(?!.*_).*", "", names(mdlRobustPrep), perl = TRUE))
studies <- unique(sub(".*_(.*)", "\\1", names(mdlRobustPrep)))

robustTblLong <- list()
for (analysis in analyses) {
  mylist <- shortRobustPrep[grepl(analysis, names(shortRobustPrep))]
  mylist <- lapply(names(mylist), function(x) transform(mylist[[x]], name = x))
  df <- do.call(rbind, mylist)
  df <- melt(df, id.vars = c("coef", "name")) %>%
    mutate(
      name = as.character(sub(".*_(.*)", "\\1", name)),
      coef = as.character(sub("CoreNeedC", "CoreNeed", coef)),
      variable = as.character(variable)
    )
  df <- dcast(df, coef ~ name + variable, value.var = "value")
  robustTblLong[[analysis]] <- df
}
robustTblLong <- do.call(rbind, robustTblLong) %>% 
  rownames_to_column(var = "group") %>%
  mutate(group = factor(sub("\\.\\d+$", "", group), levels = unique(sub("\\.\\d+$", "", group))),
         contains_colon = ifelse(grepl(":", coef), 1, 0),
         special = case_when(
           coef == "(Intercept)" ~ "first",
           coef == "CoreNeed" ~ "second",
           coef == "R2Marg_R2Cond" ~ "last",
           TRUE ~ "middle"
         ),
         special = factor(special, levels = c("first", "second", "middle", "last"))) %>% 
  arrange(group, special, contains_colon, coef) %>% 
  select(-contains_colon, -special)

replacement_mapping <- c("contact" = "Contact specific",
                         "accidental" = "Interaction Intend",
                         "wellbeing_core" = "Well-being Outcome",
                         "need_type" = "Need Type",
                         "need_sdt" = "Specific Psychological Needs")

robustTblLong <- robustTblLong %>%
  mutate(
    group = case_when(
      group %in% names(replacement_mapping) ~ replacement_mapping[group],
      TRUE ~ as.character(group)
    ),
    coef = mapvalues(
      robustTblLong$coef,
      from = c("R2Marg_R2Cond"),
      to = c("$R^2_{marginal}$ / $R^2_{conditional}$")
    )
  )


mdlTblRobustLong <- 
  robustTblLong %>%
  select(-group) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    #format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    escape = FALSE,
    col.names = c("", rep(c("$B$", "$\\beta$"), (ncol(.)-1)/2))
  ) %>%
  kable_classic() %>%
  add_header_above(., c(" ", "Overall" = 2, "Study 1" = 2, "Study 2" = 2, "Study 3" = 2)) %>%
  pack_rows(index = table(robustTblLong$group)) %>%
  kableExtra::footnote(
    .,
    general = c("**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"), 
    escape = FALSE
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  #kableExtra::landscape() %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/mdlRobustlong.tex")

```


<!-- ```{r} -->
<!-- #| label: robustnessTblWide -->
<!-- #| include: false -->

<!-- # Wide format -->
<!-- mdlRobustTbl <- data.frame( -->
<!--   coef = c( -->
<!--     sapply(mdlRobustPrep, function(x) x[1]$coeficients$coef) %>% unlist %>% unique, -->
<!--     names(mdlRobustPrep[[1]]$random), -->
<!--     names(mdlRobustPrep[[1]]$fit) -->
<!--   ) -->
<!-- ) -->
<!-- for (i in 1:length(mdlRobustPrep)){ -->
<!--   mdlRobustTbl <- join(mdlRobustTbl, mdlRobustPrep[[i]]$mdlTbl, by = "coef") -->
<!--   #mdlTbl <- merge(mdlRobustTbl, mdlRobustPrep[[i]]$mdlTbl, by = "coef", all = TRUE, sort = FALSE, no.dups = TRUE, suffixes=c("", "")) -->
<!-- } -->

<!-- mdlRobustTblHeader <- data.frame( -->
<!--   data = as.character(mdlRobustTbl[mdlRobustTbl$coef == "data",]), -->
<!--   formula = as.character(mdlRobustTbl[mdlRobustTbl$coef == "formula",]) -->
<!-- ) %>% -->
<!--   filter(data != "", -->
<!--          data != "data") %>% -->
<!--   mutate(study = str_extract(data, "Worker|Student|Medical")) %>% -->
<!--   mutate(study = gsub("Worker", "Study 1", study)) %>% -->
<!--   mutate(study = gsub("Student", "Study 2", study)) %>% -->
<!--   mutate(study = gsub("Medical", "Study 3", study)) %>% -->
<!--   mutate(dv = sub(" ~.*", "", formula)) %>% -->
<!--   mutate(dv = gsub("Raw", " ", dv)) %>% -->
<!--   mutate(pred = str_extract(formula, "CoreNeed|Allport")) %>% -->
<!--   mutate(header = paste(study, pred, sep = " - ")) -->

<!-- mdlRobustTblHeaderFreq <- rbind.data.frame(rle(mdlRobustTblHeader$header)) %>% -->
<!--   mutate(lengths = lengths*2) %>% -->
<!--   rename(names = values, span = lengths) %>% -->
<!--   rbind(c(1, ""), .) %>% -->
<!--   mutate(span = as.numeric(span)) %>% -->
<!--   select(names, span) -->

<!-- mdlRobustTblHeaderDv <- data.frame(names = mdlRobustTblHeader$dv, span = 2) %>%  -->
<!--   mutate(names = as.character(names)) %>% -->
<!--   rbind(c("", 1), .) %>% -->
<!--   mutate(span = as.numeric(span)) -->

<!-- mdlRobustTblHeaderStudy <- rbind.data.frame(rle(mdlRobustTblHeader$study)) %>% -->
<!--   mutate(lengths = lengths*2) %>% -->
<!--   rename(names = values, span = lengths) %>% -->
<!--   rbind(c(1, ""), .) %>% -->
<!--   mutate(span = as.numeric(span)) %>% -->
<!--   select(names, span) -->

<!-- mdlRobustTbl$coef <- mapvalues( -->
<!--   mdlRobustTbl$coef, -->
<!--   from = c( -->
<!--     "sigmaSq", -->
<!--     "tau00", -->
<!--     "tau11", -->
<!--     "rho01", -->
<!--     "rho00", -->
<!--     "R2_marginal", -->
<!--     "R2_conditional",  -->
<!--     "R2Marg_R2Cond" -->
<!--   ), -->
<!--   to = c( -->
<!--     "$\\sigma^2$", -->
<!--     "$\\tau_{00}$", -->
<!--     "$\\tau_{11}$", -->
<!--     "$\\rho_{01}$", -->
<!--     "$\\rho_{00}$", -->
<!--     "$R^2_{marginal}$", -->
<!--     "$R^2_{conditional}$", -->
<!--     "$R^2_{marginal}$ / $R^2_{conditional}$" -->
<!--   ) -->
<!-- ) -->

<!-- # Long Table -->
<!-- mdlTblRobustLong <- mdlRobustTbl %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Robustness Analyses", -->
<!--     #format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = c("l", rep("c", ncol(.) - 1)), -->
<!--     escape = FALSE, -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_classic() %>% -->
<!--   add_header_above(., mdlRobustTblHeaderStudy) %>% -->
<!--   add_header_above( -->
<!--     ., -->
<!--     c( -->
<!--       "", -->
<!--       "Contact [Full Sample]" = 6, -->
<!--       "Self-Determination Theory [Outgroup Interactions only]" = 6 -->
<!--     ) -->
<!--   ) %>% -->
<!--   pack_rows("Fixed", 1, 7) %>% -->
<!--   pack_rows("Random", 8, 12) %>% -->
<!--   pack_rows("Fit", 13, 25) %>% -->
<!--   footnote( -->
<!--     general = c("PID = Participant ID number (grouping variable)", -->
<!--                 "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes", -->
<!--                 "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05" -->
<!--     ), -->
<!--     escape = FALSE -->
<!--   ) %>% -->
<!--   gsub("_cwc", "", ., fixed = TRUE)  -->

<!-- # shortened Table -->
<!-- mdlTblRobustShort <- mdlRobustTbl %>% -->
<!--   replace(is.na(.), "") -->
<!-- names(mdlTblRobustShort) <- make.unique(names(mdlTblRobustShort)) -->
<!-- mdlTblRobustShort <- mdlTblRobustShort %>% -->
<!--   filter( -->
<!--     !coef %in% c( -->
<!--       "data", -->
<!--       "formula", -->
<!--       "groupId", -->
<!--       "$R^2_{marginal}$", -->
<!--       "$R^2_{conditional}$", -->
<!--       "logLik", -->
<!--       "deviance" -->
<!--     ) -->
<!--   ) %>% -->
<!--   mutate_all(linebreak) %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Robustness Analyses", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = TRUE, -->
<!--     col.names = c("", rep(c("$B$", "$\\beta$"), (ncol(.)-1)/2)), -->
<!--     align = c("l", rep("c", ncol(.) - 1)), -->
<!--     escape = FALSE, -->
<!--     digits = 3 -->
<!--   )  %>% -->
<!--   kable_classic() %>% -->
<!--   add_header_above(., mdlRobustTblHeaderStudy) %>% -->
<!--   add_header_above( -->
<!--     ., -->
<!--     c( -->
<!--       "", -->
<!--       "Contact [Full Sample]" = 6, -->
<!--       "Self-Determination Theory [Outgroup Interactions only]" = 6 -->
<!--     ) -->
<!--   ) %>% -->
<!--   pack_rows("Fixed", 1, 7) %>% -->
<!--   pack_rows("Random", 8, 12) %>% -->
<!--   pack_rows("Fit", 13, 18) %>% -->
<!--   footnote( -->
<!--     general = c("PID = Participant ID number (grouping variable)", -->
<!--                 "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes", -->
<!--                 "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05" -->
<!--     ),  -->
<!--     escape = FALSE -->
<!--   ) %>% -->
<!--   kable_styling(latex_options = "scale_down") %>% -->
<!--   kableExtra::landscape() %>% -->
<!--   gsub("_cwc", "", ., fixed = TRUE)  %>% -->
<!--   gsub("\\makecell[l]", "\\makecell[c]", ., fixed = TRUE) %>% -->
<!--   gsub("\\makecell[r]", "\\makecell[c]", ., fixed = TRUE) %>% -->
<!--   gsub("objVar$", "", ., fixed = TRUE) %>% -->
<!--   gsub("slope_intercept.", "slope.intercept", ., fixed = TRUE) %>% -->
<!--   gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position -->
<!--   gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position -->
<!--   save_kable("Tables/mdlRobustness.tex") -->
<!-- mdlTblRobustShort -->
<!-- ``` -->

<!-- FIGURES: -->

```{r}
#| label: metaRobust
#| include: false

analyses <- unique(sub("_(?!.*_).*", "", names(mdlRobustTblElements), perl = TRUE))
studies <- unique(sub(".*_(.*)", "\\1", names(mdlRobustTblElements)))

# i = 1
robustMetaTbl <- data.frame()
for (i in 1:length(mdlRobustTblElements)){
  Prep <- lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])
  lmerTblTmp <- Prep$beta %>%
  transmute(
    group = names(mdlRobustTblElements)[[i]],
    analysis = sub("_(?!.*_).*", "", names(mdlRobustTblElements)[[i]], perl = TRUE),
    coef = gsub(":", ".", coef),
    B = est,
    se,
    lwr,
    upr,
    tval,
    Rsq,
    n = Prep$fit$N,
    m = nrow(.), 
    #dv = gsub("Dutch", "", str_extract(lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$formula,".+?(?= ~)")),
    sample = sub(".*_(.*)", "\\1", names(mdlRobustTblElements)[[i]]),
    formula = gsub("\\s+", " ", Prep$fit$formula)
  )
  robustMetaTbl <- rbind(robustMetaTbl, lmerTblTmp)
}
robustMetaTblSorted <- robustMetaTbl %>% 
  mutate(group = factor(group, levels = unique(group)),
         contains_period = ifelse(grepl("\\.", coef), 1, 0),
         special = case_when(
           coef == "(Intercept)" ~ "first",
           coef == "CoreNeed" ~ "second",
           coef == "R2Marg_R2Cond" ~ "last",
           TRUE ~ "middle"
         ),
         special = factor(special, levels = c("first", "second", "middle", "last"))) %>% 
  arrange(group, special, contains_period, coef) %>% 
  select(-contains_period, -special) %>%
  filter(sample != "overall") %>% 
  mutate(formula = gsub(" \\+ \\(.*", "", formula))

replacement_mapping <- c("contact" = "Contact Specific",
                         "accidental" = "Interaction Intend",
                         "wellbeing_core" = "Well-being Outcome",
                         "need_type" = "Need Type",
                         "need_sdt" = "Specific Psychological Needs")

robustMeta <- list()
for (name in unique(robustMetaTblSorted$analysis)) {
  lab <- case_when(
    name %in% names(replacement_mapping) ~ replacement_mapping[name],
    TRUE ~ as.character(name)
  )
  robustMeta[[name]] <- metaLmerOut(
    lmerDataTbl = robustMetaTblSorted %>% filter(analysis == name),
    type = "REML", #"FE", 
    name = name,
    title = paste0("Robustness — ", lab), 
  )
}
```

```{r}
#| label: robustForestPltComb
#| include: false

process_element <- function(element) {
  # Apply dplyr filtering and mutating
  df_eff_adjusted <- element$eff %>%
    filter(coef != "(Intercept)") %>%
    mutate(metaId = paste(coef, analysis, sep = ".")) %>%
    as.data.frame
  
  return(df_eff_adjusted)
}
adjusted_dataframes <- lapply(robustMeta, process_element)

lookup_table <- data.frame(analysis = unique(names(adjusted_dataframes)), group_letter = LETTERS[seq_along(unique(names(adjusted_dataframes)))])

effRobust <- do.call(rbind, adjusted_dataframes) %>%
  left_join(lookup_table, by = "analysis") %>%
  mutate(
    analysis = paste0("(",group_letter, ") ",
      case_when(
        analysis %in% names(replacement_mapping) ~ replacement_mapping[analysis],
        TRUE ~ as.character(analysis)
      )
    ),
    contains_period = ifelse(grepl("\\.", coef), 1, 0),
    special = case_when(coef == "CoreNeedZ" ~ "first", 
                        TRUE ~ "last"),
    special = factor(special, levels = c("first", "last"))
  ) %>%
  arrange(analysis, special, contains_period, coef, sample) %>%
  select(-group_letter, -special, -contains_period)


metaSubForest(effects = effRobust, 
              title = "Meta Analysis: Forest Plot Robustness Analysis \n[Parametric]",
              filename = "RobustnessComb",
              addAbove = 5,
              width = 600,
              height = 1200)
```



<!-- -------------------------------------------------------------------- -->

<!--                               OLD CODE                               -->

<!-- -------------------------------------------------------------------- -->





<!-- \subsubsection{Study 1} -->

<!-- ```{r workerSampleInfo, include=FALSE} -->
<!-- # combine education measure -->
<!-- workerOccupation <-  -->
<!--   dtWorker$clean %>% -->
<!--   select(PID, starts_with("occupation")) %>% -->
<!--   mutate_all(as_factor) %>%  -->
<!--   mutate_all(as.character) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   unite("occupation", -PID, sep = "/") %>% -->
<!--   mutate(occupation = trimws(occupation, which = "both", whitespace = "[/]")) %>% -->
<!--   distinct -->

<!-- # summarize participant characteristics -->
<!-- workerSampleInfo <-  -->
<!--   dtWorker$clean %>% -->
<!--   group_by(PID) %>% -->
<!--   summarise( -->
<!--     dailiesN = n(),  -->
<!--     morningN = sum(daytime=="morning"), -->
<!--     afternoonN = sum(daytime=="afternoon"), -->
<!--     age = age, -->
<!--     gender = as_factor(Gender), -->
<!--     edu = as_factor(education_level), -->
<!--     nationality = as_factor(nationality) -->
<!--   ) %>% -->
<!--   distinct -->

<!-- # add occupation variable -->
<!-- workerSampleInfo <- merge(workerSampleInfo, workerOccupation) -->
<!-- rm(workerOccupation) -->

<!-- # divide into trait and state -->
<!-- dtWorkerSupp$workerWithinBetween <- -->
<!--   MlTraitState( -->
<!--     data = dtWorkerSupp$workerInteractionType, -->
<!--     id = "PID", -->
<!--     selection = -->
<!--       c( -->
<!--         "keyMotiveFulfilled", -->
<!--         "competence.daily.all", -->
<!--         "autonomy.daily.all", -->
<!--         "relatedness.daily.all", -->
<!--         "thermometerDutch_1", -->
<!--         "keymotive_fulfillemt_1", -->
<!--         "competence_1", -->
<!--         "autonomy_1", -->
<!--         "relatedness_1",  -->
<!--         "quality_overall_1",  -->
<!--         "OutgroupInteraction", -->
<!--         "NonOutgroupInteraction",  -->
<!--         "OutgroupInteractionM", -->
<!--         "NonOutgroupInteractionM" -->
<!--       ) -->
<!--   ) -->

<!-- dtWorkerSupp$workerOutWithinBetween <- -->
<!--   MlTraitState( -->
<!--     data = dtWorkerSupp$workerInteractionType %>% filter(OutgroupInteraction == "Yes"), -->
<!--     id = "PID", -->
<!--     selection = -->
<!--       c( -->
<!--         "keyMotiveFulfilled", -->
<!--         "thermometerDutch_1", -->
<!--         "keymotive_fulfillemt_1", -->
<!--         "competence_1", -->
<!--         "autonomy_1", -->
<!--         "relatedness_1",  -->
<!--         "quality_overall_1" -->
<!--       ) -->
<!--   ) -->
<!-- ``` -->

<!-- ```{r workerModelOlsAttFreqQual, include=FALSE} -->
<!-- # create list to store Worker models -->
<!-- mdlWorker <- list() -->
<!-- ``` -->

<!-- ```{r workerModelMLAttNull, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlWorker$lmerAttNull <- -->
<!--   lme4::lmer(thermometerDutch_1 ~ 1 + (1 | PID), -->
<!--     data = dtWorker$full -->
<!--   ) # use optim if it does not converge -->

<!-- mdlWorker$lmeAttNull <- -->
<!--   lme( -->
<!--     thermometerDutch_1 ~ 1, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtWorker$full, -->
<!--     na.action=na.omit, -->
<!--     control = list(opt = "nlmimb") -->
<!--   ) # use optim if it does not converge -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- # summary(lmerWorkerAttNull) #or with the lme function -->
<!-- summ(mdlWorker$lmerAttNull, digits = 3, center = TRUE) -->

<!-- # Save variances -->
<!-- mdlWorker$varAttNull <-  -->
<!--   VarCorr(mdlWorker$lmeAttNull) # save variances -->
<!-- # The estimate of (between-group or Intercept variance, tau_{00}^2): -->
<!-- mdlWorker$tauAttNull <-  -->
<!--   as.numeric(mdlWorker$varAttNull[1]) -->
<!-- # and the estimate of (within-group or residual variance, sigma^2) is: -->
<!-- mdlWorker$sigmaAttNull <-  -->
<!--   as.numeric(mdlWorker$varAttNull[2]) -->
<!-- # The ICC estimate (between/between+within) is: -->
<!-- mdlWorker$IccAttNull <- -->
<!--   (as.numeric(mdlWorker$varAttNull[1]) / (as.numeric(mdlWorker$varAttNull[1]) + as.numeric(mdlWorker$varAttNull[2]))) -->
<!-- mdlWorker$IccPercAttNull <- -->
<!--   ((as.numeric(mdlWorker$varAttNull[1]) / (as.numeric(mdlWorker$varAttNull[1]) + as.numeric(mdlWorker$varAttNull[2])))) * 100 -->
<!-- ``` -->

<!-- ```{r workerOutModelMLAttNull, include=FALSE} -->
<!-- # create empty list to organize models -->
<!-- mdlWorkerOut <-  -->
<!--   list( -->
<!--     Att = list(), -->
<!--     Qlt = list() -->
<!--   ) -->

<!-- # Create and save Model -->
<!-- mdlWorkerOut$Att$lmerNull <- -->
<!--   lme4::lmer(thermometerDutch_1 ~ 1 + (1 | PID),  -->
<!--              data = dtWorkerSupp$workerOutgroupInteraction) # use optim if it does not converge -->
<!-- mdlWorkerOut$Att$lmeNull <- -->
<!--   lme( -->
<!--     thermometerDutch_1 ~ 1, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtWorkerSupp$workerOutgroupInteraction, -->
<!--     na.action=na.omit, -->
<!--     control = list(opt = "nlmimb") -->
<!--   ) # use optim if it does not converge -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- # summary(Null.Out.ML.r) #or with the lme function -->
<!-- summ(mdlWorkerOut$Att$lmerNull, digits = 3, center = TRUE) -->

<!-- # Save variances -->
<!-- mdlWorkerOut$Att$varNull <-  -->
<!--   VarCorr(mdlWorkerOut$Att$lmeNull) # save variances -->
<!-- # The estimate of (between-group or Intercept variance, tau_{00}^2): -->
<!-- mdlWorkerOut$Att$tauNull <-  -->
<!--   as.numeric(mdlWorkerOut$Att$varNull[1]) -->
<!-- # and the estimate of (within-group or residual variance, sigma^2) is: -->
<!-- mdlWorkerOut$Att$sigmaNull <-  -->
<!--   as.numeric(mdlWorkerOut$Att$varNull[2]) -->
<!-- # The ICC estimate (between/between+within) is: -->
<!-- mdlWorkerOut$Att$IccNull <- -->
<!--   (as.numeric(mdlWorkerOut$Att$varNull[1]) / (as.numeric(mdlWorkerOut$Att$varNull[1]) + as.numeric(mdlWorkerOut$Att$varNull[2]))) -->
<!-- mdlWorkerOut$Att$IccPercNull <- -->
<!--   ((as.numeric(mdlWorkerOut$Att$varNull[1]) / (as.numeric(mdlWorkerOut$Att$varNull[1]) + as.numeric(mdlWorkerOut$Att$varNull[2])))) * 100 -->
<!-- ``` -->

<!-- ```{r workerOutModelMLQltNull, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlWorkerOut$Qlt$lmerNull <- -->
<!--   lme4::lmer(quality_overall_1 ~ 1 + (1 | PID),  -->
<!--              data = dtWorkerSupp$workerOutWithinBetween) # use optim if it does not converge -->

<!-- mdlWorkerOut$Qlt$lmeNull <- -->
<!--   mdlWorkerOut$Qlt$lmeNull <- lme( -->
<!--     quality_overall_1 ~ 1, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtWorkerSupp$workerOutWithinBetween, -->
<!--     na.action=na.omit, -->
<!--     control = list(opt = "nlmimb") -->
<!--   ) # use optim if it does not converge -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- # summary(Null.Out.Qual.ML.r) #or with the lme function -->
<!-- summ(mdlWorkerOut$Qlt$lmerNull, digits = 3) -->

<!-- # Save variances -->
<!-- mdlWorkerOut$Qlt$varNull <-  -->
<!--   VarCorr(mdlWorkerOut$Qlt$lmeNull) # save variances -->
<!-- # The estimate of (between-group or Intercept variance, tau_{00}^2): -->
<!-- mdlWorkerOut$Qlt$tauNull <-  -->
<!--   as.numeric(mdlWorkerOut$Qlt$varNull[1]) -->
<!-- # and the estimate of (within-group or residual variance, sigma^2) is: -->
<!-- mdlWorkerOut$Qlt$sigmaNull <-  -->
<!--   as.numeric(mdlWorkerOut$Qlt$varNull[2]) -->
<!-- # The ICC estimate (between/between+within) is: -->
<!-- mdlWorkerOut$Qlt$IccNull <- -->
<!--   (as.numeric(mdlWorkerOut$Qlt$varNull[1]) / (as.numeric(mdlWorkerOut$Qlt$varNull[1]) + as.numeric(mdlWorkerOut$Qlt$varNull[2]))) -->
<!-- mdlWorkerOut$Qlt$IccPercNull <- -->
<!--   ((as.numeric(mdlWorkerOut$Qlt$varNull[1]) / (as.numeric(mdlWorkerOut$Qlt$varNull[1]) + as.numeric(mdlWorkerOut$Qlt$varNull[2])))) * 100 -->
<!-- ``` -->


<!-- ```{r workerModelInterceptAttCoreInt, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlWorker$lmeInterceptAttCoreInt <- -->
<!--   lme( -->
<!--     thermometerDutch_1 ~ keyMotiveFulfilled_cwc * OutgroupInteraction, -->
<!--     random =  ~ 1 | PID, -->
<!--     na.action=na.omit, -->
<!--     data = dtWorkerSupp$workerWithinBetween -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- summ( -->
<!--   mdlWorker$lmerInterceptAttCoreInt <- lmer( -->
<!--     thermometerDutch_1 ~ keyMotiveFulfilled_cwc * OutgroupInteraction + (1 | PID), -->
<!--     data = dtWorkerSupp$workerWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # 95%CI -->
<!-- mdlWorker$lmerInterceptAttCoreIntCI <-  -->
<!--   confint(method = "Wald", mdlWorker$lmerInterceptAttCoreInt) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlWorker$lmeAttNull,  -->
<!--       mdlWorker$lmeInterceptAttCoreInt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   add_rownames(., var = "Description") %>% -->
<!--   mutate(Description = gsub(".*\\$", "", Description)) %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Worker: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = c("l", rep("c", ncol(.)-1)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->

<!-- # Save variances -->
<!-- mdlWorker$varInterceptAttCoreInt <-  -->
<!--   lme4::VarCorr(mdlWorker$lmeInterceptAttCoreInt) -->
<!-- ``` -->
<!-- ```{r workerModelSlopesAttCoreIntX, include=FALSE} -->
<!-- # Create and save Model (optimizer needed to reach convergence) -->
<!-- mdlWorker$lmeSlopesAttCoreInt <- lme( -->
<!--   thermometerDutch_1 ~ -->
<!--     keyMotiveFulfilled_cwc * OutgroupInteraction, -->
<!--   random = ~ 1 + keyMotiveFulfilled_cwc + OutgroupInteraction | PID, -->
<!--   control = lmeControl(opt = "optim"), -->
<!--   na.action=na.omit, -->
<!--   data = dtWorkerSupp$workerWithinBetween -->
<!-- ) -->

<!-- # Get summary with p-values (Satterthwaite's method) [+ save model for plotting] -->
<!-- summ( -->
<!--   mdlWorker$lmerSlopesAttCoreInt <- lmer( -->
<!--     thermometerDutch_1 ~ -->
<!--       keyMotiveFulfilled_cwc * OutgroupInteraction + -->
<!--       (1 + keyMotiveFulfilled_cwc + OutgroupInteraction | PID), -->
<!--     data = dtWorkerSupp$workerWithinBetween -->
<!--   ),  -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # 95%CI -->
<!-- mdlWorker$lmerSlopesAttCoreIntCI <-  -->
<!--   confint(method = "Wald", mdlWorker$lmerSlopesAttCoreInt) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlWorker$lmeAttNull,  -->
<!--       mdlWorker$lmeInterceptAttCoreInt, -->
<!--       mdlWorker$lmeSlopesAttCoreInt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   add_rownames(., var = "Description") %>% -->
<!--   mutate(Description = gsub(".*\\$", "", Description)) %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Worker: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->

<!-- # Save variances -->
<!-- mdlWorker$varSlopesAttCoreInt <-  -->
<!--   lme4::VarCorr(mdlWorker$lmeSlopesAttCoreInt) -->

<!-- # Assumption Checks: -->
<!-- mdlWorker$diagSlopesAttCoreInt <- -->
<!--   sjPlot::plot_model(mdlWorker$lmerSlopesAttCoreInt, type = "diag") -->
<!-- grid.arrange( -->
<!--   mdlWorker$diagSlopesAttCoreInt[[1]], -->
<!--   mdlWorker$diagSlopesAttCoreInt[[2]]$`PID`, -->
<!--   mdlWorker$diagSlopesAttCoreInt[[3]], -->
<!--   mdlWorker$diagSlopesAttCoreInt[[4]] -->
<!-- ) -->

<!-- # Plot prediction model -->
<!-- mdlWorker$predSlopesAttCoreInt <-  -->
<!--   dtWorkerSupp$workerWithinBetween %>% -->
<!--   select(thermometerDutch_1, session, PID) %>%  -->
<!--   mutate(measure = predict(mdlWorker$lmeSlopesAttCoreInt, -->
<!--                            dtWorkerSupp$workerWithinBetween, -->
<!--                            re.form = NA -->
<!--                            ) -->
<!--          ) -->

<!-- ( -->
<!--   mdlWorker$predPltSlopesAttCoreInt <- -->
<!--     ggplot(data = mdlWorker$predSlopesAttCoreInt, aes(x = session, y = measure)) + -->
<!--     geom_line(alpha = 1, color = "blue") + -->
<!--     geom_line(aes(y = thermometerDutch_1), alpha = 1) + -->
<!--     facet_wrap(~ PID, ncol = 6) + -->
<!--     xlab("Time") + -->
<!--     ylab("Outgroup Attitudes") + -->
<!--     theme_Publication() -->
<!-- ) -->
<!-- ggsave( -->
<!--   filename = "Figures/Worker_PredictionPlot_SlopesAttCoreInt.png", -->
<!--   mdlWorker$predPltSlopesAttCoreInt, -->
<!--   width = 18, -->
<!--   height = 12, -->
<!--   dpi = 800, -->
<!--   units = "cm", -->
<!--   device = "png" -->
<!-- ) -->
<!-- ``` -->



<!-- ```{r workerOutModelInterceptAttCoreSdt, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlWorkerOut$Att$lmeInterceptCoreSdt <- -->
<!--   lme( -->
<!--     thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtWorkerSupp$workerOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- summ( -->
<!--   mdlWorkerOut$Att$lmerInterceptCoreSdt <- lmer( -->
<!--     thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc + (1 | PID), -->
<!--     data = dtWorkerSupp$workerOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # To be compared against a model with only the self-determination theory needs -->
<!-- mdlWorkerOut$Att$lmeInterceptSdt <- -->
<!--   lme( -->
<!--     thermometerDutch_1 ~ competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtWorkerSupp$workerOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- summ( -->
<!--   mdlWorkerOut$Att$lmerInterceptSdt <- lmer( -->
<!--     thermometerDutch_1 ~ competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc + (1 | PID), -->
<!--     data = dtWorkerSupp$workerOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # Compare new model to previous steps -->
<!-- anova( -->
<!--   mdlWorkerOut$Att$lmeInterceptSdt, -->
<!--   mdlWorkerOut$Att$lmeInterceptCoreSdt -->
<!--   ) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Worker: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->
<!-- rm(lmeInterceptCoreRed) -->

<!-- # Save variances -->
<!-- mdlWorkerOut$Att$varInterceptCoreSdt <- -->
<!--   lme4::VarCorr(mdlWorkerOut$Att$lmeInterceptCoreSdt) -->
<!-- ``` -->
<!-- ```{r workerOutModelSlopesAttCoreSdt, include=FALSE} -->
<!-- # Create and save Model (optimizer needed to reach convergence) -->
<!-- mdlWorkerOut$Att$lmeSlopesCoreSdt <- -->
<!--   lme( -->
<!--     thermometerDutch_1 ~ -->
<!--       keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc, -->
<!--     random = ~ 1 + keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID, -->
<!--     control = lmeControl(opt = "optim"), -->
<!--     data = dtWorkerSupp$workerOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) [+ save model for plotting] -->
<!-- summ( -->
<!--   mdlWorkerOut$Att$lmerSlopesCoreSdt <- lmer( -->
<!--     thermometerDutch_1 ~ -->
<!--       keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc + -->
<!--       (1 + keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID), -->
<!--     data = dtWorkerSupp$workerOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- mdlWorkerOut$Att$lmerSlopesCoreSdtCI <-  -->
<!--   confint(method = "Wald", mdlWorkerOut$Att$lmerSlopesCoreSdt) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlWorkerOut$Att$lmeInterceptSdt, -->
<!--       mdlWorkerOut$Att$lmeInterceptCoreSdt,  -->
<!--       mdlWorkerOut$Att$lmeSlopesCoreSdt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Worker: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->

<!-- # model with SDT only -->
<!-- # Create and save Model (optimizer needed to reach convergence) -->
<!-- mdlWorkerOut$Att$lmeSlopesSdt <- -->
<!--   lme( -->
<!--     thermometerDutch_1 ~ -->
<!--       competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc, -->
<!--     random = ~ 1 + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID, -->
<!--     control = lmeControl(opt = "optim"), -->
<!--     data = dtWorkerSupp$workerOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) [+ save model for plotting] -->
<!-- summ( -->
<!--   mdlWorkerOut$Att$lmerSlopesSdt <- lmer( -->
<!--     thermometerDutch_1 ~ -->
<!--       competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc + -->
<!--       (1 + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID), -->
<!--     data = dtWorkerSupp$workerOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlWorkerOut$Att$lmeInterceptSdt, -->
<!--       mdlWorkerOut$Att$lmeSlopesSdt,  -->
<!--       mdlWorkerOut$Att$lmeSlopesCoreSdt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Worker: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->


<!-- # Save variances -->
<!-- mdlWorkerOut$Att$varSlopesCoreSdt <-  -->
<!--   lme4::VarCorr(mdlWorkerOut$Att$lmeSlopesCoreSdt) -->

<!-- # Assumption Checks: -->
<!-- mdlWorkerOut$Att$diagSlopesCoreSdt <-  -->
<!--   sjPlot::plot_model(mdlWorkerOut$Att$lmerSlopesCoreSdt, type = "diag") -->
<!-- grid.arrange( -->
<!--   mdlWorkerOut$Att$diagSlopesCoreSdt[[1]], -->
<!--   mdlWorkerOut$Att$diagSlopesCoreSdt[[2]]$`PID`, -->
<!--   mdlWorkerOut$Att$diagSlopesCoreSdt[[3]], -->
<!--   mdlWorkerOut$Att$diagSlopesCoreSdt[[4]] -->
<!-- ) -->

<!-- # Plot prediction model -->
<!-- mdlWorkerOut$Att$predSlopesCoreSdt <-  -->
<!--   dtWorkerSupp$workerOutWithinBetween %>% -->
<!--   filter(!is.na(autonomy_1)) %>% -->
<!--   select(thermometerDutch_1, session, PID, autonomy_1) %>%  -->
<!--   mutate(measure = predict(mdlWorkerOut$Att$lmeSlopesCoreSdt, -->
<!--                            dtWorkerSupp$workerOutWithinBetween %>% filter(!is.na(autonomy_1)), -->
<!--                            re.form = NA -->
<!--                            ) -->
<!--          ) -->

<!-- ( -->
<!--   mdlWorkerOut$Att$predPltSlopesCoreSdt <- -->
<!--     ggplot(data = mdlWorkerOut$Att$predSlopesCoreSdt, aes(x = session, y = measure)) + -->
<!--     geom_line(alpha = 1, color = "blue") + -->
<!--     geom_line(aes(y = thermometerDutch_1), alpha = 1) + -->
<!--     facet_wrap( ~ PID, ncol = 6) + -->
<!--     xlab("Time") + -->
<!--     ylab("Outgroup Attitudes") + -->
<!--     theme_Publication() -->
<!-- ) -->
<!-- ggsave( -->
<!--   filename = "Figures/WorkerOut_PredictionPlot_SlopesAttCoreStd.png", -->
<!--   mdlWorkerOut$Att$predPltSlopesCoreSdt, -->
<!--   width = 18, -->
<!--   height = 12, -->
<!--   dpi = 800, -->
<!--   units = "cm", -->
<!--   device = "png" -->
<!-- ) -->

<!-- # Model comparison -->
<!-- workerSdtComp <- -->
<!--   anova( -->
<!--     mdlWorkerOut$Att$lmerSlopesSdt,  -->
<!--     mdlWorkerOut$Att$lmerSlopesCoreSdt -->
<!--   ) %>% -->
<!--   as.data.frame() -->
<!-- workerSdtCompDf <- workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Df"] -->
<!-- workerSdtCompN <- sapply(ranef(mdlWorkerOut$Att$lmerSlopesCoreSdt), nrow) -->
<!-- workerSdtCompChi <- workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2) -->
<!-- workerSdtCompP <- -->
<!--   ifelse(workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001, -->
<!--          "< .001", -->
<!--          paste0("= ", workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3))) -->

<!-- workerSdtCompChiSq <- paste0("$\\chi^2$(", workerSdtCompDf, ", \\textit{N} = ", workerSdtCompN, ") = ", workerSdtCompChi, ", \\textit{p} ", workerSdtCompP) -->
<!-- ``` -->

<!-- In a final step, we controlled for other fundamental psychological needs during the contact. We focus on the three commonly considered self-determination needs (SDT): competence, autonomy, and relatedness. We find that the core need fulfillment adds significantly above a model with only the self-determination theory needs (random slopes models; `r workerSdtCompChiSq`). We also find that next to relatedness (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreSdt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreSdtCI, varName = "relatedness_1_cwc")`), the core need explains the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreSdt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreSdtCI, varName = "keymotive_fulfillemt_1_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all three fundamental needs (competence and autonomy needs turning non-significant; all \textit{b} < `r coef(summary(mdlWorkerOut$Att$lmeSlopesCoreSdt))[c("competence_1_cwc", "autonomy_1_cwc"),"Value"] %>% max %>% round(2) %>% format(nsmall=2)`, all \textit{p} > `r coef(summary(mdlWorkerOut$Att$lmeSlopesCoreSdt))[c("competence_1_cwc", "autonomy_1_cwc"),"p-value"] %>% min %>% round(3) %>% format(nsmall=3)`). For full results see see \tblref{tab:robustnessTblLong} and \fgrref{fig:Robustness}, and Online Supplementary Material A. There is, thus, considerable evidence lending confidence to the stability and relevance of psychological need fulfillment as a predictor of positive outgroup attitudes for natural intergroup contacts. -->

<!-- \hl{Intend ...} -->

<!-- \hl{Goal-directedness ...} -->

<!-- \hl{Well-being ...} -->

<!-- \subsubsection{Study 2} -->

<!-- ```{r studentSampleInfo, include=FALSE} -->
<!-- # summarize participant characteristics -->
<!-- studentSampleInfo <-  -->
<!--   dtStudents$full %>% -->
<!--   mutate(gender = as.factor(ifelse(.$Gender == 1, "women", ifelse(.$Gender == 2, "man", ifelse(.$Gender == 3, "other", NA))))) %>% -->
<!--   group_by(PID) %>% -->
<!--   summarise( -->
<!--     dailiesN = n(),  -->
<!--     morningN = sum(periodMA=="morning"), -->
<!--     afternoonN = sum(periodMA=="afternoon"), -->
<!--     age = age, -->
<!--     gender = gender, -->
<!--     nationality = nationality -->
<!--   ) %>% -->
<!--   distinct -->

<!-- # look at frequencies of characteristics  -->
<!-- table(studentSampleInfo$gender) -->
<!-- table(as.character(studentSampleInfo$nationality)) -->

<!-- # divide into trait and state -->
<!-- dtStudentSupp$studentWithinBetween <- -->
<!--   MlTraitState( -->
<!--     data = dtStudentSupp$studentInteractionType, -->
<!--     id = "PID", -->
<!--     selection = -->
<!--       c( -->
<!--         "KeyNeedFullfillment", -->
<!--         "Competence", -->
<!--         "Autonomy", -->
<!--         "Relatedness", -->
<!--         "AttitudesDutch", -->
<!--         "quality_overall", -->
<!--         "OutgroupInteraction", -->
<!--         "NonOutgroupInteraction", -->
<!--         "OutgroupInteractionM", -->
<!--         "NonOutgroupInteractionM" -->
<!--       ) -->
<!--   ) -->
<!-- dtStudentSupp$studentOutWithinBetween <- -->
<!--   MlTraitState( -->
<!--     data = dtStudentSupp$studentInteractionType %>% filter(OutgroupInteraction == "Yes"), -->
<!--     id = "PID", -->
<!--     selection = -->
<!--       c( -->
<!--         "KeyNeedFullfillment", -->
<!--         "Competence", -->
<!--         "Autonomy", -->
<!--         "Relatedness", -->
<!--         "AttitudesDutch", -->
<!--         "quality_overall" -->
<!--       ) -->
<!--   ) -->
<!-- ``` -->

<!-- ```{r studentModelOlsAttFreqQual, include=FALSE} -->
<!-- # create list to store Worker models -->
<!-- mdlStudent <- list() -->
<!-- ``` -->

<!-- ```{r studentModelMLAttNull, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlStudent$lmerAttNull <- -->
<!--   lme4::lmer(AttitudesDutch ~ 1 + (1 | PID), -->
<!--     data = dtStudents$full -->
<!--   ) # use optim if it does not converge -->

<!-- mdlStudent$lmeAttNull <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ 1, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtStudents$full, -->
<!--     control = list(opt = "nlmimb") -->
<!--   ) # use optim if it does not converge -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- # summary(mdlStudent$lmerAttNull) #or with the lme function -->
<!-- summ(mdlStudent$lmerAttNull, digits = 3) -->

<!-- # Save variances -->
<!-- mdlStudent$varAttNull <-  -->
<!--   VarCorr(mdlStudent$lmeAttNull) # save variances -->
<!-- # The estimate of (between-group or Intercept variance, tau_{00}^2): -->
<!-- mdlStudent$tauAttNull <-  -->
<!--   as.numeric(mdlStudent$varAttNull[1]) -->
<!-- # and the estimate of (within-group or residual variance, sigma^2) is: -->
<!-- mdlStudent$sigmaAttNull <-  -->
<!--   as.numeric(mdlStudent$varAttNull[2]) -->
<!-- # The ICC estimate (between/between+within) is: -->
<!-- mdlStudent$IccAttNull <- -->
<!--   (as.numeric(mdlStudent$varAttNull[1]) / (as.numeric(mdlStudent$varAttNull[1]) + as.numeric(mdlStudent$varAttNull[2]))) -->
<!-- mdlStudent$IccPercAttNull <- -->
<!--   ((as.numeric(mdlStudent$varAttNull[1]) / (as.numeric(mdlStudent$varAttNull[1]) + as.numeric(mdlStudent$varAttNull[2])))) * 100 -->
<!-- ``` -->

<!-- ```{r studentOutModelMLAttNull, include=FALSE} -->
<!-- # create empty list to organize models -->
<!-- mdlStudentOut <-  -->
<!--   list( -->
<!--     Att = list(), -->
<!--     Qlt = list() -->
<!--   ) -->

<!-- # Create and save Model -->
<!-- mdlStudentOut$Att$lmerNull <- -->
<!--   lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),  -->
<!--              data = dtStudentSupp$studentOutgroupInteraction) # use optim if it does not converge -->
<!-- mdlStudentOut$Att$lmeNull <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ 1, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtStudentSupp$studentOutgroupInteraction, -->
<!--     control = list(opt = "nlmimb") -->
<!--   ) # use optim if it does not converge -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- # summary(Null.Out.ML.r) #or with the lme function -->
<!-- summ(mdlStudentOut$Att$lmerNull, digits = 3, center = TRUE) -->

<!-- # Save variances -->
<!-- mdlStudentOut$Att$varNull <-  -->
<!--   VarCorr(mdlStudentOut$Att$lmeNull) # save variances -->
<!-- # The estimate of (between-group or Intercept variance, tau_{00}^2): -->
<!-- mdlStudentOut$Att$tauNull <-  -->
<!--   as.numeric(mdlStudentOut$Att$varNull[1]) -->
<!-- # and the estimate of (within-group or residual variance, sigma^2) is: -->
<!-- mdlStudentOut$Att$sigmaNull <-  -->
<!--   as.numeric(mdlStudentOut$Att$varNull[2]) -->
<!-- # The ICC estimate (between/between+within) is: -->
<!-- mdlStudentOut$Att$IccNull <- -->
<!--   (as.numeric(mdlStudentOut$Att$varNull[1]) / (as.numeric(mdlStudentOut$Att$varNull[1]) + as.numeric(mdlStudentOut$Att$varNull[2]))) -->
<!-- mdlStudentOut$Att$IccPercNull <- -->
<!--   ((as.numeric(mdlStudentOut$Att$varNull[1]) / (as.numeric(mdlStudentOut$Att$varNull[1]) + as.numeric(mdlStudentOut$Att$varNull[2])))) * 100 -->
<!-- ``` -->

<!-- ```{r studentOutModelMLQltNull, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlStudentOut$Qlt$lmerNull <- -->
<!--   lme4::lmer(quality_overall ~ 1 + (1 | PID),  -->
<!--              data = dtStudentSupp$studentOutWithinBetween) # use optim if it does not converge -->
<!-- mdlStudentOut$Qlt$lmeNull <- -->
<!--   mdlStudentOut$Qlt$lmeNull <-lme( -->
<!--     quality_overall ~ 1, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtStudentSupp$studentOutWithinBetween, -->
<!--     control = list(opt = "nlmimb") -->
<!--   ) # use optim if it does not converge -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- # summary(Null.Out.Qual.ML.r) #or with the lme function -->
<!-- summ(mdlStudentOut$Qlt$lmerNull, digits = 3) -->

<!-- # Save variances -->
<!-- mdlStudentOut$Qlt$varNull <-  -->
<!--   VarCorr(mdlStudentOut$Qlt$lmeNull) # save variances -->
<!-- # The estimate of (between-group or Intercept variance, tau_{00}^2): -->
<!-- mdlStudentOut$Qlt$tauNull <-  -->
<!--   as.numeric(mdlStudentOut$Qlt$varNull[1]) -->
<!-- # and the estimate of (within-group or residual variance, sigma^2) is: -->
<!-- mdlStudentOut$Qlt$sigmaNull <-  -->
<!--   as.numeric(mdlStudentOut$Qlt$varNull[2]) -->
<!-- # The ICC estimate (between/between+within) is: -->
<!-- mdlStudentOut$Qlt$IccNull <- -->
<!--   (as.numeric(mdlStudentOut$Qlt$varNull[1]) / (as.numeric(mdlStudentOut$Qlt$varNull[1]) + as.numeric(mdlStudentOut$Qlt$varNull[2]))) -->
<!-- mdlStudentOut$Qlt$IccPercNull <- -->
<!--   ((as.numeric(mdlStudentOut$Qlt$varNull[1]) / (as.numeric(mdlStudentOut$Qlt$varNull[1]) + as.numeric(mdlStudentOut$Qlt$varNull[2])))) * 100 -->
<!-- ``` -->

<!-- ```{r studentModelInterceptAttCoreInt, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlStudent$lmeInterceptAttCoreInt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ KeyNeedFullfillment_cwc * OutgroupInteraction, -->
<!--     random =  ~ 1 | PID, -->
<!--     data = dtStudentSupp$studentWithinBetween -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- summ( -->
<!--   mdlStudent$lmerInterceptAttCoreInt <- lmer( -->
<!--     AttitudesDutch ~ KeyNeedFullfillment_cwc * OutgroupInteraction + (1 | PID), -->
<!--     data = dtStudentSupp$studentWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # 95%CI -->
<!-- mdlStudent$lmerInterceptAttCoreIntCI <-  -->
<!--   confint(method = "Wald", mdlStudent$lmerInterceptAttCoreInt) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlStudent$lmeAttNull,  -->
<!--       mdlStudent$lmeInterceptAttCoreInt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   add_rownames(., var = "Description") %>% -->
<!--   mutate(Description = gsub(".*\\$", "", Description)) %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Student: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = c("l", rep("c", ncol(.)-1)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->

<!-- # Save variances -->
<!-- mdlStudent$varInterceptAttCoreInt <-  -->
<!--   lme4::VarCorr(mdlStudent$lmeInterceptAttCoreInt) -->
<!-- ``` -->
<!-- ```{r studentModelSlopesAttCoreIntX, include=FALSE} -->
<!-- # Create and save Model (optimizer needed to reach convergence) -->
<!-- mdlStudent$lmeSlopesAttCoreInt <- lme( -->
<!--   AttitudesDutch ~ -->
<!--     KeyNeedFullfillment_cwc * OutgroupInteraction, -->
<!--   random = ~ 1 + KeyNeedFullfillment_cwc + OutgroupInteraction | PID, -->
<!--   control = lmeControl(opt = "optim"), -->
<!--   data = dtStudentSupp$studentWithinBetween -->
<!-- ) -->

<!-- # Get summary with p-values (Satterthwaite's method) [+ save model for plotting] -->
<!-- summ( -->
<!--   mdlStudent$lmerSlopesAttCoreInt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       KeyNeedFullfillment_cwc * OutgroupInteraction + -->
<!--       (1 + KeyNeedFullfillment_cwc + OutgroupInteraction | PID), -->
<!--     data = dtStudentSupp$studentWithinBetween -->
<!--   ),  -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # 95%CI -->
<!-- mdlStudent$lmerSlopesAttCoreIntCI <-  -->
<!--   confint(method = "Wald", mdlStudent$lmerSlopesAttCoreInt) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlStudent$lmeAttNull,  -->
<!--       mdlStudent$lmeInterceptAttCoreInt, -->
<!--       mdlStudent$lmeSlopesAttCoreInt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   add_rownames(., var = "Description") %>% -->
<!--   mutate(Description = gsub(".*\\$", "", Description)) %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Student: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->

<!-- # Save variances -->
<!-- mdlStudent$varSlopesAttCoreInt <-  -->
<!--   lme4::VarCorr(mdlStudent$lmeSlopesAttCoreInt) -->

<!-- # Assumption Checks: -->
<!-- mdlStudent$diagSlopesAttCoreInt <- -->
<!--   sjPlot::plot_model(mdlStudent$lmerSlopesAttCoreInt, type = "diag") -->
<!-- grid.arrange( -->
<!--   mdlStudent$diagSlopesAttCoreInt[[1]], -->
<!--   mdlStudent$diagSlopesAttCoreInt[[2]]$`PID`, -->
<!--   mdlStudent$diagSlopesAttCoreInt[[3]], -->
<!--   mdlStudent$diagSlopesAttCoreInt[[4]] -->
<!-- ) -->

<!-- # Plot prediction model -->
<!-- mdlStudent$predSlopesAttCoreInt <-  -->
<!--   dtStudentSupp$studentWithinBetween %>% -->
<!--   filter(PID %in% dtStudentSupp$studentPltIDs) %>% -->
<!--   select(AttitudesDutch, TIDnum, PID) %>%  -->
<!--   mutate(measure = predict(mdlStudent$lmeSlopesAttCoreInt, -->
<!--                            dtStudentSupp$studentWithinBetween %>% filter(PID %in% dtStudentSupp$studentPltIDs), -->
<!--                            re.form = NA -->
<!--                            ) -->
<!--          ) -->

<!-- ( -->
<!--   mdlStudent$predPltSlopesAttCoreInt <- -->
<!--     ggplot(data = mdlStudent$predSlopesAttCoreInt, aes(x = TIDnum, y = measure)) + -->
<!--     geom_line(alpha = 1, color = "blue") + -->
<!--     geom_line(aes(y = AttitudesDutch), alpha = 1) + -->
<!--     facet_wrap(~ PID, ncol = 6) + -->
<!--     xlab("Time") + -->
<!--     ylab("Outgroup Attitudes") + -->
<!--     theme_Publication() -->
<!-- ) -->
<!-- ggsave( -->
<!--   filename = "Figures/Student_PredictionPlot_SlopesAttCoreInt.png", -->
<!--   mdlStudent$predPltSlopesAttCoreInt, -->
<!--   width = 18, -->
<!--   height = 12, -->
<!--   dpi = 800, -->
<!--   units = "cm", -->
<!--   device = "png" -->
<!-- ) -->
<!-- ``` -->

<!-- Also for Study 2, we checked for alternative models. First, when considering generalized situational core need fulfillment together with whether an intergroup contact took place, we find that there is only a minuscule main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "KeyNeedFullfillment_cwc")`) but a stronger interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "KeyNeedFullfillment_cwc:OutgroupInteraction")`). Together with a significant main effect of having an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "OutgroupInteraction")`), this indicates that it is not key need fulfillment in general --- but key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. This finding is consistent with the results of the previous study, albeit with a slightly weaker effect (likely because of the large number of measurements that did not include an outgroup interaction; For full results see \tblref{tab:robustnessTblLong} and for visual comparison see \fgrref{fig:Robustness}). -->

<!-- ```{r studentOutModelInterceptAttCoreSdt, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlStudentOut$Att$lmeInterceptCoreSdt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtStudentSupp$studentOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- summ( -->
<!--   mdlStudentOut$Att$lmerInterceptCoreSdt <- lmer( -->
<!--     AttitudesDutch ~ KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID), -->
<!--     data = dtStudentSupp$studentOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # 95%CI -->
<!-- mdlStudentOut$Att$lmerInterceptCoreSdtCI <-  -->
<!--   confint(method = "Wald", mdlStudentOut$Att$lmerInterceptCoreSdt) -->

<!-- # To be compared against a model with only the self-determination theory needs -->
<!-- mdlStudentOut$Att$lmeInterceptSdt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtStudentSupp$studentOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- summ( -->
<!--   mdlStudentOut$Att$lmerInterceptSdt <- lmer( -->
<!--     AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID), -->
<!--     data = dtStudentSupp$studentOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # Compare new model to previous steps -->
<!-- anova( -->
<!--   mdlStudentOut$Att$lmeNull, -->
<!--   mdlStudentOut$Att$lmeInterceptSdt, -->
<!--   mdlStudentOut$Att$lmeInterceptCoreSdt -->
<!--   ) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Student: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->
<!-- rm(lmeInterceptCoreRed) -->

<!-- # Save variances -->
<!-- mdlStudentOut$Att$varInterceptCoreSdt <- -->
<!--   lme4::VarCorr(mdlStudentOut$Att$lmeInterceptCoreSdt) -->
<!-- ``` -->
<!-- ```{r studentOutModelSlopesAttCoreSdt, include=FALSE} -->
<!-- # Create and save Model (optimizer needed to reach convergence) -->
<!-- mdlStudentOut$Att$lmeSlopesCoreSdt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ -->
<!--       KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc, -->
<!--     random = ~ 1 + KeyNeedFullfillment_cwc + Competence_cwc + Relatedness_cwc | PID, -->
<!--     control = lmeControl(opt = "optim", maxIter = 100, msMaxIter = 100), -->
<!--     data = dtStudentSupp$studentOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) [+ save model for plotting] -->
<!-- summ( -->
<!--   mdlStudentOut$Att$lmerSlopesCoreSdt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + -->
<!--       (1 + KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID), -->
<!--     data = dtStudentSupp$studentOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # 95%CI -->
<!-- mdlStudentOut$Att$lmerSlopesCoreSdtCI <-  -->
<!--   confint(method = "Wald", mdlStudentOut$Att$lmerSlopesCoreSdt) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlStudentOut$Att$lmeInterceptSdt, -->
<!--       mdlStudentOut$Att$lmeInterceptCoreSdt,  -->
<!--       mdlStudentOut$Att$lmeSlopesCoreSdt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Student: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->

<!-- # model with SDT only -->
<!-- # Create and save Model (optimizer needed to reach convergence) -->
<!-- mdlStudentOut$Att$lmeSlopesSdt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ -->
<!--       Competence_cwc + Autonomy_cwc + Relatedness_cwc, -->
<!--     random = ~ 1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID, -->
<!--     control = lmeControl(opt = "optim"), -->
<!--     data = dtStudentSupp$studentOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) [+ save model for plotting] -->
<!-- summ( -->
<!--   mdlStudentOut$Att$lmerSlopesSdt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       Competence_cwc + Autonomy_cwc + Relatedness_cwc + -->
<!--       (1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID), -->
<!--     data = dtStudentSupp$studentOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlStudentOut$Att$lmeInterceptSdt, -->
<!--       mdlStudentOut$Att$lmeSlopesSdt,  -->
<!--       mdlStudentOut$Att$lmeSlopesCoreSdt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Student: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->


<!-- # Save variances -->
<!-- mdlStudentOut$Att$varSlopesCoreSdt <-  -->
<!--   lme4::VarCorr(mdlStudentOut$Att$lmeSlopesCoreSdt) -->

<!-- # Assumption Checks: -->
<!-- mdlStudentOut$Att$diagSlopesCoreSdt <-  -->
<!--   sjPlot::plot_model(mdlStudentOut$Att$lmerSlopesCoreSdt, type = "diag") -->
<!-- grid.arrange( -->
<!--   mdlStudentOut$Att$diagSlopesCoreSdt[[1]], -->
<!--   mdlStudentOut$Att$diagSlopesCoreSdt[[2]]$`PID`, -->
<!--   mdlStudentOut$Att$diagSlopesCoreSdt[[3]], -->
<!--   mdlStudentOut$Att$diagSlopesCoreSdt[[4]] -->
<!-- ) -->

<!-- # Plot prediction model -->
<!-- mdlStudentOut$Att$predSlopesCoreSdt <-  -->
<!--   dtStudentSupp$studentOutWithinBetween %>% -->
<!--   filter(PID %in% dtStudentSupp$studentOutPltIDs) %>% -->
<!--   select(AttitudesDutch, TIDnum, PID, Autonomy) %>%  -->
<!--   mutate(measure = predict(mdlStudentOut$Att$lmeSlopesCoreSdt, -->
<!--                            dtStudentSupp$studentOutWithinBetween %>% filter(PID %in% dtStudentSupp$studentOutPltIDs), -->
<!--                            re.form = NA -->
<!--                            ) -->
<!--          ) -->

<!-- ( -->
<!--   mdlStudentOut$Att$predPltSlopesCoreSdt <- -->
<!--     ggplot(data = mdlStudentOut$Att$predSlopesCoreSdt, aes(x = TIDnum, y = measure)) + -->
<!--     geom_line(alpha = 1, color = "blue") + -->
<!--     geom_line(aes(y = AttitudesDutch), alpha = 1) + -->
<!--     facet_wrap( ~ PID, ncol = 6) + -->
<!--     xlab("Time") + -->
<!--     ylab("Outgroup Attitudes") + -->
<!--     theme_Publication() -->
<!-- ) -->
<!-- ggsave( -->
<!--   filename = "Figures/StudentOut_PredictionPlot_SlopesAttCoreStd.png", -->
<!--   mdlStudentOut$Att$predPltSlopesCoreSdt, -->
<!--   width = 18, -->
<!--   height = 12, -->
<!--   dpi = 800, -->
<!--   units = "cm", -->
<!--   device = "png" -->
<!-- ) -->

<!-- # Model comparison -->
<!-- studentSdtComp <- -->
<!--   anova( -->
<!--     mdlStudentOut$Att$lmerSlopesSdt,  -->
<!--     mdlStudentOut$Att$lmerSlopesCoreSdt -->
<!--   ) %>% -->
<!--   as.data.frame() -->
<!-- studentSdtCompDf <- studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Df"] -->
<!-- studentSdtCompN <- sapply(ranef(mdlStudentOut$Att$lmerSlopesCoreSdt), nrow) -->
<!-- studentSdtCompChi <- studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2) -->
<!-- studentSdtCompP <- -->
<!--   ifelse(studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001, -->
<!--          "< .001", -->
<!--          paste0("= ", studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3))) -->

<!-- studentSdtCompChiSq <- paste0("$\\chi^2$(", studentSdtCompDf, ", \\textit{N} = ", studentSdtCompN, ") = ", studentSdtCompChi, ", \\textit{p} ", studentSdtCompP) -->
<!-- ``` -->

<!-- In a final step, we again checked whether during the interaction the core situational need remains a meaningful predictor even when taking other fundamental psychological needs into account. We find that the core need fulfillment adds significantly above a model with only the self-determination theory needs (random slopes models; `r studentSdtCompChiSq`). We find that the core need fulfillment explained the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "KeyNeedFullfillment_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all of the three fundamental needs. However, different from the first study, relatedness (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "Relatedness_cwc")`) and autonomy (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "Autonomy_cwc")`) also predicted positive outgroup attitudes in this larger sample. For full results see \tblref{tab:robustnessTblLong} and \fgrref{fig:Robustness}, and Online Supplementary Material A. This means that also within this second sample, the fulfillment of psychological needs during intergroup contact remained a key predictor of positive outgroup attitudes, even when taking into account several alternative models. -->

<!-- \hl{Intend ...} -->

<!-- \hl{Goal-directedness ...} -->

<!-- \hl{Well-being ...} -->

<!-- \subsubsection{Study 3} -->

<!-- ```{r medicalSampleInfo, include=FALSE} -->
<!-- # extract demographic information from eligibility questionnaire -->
<!-- medicalDemographicSupp <-  -->
<!--   dtMedical$raw.eligibility %>% -->
<!--   filter(session %in% dtMedical$full$session) %>% -->
<!--   select(session, nationality, studentBachMa) -->
<!-- # summarize participant characteristics -->

<!-- medicalSampleInfo <- -->
<!--   merge(dtMedical$full, medicalDemographicSupp, by = "session") %>% -->
<!--   mutate(gender = as.factor(ifelse(.$Gender == 1, "women", ifelse(.$Gender == 2, "man", ifelse(.$Gender == 3, "other", NA))))) %>% -->
<!--   group_by(PID) %>% -->
<!--   summarise( -->
<!--     dailiesN = n(),  -->
<!--     morningN = sum(periodMA=="morning"), -->
<!--     afternoonN = sum(periodMA=="afternoon"), -->
<!--     age = age, -->
<!--     gender = gender, -->
<!--     nationality = nationality -->
<!--   ) %>% -->
<!--   distinct -->

<!-- # divide into trait and state -->
<!-- dtMedicalSupp$medicalWithinBetween <-  -->
<!--   MlTraitState( -->
<!--     data = dtMedical$full, -->
<!--     id = "PID", -->
<!--     selection = -->
<!--       c( -->
<!--         "OutgroupInteraction", -->
<!--         "NonOutgroupInteraction", -->
<!--         "OutgroupInteractionM", -->
<!--         "NonOutgroupInteractionM" -->
<!--       ) -->
<!--   ) -->

<!-- ``` -->

<!-- ```{r medicalModelOlsAttFreqQual, include=FALSE} -->
<!-- # create list to store Worker models -->
<!-- mdlMedical <- list() -->
<!-- ``` -->

<!-- ```{r medicalModelMLAttNull, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlMedical$lmerAttNullType <- -->
<!--   lme4::lmer(AttitudesDutch ~ 1 + (1 | PID), -->
<!--              data = dtMedical$full %>% -->
<!--                filter(complete.cases( -->
<!--                  OutgroupInteraction, NonOutgroupInteraction -->
<!--                ))) # use optim if it does not converge -->

<!-- mdlMedical$lmeAttNullType <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ 1, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtMedical$full %>% -->
<!--       filter(complete.cases( -->
<!--         OutgroupInteraction, NonOutgroupInteraction -->
<!--       )), -->
<!--     na.action = na.omit, -->
<!--     control = list(opt = "nlmimb") -->
<!--   ) # use optim if it does not converge -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- # summary(mdlMedical$lmerAttNull) #or with the lme function -->
<!-- summ(mdlMedical$lmerAttNullType, digits = 3) -->

<!-- # Save variances -->
<!-- mdlMedical$varAttNullType <-  -->
<!--   VarCorr(mdlMedical$lmeAttNullType) # save variances -->
<!-- # The estimate of (between-group or Intercept variance, tau_{00}^2): -->
<!-- mdlMedical$tauAttNullType <-  -->
<!--   as.numeric(mdlMedical$varAttNullType[1]) -->
<!-- # and the estimate of (within-group or residual variance, sigma^2) is: -->
<!-- mdlMedical$sigmaAttNullType <-  -->
<!--   as.numeric(mdlMedical$varAttNullType[2]) -->
<!-- # The ICC estimate (between/between+within) is: -->
<!-- mdlMedical$IccAttNullType <- -->
<!--   (as.numeric(mdlMedical$varAttNullType[1]) / (as.numeric(mdlMedical$varAttNullType[1]) + as.numeric(mdlMedical$varAttNullType[2]))) -->
<!-- mdlMedical$IccPercAttNull <- -->
<!--   ((as.numeric(mdlMedical$varAttNullType[1]) / (as.numeric(mdlMedical$varAttNullType[1]) + as.numeric(mdlMedical$varAttNullType[2])))) * 100 -->
<!-- ``` -->

<!-- ```{r medicalOutModelMLAttNull, include=FALSE} -->
<!-- # create empty list to organize models -->
<!-- mdlMedicalOut <-  -->
<!--   list( -->
<!--     Att = list(), -->
<!--     Qlt = list() -->
<!--   ) -->

<!-- # Create and save Model -->
<!-- mdlMedicalOut$Att$lmerNull <- -->
<!--   lme4::lmer(AttitudesDutch ~ 1 + (1 | PID), -->
<!--              data = dtMedicalSupp$medicalOutWithinBetween) # use optim if it does not converge -->
<!-- mdlMedicalOut$Att$lmeNull <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ 1, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtMedicalSupp$medicalOutWithinBetween, -->
<!--     na.action = na.omit, -->
<!--     control = list(opt = "nlmimb") -->
<!--   ) # use optim if it does not converge -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- # summary(Null.Out.ML.r) #or with the lme function -->
<!-- summ(mdlMedicalOut$Att$lmerNull, digits = 3, center = TRUE) -->

<!-- # Save variances -->
<!-- mdlMedicalOut$Att$varNull <-  -->
<!--   VarCorr(mdlMedicalOut$Att$lmeNull) # save variances -->
<!-- # The estimate of (between-group or Intercept variance, tau_{00}^2): -->
<!-- mdlMedicalOut$Att$tauNull <-  -->
<!--   as.numeric(mdlMedicalOut$Att$varNull[1]) -->
<!-- # and the estimate of (within-group or residual variance, sigma^2) is: -->
<!-- mdlMedicalOut$Att$sigmaNull <-  -->
<!--   as.numeric(mdlMedicalOut$Att$varNull[2]) -->
<!-- # The ICC estimate (between/between+within) is: -->
<!-- mdlMedicalOut$Att$IccNull <- -->
<!--   (as.numeric(mdlMedicalOut$Att$varNull[1]) / (as.numeric(mdlMedicalOut$Att$varNull[1]) + as.numeric(mdlMedicalOut$Att$varNull[2]))) -->
<!-- mdlMedicalOut$Att$IccPercNull <- -->
<!--   ((as.numeric(mdlMedicalOut$Att$varNull[1]) / (as.numeric(mdlMedicalOut$Att$varNull[1]) + as.numeric(mdlMedicalOut$Att$varNull[2])))) * 100 -->
<!-- ``` -->

<!-- ```{r medicalOutModelMLQltNull, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlMedicalOut$Qlt$lmerNull <- -->
<!--   lme4::lmer(qualityOverall ~ 1 + (1 | PID),  -->
<!--              data = dtMedicalSupp$medicalOutWithinBetween) # use optim if it does not converge -->
<!-- mdlMedicalOut$Qlt$lmeNull <- -->
<!--   mdlMedicalOut$Qlt$lmeNull <-lme( -->
<!--     qualityOverall ~ 1, -->
<!--     random = ~ 1 | PID, -->
<!--     na.action = na.omit, -->
<!--     data = dtMedicalSupp$medicalOutWithinBetween, -->
<!--     control = list(opt = "nlmimb") -->
<!--   ) # use optim if it does not converge -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- # summary(Null.Out.Qual.ML.r) #or with the lme function -->
<!-- summ(mdlMedicalOut$Qlt$lmerNull, digits = 3) -->

<!-- # Save variances -->
<!-- mdlMedicalOut$Qlt$varNull <-  -->
<!--   VarCorr(mdlMedicalOut$Qlt$lmeNull) # save variances -->
<!-- # The estimate of (between-group or Intercept variance, tau_{00}^2): -->
<!-- mdlMedicalOut$Qlt$tauNull <-  -->
<!--   as.numeric(mdlMedicalOut$Qlt$varNull[1]) -->
<!-- # and the estimate of (within-group or residual variance, sigma^2) is: -->
<!-- mdlMedicalOut$Qlt$sigmaNull <-  -->
<!--   as.numeric(mdlMedicalOut$Qlt$varNull[2]) -->
<!-- # The ICC estimate (between/between+within) is: -->
<!-- mdlMedicalOut$Qlt$IccNull <- -->
<!--   (as.numeric(mdlMedicalOut$Qlt$varNull[1]) / (as.numeric(mdlMedicalOut$Qlt$varNull[1]) + as.numeric(mdlMedicalOut$Qlt$varNull[2]))) -->
<!-- mdlMedicalOut$Qlt$IccPercNull <- -->
<!--   ((as.numeric(mdlMedicalOut$Qlt$varNull[1]) / (as.numeric(mdlMedicalOut$Qlt$varNull[1]) + as.numeric(mdlMedicalOut$Qlt$varNull[2])))) * 100 -->
<!-- ``` -->

<!-- ```{r medicalModelAttNullInt, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlMedical$lmerAttNullInt <- -->
<!--   lme4::lmer(AttitudesDutch ~ 1 + (1 | PID), -->
<!--              data = dtMedical$full %>% -->
<!--                filter(complete.cases( -->
<!--                  OutgroupInteraction -->
<!--                ))) # use optim if it does not converge -->

<!-- mdlMedical$lmeAttNullInt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ 1, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtMedical$full %>% -->
<!--       filter(complete.cases( -->
<!--         OutgroupInteraction -->
<!--       )), -->
<!--     na.action = na.omit, -->
<!--     control = list(opt = "nlmimb") -->
<!--   ) # use optim if it does not converge -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- # summary(mdlMedical$lmerAttNull) #or with the lme function -->
<!-- summ(mdlMedical$lmerAttNullInt, digits = 3) -->
<!-- ``` -->

<!-- ```{r medicalModelInterceptAttCoreInt, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlMedical$lmeInterceptAttCoreInt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ KeyNeedFulfillment_cwc * OutgroupInteraction, -->
<!--     random =  ~ 1 | PID, -->
<!--     na.action = na.omit, -->
<!--     data = dtMedical$full -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- summ( -->
<!--   mdlMedical$lmerInterceptAttCoreInt <- lmer( -->
<!--     AttitudesDutch ~ KeyNeedFulfillment_cwc * OutgroupInteraction + (1 | PID), -->
<!--     data = dtMedical$full -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- mdlMedical$lmerInterceptAttCoreIntCI <-  -->
<!--   confint(method = "Wald", mdlMedical$lmerInterceptAttCoreInt) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlMedical$lmeAttNullInt,  -->
<!--       mdlMedical$lmeInterceptAttCoreInt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   add_rownames(., var = "Description") %>% -->
<!--   mutate(Description = gsub(".*\\$", "", Description)) %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Medical: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = c("l", rep("c", ncol(.)-1)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->

<!-- # Save variances -->
<!-- mdlMedical$varInterceptAttCoreInt <-  -->
<!--   lme4::VarCorr(mdlMedical$lmeInterceptAttCoreInt) -->
<!-- ``` -->

<!-- ```{r medicalModelSlopesAttCoreIntX, include=FALSE} -->
<!-- # Create and save Model (optimizer needed to reach convergence) -->
<!-- mdlMedical$lmeSlopesAttCoreInt <- lme( -->
<!--   AttitudesDutch ~ -->
<!--     KeyNeedFulfillment_cwc * OutgroupInteraction, -->
<!--   random = ~ 1 + KeyNeedFulfillment_cwc + OutgroupInteraction | PID, -->
<!--   control = lmeControl(opt = "optim"), -->
<!--   na.action = na.omit, -->
<!--   data = dtMedical$full -->
<!-- ) -->

<!-- # Get summary with p-values (Satterthwaite's method) [+ save model for plotting] -->
<!-- summ( -->
<!--   mdlMedical$lmerSlopesAttCoreInt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       KeyNeedFulfillment_cwc * OutgroupInteraction + -->
<!--       (1 + KeyNeedFulfillment_cwc + OutgroupInteraction | PID), -->
<!--     data = dtMedical$full -->
<!--   ),  -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- mdlMedical$lmerSlopesAttCoreIntCI <-  -->
<!--   confint(method = "Wald", mdlMedical$lmerSlopesAttCoreInt) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlMedical$lmeAttNullInt,  -->
<!--       mdlMedical$lmeInterceptAttCoreInt, -->
<!--       mdlMedical$lmeSlopesAttCoreInt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   add_rownames(., var = "Description") %>% -->
<!--   mutate(Description = gsub(".*\\$", "", Description)) %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Medical: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->

<!-- # Save variances -->
<!-- mdlMedical$varSlopesAttCoreInt <-  -->
<!--   lme4::VarCorr(mdlMedical$lmeSlopesAttCoreInt) -->

<!-- # Assumption Checks: -->
<!-- mdlMedical$diagSlopesAttCoreInt <- -->
<!--   sjPlot::plot_model(mdlMedical$lmerSlopesAttCoreInt, type = "diag") -->
<!-- grid.arrange( -->
<!--   mdlMedical$diagSlopesAttCoreInt[[1]], -->
<!--   mdlMedical$diagSlopesAttCoreInt[[2]]$`PID`, -->
<!--   mdlMedical$diagSlopesAttCoreInt[[3]], -->
<!--   mdlMedical$diagSlopesAttCoreInt[[4]] -->
<!-- ) -->

<!-- # Plot prediction model -->
<!-- mdlMedical$predSlopesAttCoreInt <-  -->
<!--   dtMedical$full %>% -->
<!--   filter(complete.cases(KeyNeedFulfillment, OutgroupInteraction)) %>% -->
<!--   filter(PID %in% dtMedicalSupp$medicalPltIDs) %>% -->
<!--   select(AttitudesDutch, TIDnum, PID) %>%  -->
<!--   mutate(measure = predict(mdlMedical$lmeSlopesAttCoreInt, -->
<!--                            dtMedical$full %>%  -->
<!--                              filter(complete.cases(KeyNeedFulfillment, OutgroupInteraction)) %>% -->
<!--                              filter(PID %in% dtMedicalSupp$medicalPltIDs), -->
<!--                            re.form = NA -->
<!--                            ) -->
<!--          ) -->

<!-- ( -->
<!--   mdlMedical$predPltSlopesAttCoreInt <- -->
<!--     ggplot(data = mdlMedical$predSlopesAttCoreInt, aes(x = TIDnum, y = measure)) + -->
<!--     geom_line(alpha = 1, color = "blue") + -->
<!--     geom_line(aes(y = AttitudesDutch), alpha = 1) + -->
<!--     facet_wrap(~ PID, ncol = 6) + -->
<!--     xlab("Time") + -->
<!--     ylab("Outgroup Attitudes") + -->
<!--     theme_Publication() -->
<!-- ) -->
<!-- ggsave( -->
<!--   filename = "Figures/Medical_PredictionPlot_SlopesAttCoreInt.png", -->
<!--   mdlMedical$predPltSlopesAttCoreInt, -->
<!--   width = 18, -->
<!--   height = 12, -->
<!--   dpi = 800, -->
<!--   units = "cm", -->
<!--   device = "png" -->
<!-- ) -->
<!-- ``` -->

<!-- As with the previous two studies, we checked for alternative models of the key need fulfillment. First, when considering generalized situational core need fulfillment together with whether an intergroup contact took place, we find that there is no significant main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "KeyNeedFulfillment_cwc")`) but a stronger interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "KeyNeedFulfillment_cwc:OutgroupInteractionYes")`). Together with a significant main effect of having an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "OutgroupInteractionYes")`), this indicates that it is not key need fulfillment in general --- but key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. This finding is consistent with the results of the previous studies. -->

<!-- ```{r medicalOutModelInterceptAttCoreSdt, include=FALSE} -->
<!-- # Create and save Model -->
<!-- mdlMedicalOut$Att$lmeInterceptCoreSdt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtMedicalSupp$medicalOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) -->
<!-- summ( -->
<!--   mdlMedicalOut$Att$lmerInterceptCoreSdt <- lmer( -->
<!--     AttitudesDutch ~ KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID), -->
<!--     data = dtMedicalSupp$medicalOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # To be compared against a model with only the self-determination theory needs -->
<!-- mdlMedicalOut$Att$lmeInterceptSdt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc, -->
<!--     random = ~ 1 | PID, -->
<!--     data = dtMedicalSupp$medicalOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- summ( -->
<!--   mdlMedicalOut$Att$lmerInterceptSdt <- lmer( -->
<!--     AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID), -->
<!--     data = dtMedicalSupp$medicalOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # Compare new model to previous steps -->
<!-- anova( -->
<!--   mdlMedicalOut$Att$lmeInterceptSdt, -->
<!--   mdlMedicalOut$Att$lmeInterceptCoreSdt -->
<!--   ) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Medical: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->

<!-- # Save variances -->
<!-- mdlMedicalOut$Att$varInterceptCoreSdt <- -->
<!--   lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptCoreSdt) -->
<!-- ``` -->

<!-- ```{r medicalOutModelSlopesAttCoreSdt, include=FALSE} -->
<!-- # Create and save Model (optimizer needed to reach convergence) -->
<!-- mdlMedicalOut$Att$lmeSlopesCoreSdt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ -->
<!--       KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc, -->
<!--     random = ~ 1 + KeyNeedFulfillment_cwc + Competence_cwc + Relatedness_cwc | PID, -->
<!--     control = lmeControl(opt = "optim", maxIter = 100, msMaxIter = 100), -->
<!--     data = dtMedicalSupp$medicalOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) [+ save model for plotting] -->
<!-- summ( -->
<!--   mdlMedicalOut$Att$lmerSlopesCoreSdt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + -->
<!--       (1 + KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID), -->
<!--     data = dtMedicalSupp$medicalOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- mdlMedicalOut$Att$lmerSlopesCoreSdtCI <-  -->
<!--   confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesCoreSdt) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlMedicalOut$Att$lmeInterceptSdt, -->
<!--       mdlMedicalOut$Att$lmeInterceptCoreSdt,  -->
<!--       mdlMedicalOut$Att$lmeSlopesCoreSdt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Medical: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->

<!-- # model with SDT only -->
<!-- # Create and save Model (optimizer needed to reach convergence) -->
<!-- mdlMedicalOut$Att$lmeSlopesSdt <- -->
<!--   lme( -->
<!--     AttitudesDutch ~ -->
<!--       Competence_cwc + Autonomy_cwc + Relatedness_cwc, -->
<!--     random = ~ 1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID, -->
<!--     control = lmeControl(opt = "optim"), -->
<!--     data = dtMedicalSupp$medicalOutWithinBetween, -->
<!--     na.action = na.exclude -->
<!--   ) -->

<!-- # Get summary with p-values (Satterthwaite's method) [+ save model for plotting] -->
<!-- summ( -->
<!--   mdlMedicalOut$Att$lmerSlopesSdt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       Competence_cwc + Autonomy_cwc + Relatedness_cwc + -->
<!--       (1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID), -->
<!--     data = dtMedicalSupp$medicalOutWithinBetween -->
<!--   ), -->
<!--   confint = TRUE, -->
<!--   digits = 3 -->
<!-- ) -->

<!-- # Compare new model to previous step -->
<!-- anova(mdlMedicalOut$Att$lmeInterceptSdt, -->
<!--       mdlMedicalOut$Att$lmeSlopesSdt,  -->
<!--       mdlMedicalOut$Att$lmeSlopesCoreSdt) %>% -->
<!--   as.data.frame() %>% -->
<!--   select(-call) %>% -->
<!--   mutate( -->
<!--     L.Ratio = round(L.Ratio, 3), -->
<!--     `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001") -->
<!--   ) %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Medical: Model Comparison", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = rep("c", ncol(.)), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_styling(position = "left") -->


<!-- # Save variances -->
<!-- mdlMedicalOut$Att$varSlopesCoreSdt <-  -->
<!--   lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesCoreSdt) -->

<!-- # Assumption Checks: -->
<!-- mdlMedicalOut$Att$diagSlopesCoreSdt <-  -->
<!--   sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesCoreSdt, type = "diag") -->
<!-- grid.arrange( -->
<!--   mdlMedicalOut$Att$diagSlopesCoreSdt[[1]], -->
<!--   mdlMedicalOut$Att$diagSlopesCoreSdt[[2]]$`PID`, -->
<!--   mdlMedicalOut$Att$diagSlopesCoreSdt[[3]], -->
<!--   mdlMedicalOut$Att$diagSlopesCoreSdt[[4]] -->
<!-- ) -->

<!-- # Plot prediction model -->
<!-- mdlMedicalOut$Att$predSlopesCoreSdt <-  -->
<!--   dtMedicalSupp$medicalOutWithinBetween %>% -->
<!--   filter(complete.cases( -->
<!--     KeyNeedFulfillment, -->
<!--     Autonomy, Competence, Relatedness -->
<!--     )) %>% -->
<!--   filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>% -->
<!--   select(AttitudesDutch, TIDnum, PID, Autonomy, Competence, Relatedness) %>%  -->
<!--   mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesCoreSdt, -->
<!--                            dtMedicalSupp$medicalOutWithinBetween %>%  -->
<!--                              filter(complete.cases( -->
<!--                                KeyNeedFulfillment, -->
<!--                                Autonomy, Competence, Relatedness -->
<!--                              )) %>% -->
<!--                              filter(PID %in% dtMedicalSupp$medicalOutPltIDs), -->
<!--                            re.form = NA -->
<!--                            ) -->
<!--          ) -->

<!-- ( -->
<!--   mdlMedicalOut$Att$predPltSlopesCoreSdt <- -->
<!--     ggplot(data = mdlMedicalOut$Att$predSlopesCoreSdt, aes(x = TIDnum, y = measure)) + -->
<!--     geom_line(alpha = 1, color = "blue") + -->
<!--     geom_line(aes(y = AttitudesDutch), alpha = 1) + -->
<!--     facet_wrap( ~ PID, ncol = 6) + -->
<!--     xlab("Time") + -->
<!--     ylab("Outgroup Attitudes") + -->
<!--     theme_Publication() -->
<!-- ) -->
<!-- ggsave( -->
<!--   filename = "Figures/MedicalOut_PredictionPlot_SlopesAttCoreStd.png", -->
<!--   mdlMedicalOut$Att$predPltSlopesCoreSdt, -->
<!--   width = 18, -->
<!--   height = 12, -->
<!--   dpi = 800, -->
<!--   units = "cm", -->
<!--   device = "png" -->
<!-- ) -->

<!-- # Model comparison -->
<!-- medicalSdtComp <- -->
<!--   anova( -->
<!--     mdlMedicalOut$Att$lmerSlopesSdt,  -->
<!--     mdlMedicalOut$Att$lmerSlopesCoreSdt -->
<!--   ) %>% -->
<!--   as.data.frame() -->
<!-- medicalSdtCompDf <- medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Df"] -->
<!-- medicalSdtCompN <- sapply(ranef(mdlMedicalOut$Att$lmerSlopesCoreSdt), nrow) -->
<!-- medicalSdtCompChi <- medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2) -->
<!-- medicalSdtCompP <- -->
<!--   ifelse(medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001, -->
<!--          "< .001", -->
<!--          paste0("= ", medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3))) -->

<!-- medicalSdtCompChiSq <- paste0("$\\chi^2$(", medicalSdtCompDf, ", \\textit{N} = ", medicalSdtCompN, ") = ", medicalSdtCompChi, ", \\textit{p} ", medicalSdtCompP) -->
<!-- ``` -->

<!-- In a final step, we again checked whether during the interaction the core situational need remains a meaningful predictor even when taking other fundamental psychological needs into account. We find that the core need fulfillment adds additional variance above a model with only the self-determination theory needs (random slopes models; `r medicalSdtCompChiSq`). We find that the core need explains the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "KeyNeedFulfillment_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all of the three fundamental needs. However, similar to the previous study, in this large sample relatedness (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Relatedness_cwc")`), competence (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Competence_cwc")`) and autonomy (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Autonomy_cwc")`) each also predicted positive outgroup attitudes independently. This being said, the regression coefficient for the core need was three times larger (with all scaling being equal). For full results see \tblref{tab:robustnessTblLong} and \fgrref{fig:Robustness} as well as Online Supplementary Material A.  -->

<!-- \hl{Intend ...} -->

<!-- \hl{Goal-directedness ...} -->

<!-- \hl{Well-being ...} -->

<!-- ```{r robustnessTblLong, include=FALSE} -->
<!-- # Table of all robustness checks (w/ and w/out SDT only) -->

<!-- # Full Sample -->
<!-- # Study 1: -->
<!-- robustTblWorkerFull <-  -->
<!--   dtWorkerSupp$workerWithinBetween %>% -->
<!--   select( -->
<!--     AttitudesDutch = thermometerDutch_1, -->
<!--     AttitudesDutch_zwc = thermometerDutch_1_zwc, -->
<!--     CoreNeed_cwc = keyMotiveFulfilled_cwc, -->
<!--     CoreNeed_zwc = keyMotiveFulfilled_zwc, -->
<!--     OutgroupInteraction = OutgroupInteraction, -->
<!--     OutgroupInteraction_zwc = OutgroupInteraction_zwc, -->
<!--     PID = PID -->
<!--   ) -->
<!-- mdlWorkerLmerSlopesAttCoreInt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       CoreNeed_cwc * OutgroupInteraction + -->
<!--       (1 + CoreNeed_cwc + OutgroupInteraction | PID), -->
<!--     data = robustTblWorkerFull -->
<!--   ) -->
<!-- mdlWorkerLmerSlopesAttCoreIntZ <- lmer( -->
<!--     AttitudesDutch_zwc ~ -->
<!--       CoreNeed_zwc * OutgroupInteraction_zwc + -->
<!--       (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID), -->
<!--     data = robustTblWorkerFull -->
<!--   ) -->
<!-- #Study 2: -->
<!-- robustTblStudentFull <-  -->
<!--   dtStudentSupp$studentWithinBetween %>% -->
<!--   select( -->
<!--     AttitudesDutch = AttitudesDutch, -->
<!--     AttitudesDutch_zwc = AttitudesDutch_zwc, -->
<!--     CoreNeed_cwc = KeyNeedFullfillment_cwc, -->
<!--     CoreNeed_zwc = KeyNeedFullfillment_zwc, -->
<!--     OutgroupInteraction = OutgroupInteraction, -->
<!--     OutgroupInteraction_zwc = OutgroupInteraction_zwc,  -->
<!--     PID = PID -->
<!--   ) -->
<!-- mdlStudentLmerSlopesAttCoreInt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       CoreNeed_cwc * OutgroupInteraction + -->
<!--       (1 + CoreNeed_cwc + OutgroupInteraction | PID), -->
<!--     data = robustTblStudentFull -->
<!--   ) -->
<!-- mdlStudentLmerSlopesAttCoreIntZ <- lmer( -->
<!--     AttitudesDutch_zwc ~ -->
<!--       CoreNeed_zwc * OutgroupInteraction_zwc + -->
<!--       (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID), -->
<!--     data = robustTblStudentFull -->
<!--   ) -->
<!-- #Study 3: -->
<!-- robustTblMedicalFull <-  -->
<!--   dtMedicalSupp$medicalWithinBetween %>% -->
<!--   select( -->
<!--     AttitudesDutch = AttitudesDutch, -->
<!--     AttitudesDutch_zwc = AttitudesDutch_zwc, -->
<!--     CoreNeed_cwc = KeyNeedFulfillment_cwc, -->
<!--     CoreNeed_zwc = KeyNeedFulfillment_zwc, -->
<!--     OutgroupInteraction = OutgroupInteraction, -->
<!--     OutgroupInteraction_zwc = OutgroupInteraction_zwc,  -->
<!--     PID = PID -->
<!--   ) -->
<!-- mdlMedicalLmerSlopesAttCoreInt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       CoreNeed_cwc * OutgroupInteraction + -->
<!--       (1 + CoreNeed_cwc + OutgroupInteraction | PID), -->
<!--     #data = dtMedical$full -->
<!--     data = robustTblMedicalFull -->
<!--   ) -->
<!-- mdlMedicalLmerSlopesAttCoreIntZ <- lmer( -->
<!--     AttitudesDutch_zwc ~ -->
<!--       CoreNeed_zwc * OutgroupInteraction_zwc + -->
<!--       (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID), -->
<!--     #data = dtMedical$full -->
<!--     data = robustTblMedicalFull -->
<!--   ) -->

<!-- # SDT -->
<!-- # Study 1: -->
<!-- robustTblWorkerOut <-  -->
<!--   dtWorkerSupp$workerOutWithinBetween %>% -->
<!--   select( -->
<!--     AttitudesDutch = thermometerDutch_1, -->
<!--     AttitudesDutch_zwc = thermometerDutch_1_zwc, -->
<!--     CoreNeed_cwc = keymotive_fulfillemt_1_cwc, -->
<!--     CoreNeed_zwc = keymotive_fulfillemt_1_zwc, -->
<!--     Competence_cwc = competence_1_cwc, -->
<!--     Competence_zwc = competence_1_zwc, -->
<!--     Autonomy_cwc = autonomy_1_cwc, -->
<!--     Autonomy_zwc = autonomy_1_zwc, -->
<!--     Relatedness_cwc = relatedness_1_cwc, -->
<!--     Relatedness_zwc = relatedness_1_zwc, -->
<!--     PID = PID -->
<!--   ) -->
<!-- mdlWorkerOutLmerSlopesCoreSdt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + -->
<!--       (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID), -->
<!--     data = robustTblWorkerOut -->
<!--   ) -->
<!-- mdlWorkerOutLmerSlopesCoreSdtZ <- lmer( -->
<!--     AttitudesDutch_zwc ~ -->
<!--       CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc + -->
<!--       (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID), -->
<!--     data = robustTblWorkerOut -->
<!--   ) -->
<!-- # Study 2: -->
<!-- robustTblStudentOut <-  -->
<!--   dtStudentSupp$studentOutWithinBetween %>% -->
<!--   select( -->
<!--     AttitudesDutch = AttitudesDutch, -->
<!--     AttitudesDutch_zwc = AttitudesDutch_zwc, -->
<!--     CoreNeed_cwc = KeyNeedFullfillment_cwc, -->
<!--     CoreNeed_zwc = KeyNeedFullfillment_zwc, -->
<!--     Competence_cwc = Competence_cwc, -->
<!--     Competence_zwc = Competence_zwc, -->
<!--     Autonomy_cwc = Autonomy_cwc, -->
<!--     Autonomy_zwc = Autonomy_zwc, -->
<!--     Relatedness_cwc = Relatedness_cwc, -->
<!--     Relatedness_zwc = Relatedness_zwc, -->
<!--     PID = PID -->
<!--   ) -->
<!-- mdlStudentOutLmerSlopesCoreSdt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + -->
<!--       (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID), -->
<!--     data = robustTblStudentOut -->
<!--   ) -->
<!-- mdlStudentOutLmerSlopesCoreSdtZ <- lmer( -->
<!--     AttitudesDutch_zwc ~ -->
<!--       CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc + -->
<!--       (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID), -->
<!--     data = robustTblStudentOut -->
<!--   ) -->
<!-- # Study 3: -->
<!-- robustTblMedicalOut <-  -->
<!--   dtMedicalSupp$medicalOutWithinBetween %>% -->
<!--   select( -->
<!--     AttitudesDutch = AttitudesDutch, -->
<!--     AttitudesDutch_zwc = AttitudesDutch_zwc, -->
<!--     CoreNeed_cwc = KeyNeedFulfillment_cwc, -->
<!--     CoreNeed_zwc = KeyNeedFulfillment_zwc, -->
<!--     Competence_cwc = Competence_cwc, -->
<!--     Competence_zwc = Competence_zwc, -->
<!--     Autonomy_cwc = Autonomy_cwc, -->
<!--     Autonomy_zwc = Autonomy_zwc, -->
<!--     Relatedness_cwc = Relatedness_cwc, -->
<!--     Relatedness_zwc = Relatedness_zwc, -->
<!--     PID = PID -->
<!--   ) -->
<!-- mdlMedicalOutLmerSlopesCoreSdt <- lmer( -->
<!--     AttitudesDutch ~ -->
<!--       CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + -->
<!--       (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID), -->
<!--     data = robustTblMedicalOut -->
<!--   ) -->
<!-- mdlMedicalOutLmerSlopesCoreSdtZ <- lmer( -->
<!--     AttitudesDutch_zwc ~ -->
<!--       CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc + -->
<!--       (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID), -->
<!--     data = robustTblMedicalOut -->
<!--   ) -->

<!-- # collect models for table -->
<!-- mdlRobustTblElements <- list( -->
<!--   # full -->
<!--   c(mdlWorkerLmerSlopesAttCoreInt, mdlWorkerLmerSlopesAttCoreIntZ), -->
<!--   c(mdlStudentLmerSlopesAttCoreInt, mdlStudentLmerSlopesAttCoreIntZ), -->
<!--   c(mdlMedicalLmerSlopesAttCoreInt, mdlMedicalLmerSlopesAttCoreIntZ), -->
<!--   # outgroup -->
<!--   c(mdlWorkerOutLmerSlopesCoreSdt, mdlWorkerOutLmerSlopesCoreSdtZ), -->
<!--   c(mdlStudentOutLmerSlopesCoreSdt, mdlStudentOutLmerSlopesCoreSdtZ), -->
<!--   c(mdlMedicalOutLmerSlopesCoreSdt, mdlMedicalOutLmerSlopesCoreSdtZ) -->
<!--   ) -->

<!-- mdlRobustPrep <- list() -->
<!-- for (i in 1:length(mdlRobustTblElements)) { -->
<!--   mdlRobustPrep[[i]] <- lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]]) -->
<!-- } -->

<!-- # manual assembly -->
<!-- shortRobustPrep <- list() -->
<!-- for(i in 1:length(mdlRobustPrep)){ -->
<!--   study <- str_extract(mdlRobustPrep[[i]]$fit$data, "Worker|Student|Medical") -->
<!--   sample <- str_extract(mdlRobustPrep[[i]]$fit$data, "Full|Out") -->
<!--   #dv <- sub(" ~.*", "", mdlRobustPrep[[i]]$fit$formula) -->
<!--   #pred <- gsub("\\(Intercept\\)", "", paste(mdlRobustPrep[[i]]$coeficients$coef, collapse = '')) -->

<!--   name <- paste(study, sample, sep='.') -->
<!--   tmp <- rbind( -->
<!--     mdlRobustPrep[[i]]$coeficients[, c("coef", "B", "Beta")], -->
<!--     data.frame( -->
<!--       coef = "R2Marg_R2Cond", -->
<!--       B = mdlRobustPrep[[i]]$fit$R2Marg_R2Cond, -->
<!--       Beta = "" -->
<!--     ) -->
<!--   ) -->
<!--   shortRobustPrep[[name]] <- tmp -->
<!-- } -->


<!-- tmp <- shortRobustPrep[grepl("Full", names(shortRobustPrep))] -->
<!-- fullRobustTbl <- data.frame(coef = shortRobustPrep$Medical.Full$coef) -->
<!-- for (i in 1:length(tmp)){ -->
<!--   fullRobustTbl <- join(fullRobustTbl, tmp[[i]], by = "coef") -->
<!-- } -->

<!-- tmp <- shortRobustPrep[grepl("Out", names(shortRobustPrep))] -->
<!-- outRobustTbl <- data.frame(coef = shortRobustPrep$Medical.Out$coef) -->
<!-- for (i in 1:length(tmp)){ -->
<!--   outRobustTbl <- join(outRobustTbl, tmp[[i]], by = "coef") -->
<!-- } -->

<!-- robustTblLong <- rbind( -->
<!--   fullRobustTbl, -->
<!--   outRobustTbl -->
<!-- ) -->

<!-- robustTblLong$coef <- mapvalues( -->
<!--   robustTblLong$coef, -->
<!--   from = c( -->
<!--     "R2Marg_R2Cond" -->
<!--   ), -->
<!--   to = c( -->
<!--     "$R^2_{marginal}$ / $R^2_{conditional}$" -->
<!--   ) -->
<!-- ) -->

<!-- mdlTblRobustLong <- robustTblLong %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Robustness Analyses", -->
<!--     #format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = c("l", rep("c", ncol(.)-1)), -->
<!--     escape = FALSE -->
<!--   ) %>% -->
<!--   kable_classic() %>% -->
<!--   add_header_above(., c(" ", "Study 1" = 2, "Study 2" = 2, "Study 3" = 2)) %>% -->
<!--   pack_rows("Contact [Full Sample]", 1, 5) %>% -->
<!--   pack_rows("Self-Determination Theory [Outgroup Interactions only]", 6, 11) %>% -->
<!--   kableExtra::footnote( -->
<!--     ., -->
<!--     general = c("**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"),  -->
<!--     escape = FALSE -->
<!--   ) %>% -->
<!--   kable_styling(latex_options = "scale_down") %>% -->
<!--   #kableExtra::landscape() %>% -->
<!--   gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position -->
<!--   gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position -->
<!--   save_kable("Tables/mdlRobustlong.tex") -->
<!-- ``` -->

<!-- ```{r robustnessTblWide, include=FALSE} -->
<!-- # Wide format -->
<!-- mdlRobustTbl <- data.frame( -->
<!--   coef = c( -->
<!--     sapply(mdlRobustPrep, function(x) x[1]$coeficients$coef) %>% unlist %>% unique, -->
<!--     names(mdlRobustPrep[[1]]$random), -->
<!--     names(mdlRobustPrep[[1]]$fit) -->
<!--   ) -->
<!-- ) -->
<!-- for (i in 1:length(mdlRobustPrep)){ -->
<!--   mdlRobustTbl <- join(mdlRobustTbl, mdlRobustPrep[[i]]$mdlTbl, by = "coef") -->
<!--   #mdlTbl <- merge(mdlRobustTbl, mdlRobustPrep[[i]]$mdlTbl, by = "coef", all = TRUE, sort = FALSE, no.dups = TRUE, suffixes=c("", "")) -->
<!-- } -->

<!-- mdlRobustTblHeader <- data.frame( -->
<!--   data = as.character(mdlRobustTbl[mdlRobustTbl$coef == "data",]), -->
<!--   formula = as.character(mdlRobustTbl[mdlRobustTbl$coef == "formula",]) -->
<!-- ) %>% -->
<!--   filter(data != "", -->
<!--          data != "data") %>% -->
<!--   mutate(study = str_extract(data, "Worker|Student|Medical")) %>% -->
<!--   mutate(study = gsub("Worker", "Study 1", study)) %>% -->
<!--   mutate(study = gsub("Student", "Study 2", study)) %>% -->
<!--   mutate(study = gsub("Medical", "Study 3", study)) %>% -->
<!--   mutate(dv = sub(" ~.*", "", formula)) %>% -->
<!--   mutate(dv = gsub("Raw", " ", dv)) %>% -->
<!--   mutate(pred = str_extract(formula, "CoreNeed|Allport")) %>% -->
<!--   mutate(header = paste(study, pred, sep = " - ")) -->

<!-- mdlRobustTblHeaderFreq <- rbind.data.frame(rle(mdlRobustTblHeader$header)) %>% -->
<!--   mutate(lengths = lengths*2) %>% -->
<!--   rename(names = values, span = lengths) %>% -->
<!--   rbind(c(1, ""), .) %>% -->
<!--   mutate(span = as.numeric(span)) %>% -->
<!--   select(names, span) -->

<!-- mdlRobustTblHeaderDv <- data.frame(names = mdlRobustTblHeader$dv, span = 2) %>%  -->
<!--   mutate(names = as.character(names)) %>% -->
<!--   rbind(c("", 1), .) %>% -->
<!--   mutate(span = as.numeric(span)) -->

<!-- mdlRobustTblHeaderStudy <- rbind.data.frame(rle(mdlRobustTblHeader$study)) %>% -->
<!--   mutate(lengths = lengths*2) %>% -->
<!--   rename(names = values, span = lengths) %>% -->
<!--   rbind(c(1, ""), .) %>% -->
<!--   mutate(span = as.numeric(span)) %>% -->
<!--   select(names, span) -->

<!-- mdlRobustTbl$coef <- mapvalues( -->
<!--   mdlRobustTbl$coef, -->
<!--   from = c( -->
<!--     "sigmaSq", -->
<!--     "tau00", -->
<!--     "tau11", -->
<!--     "rho01", -->
<!--     "rho00", -->
<!--     "R2_marginal", -->
<!--     "R2_conditional",  -->
<!--     "R2Marg_R2Cond" -->
<!--   ), -->
<!--   to = c( -->
<!--     "$\\sigma^2$", -->
<!--     "$\\tau_{00}$", -->
<!--     "$\\tau_{11}$", -->
<!--     "$\\rho_{01}$", -->
<!--     "$\\rho_{00}$", -->
<!--     "$R^2_{marginal}$", -->
<!--     "$R^2_{conditional}$", -->
<!--     "$R^2_{marginal}$ / $R^2_{conditional}$" -->
<!--   ) -->
<!-- ) -->

<!-- # Long Table -->
<!-- mdlTblRobustLong <- mdlRobustTbl %>% -->
<!--   replace(is.na(.), "") %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Robustness Analyses", -->
<!--     #format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = T, -->
<!--     align = c("l", rep("c", ncol(.) - 1)), -->
<!--     escape = FALSE, -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   kable_classic() %>% -->
<!--   add_header_above(., mdlRobustTblHeaderStudy) %>% -->
<!--   add_header_above( -->
<!--     ., -->
<!--     c( -->
<!--       "", -->
<!--       "Contact [Full Sample]" = 6, -->
<!--       "Self-Determination Theory [Outgroup Interactions only]" = 6 -->
<!--     ) -->
<!--   ) %>% -->
<!--   pack_rows("Fixed", 1, 7) %>% -->
<!--   pack_rows("Random", 8, 12) %>% -->
<!--   pack_rows("Fit", 13, 25) %>% -->
<!--   footnote( -->
<!--     general = c("PID = Participant ID number (grouping variable)", -->
<!--                 "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes", -->
<!--                 "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05" -->
<!--     ), -->
<!--     escape = FALSE -->
<!--   ) %>% -->
<!--   gsub("_cwc", "", ., fixed = TRUE)  -->

<!-- # shortened Table -->
<!-- mdlTblRobustShort <- mdlRobustTbl %>% -->
<!--   replace(is.na(.), "") -->
<!-- names(mdlTblRobustShort) <- make.unique(names(mdlTblRobustShort)) -->
<!-- mdlTblRobustShort <- mdlTblRobustShort %>% -->
<!--   filter( -->
<!--     !coef %in% c( -->
<!--       "data", -->
<!--       "formula", -->
<!--       "groupId", -->
<!--       "$R^2_{marginal}$", -->
<!--       "$R^2_{conditional}$", -->
<!--       "logLik", -->
<!--       "deviance" -->
<!--     ) -->
<!--   ) %>% -->
<!--   mutate_all(linebreak) %>% -->
<!--   kbl( -->
<!--     ., -->
<!--     caption = "Robustness Analyses", -->
<!--     format = "latex", -->
<!--     linesep = "", -->
<!--     booktabs = TRUE, -->
<!--     col.names = c("", rep(c("$B$", "$\\beta$"), (ncol(.)-1)/2)), -->
<!--     align = c("l", rep("c", ncol(.) - 1)), -->
<!--     escape = FALSE, -->
<!--     digits = 3 -->
<!--   )  %>% -->
<!--   kable_classic() %>% -->
<!--   add_header_above(., mdlRobustTblHeaderStudy) %>% -->
<!--   add_header_above( -->
<!--     ., -->
<!--     c( -->
<!--       "", -->
<!--       "Contact [Full Sample]" = 6, -->
<!--       "Self-Determination Theory [Outgroup Interactions only]" = 6 -->
<!--     ) -->
<!--   ) %>% -->
<!--   pack_rows("Fixed", 1, 7) %>% -->
<!--   pack_rows("Random", 8, 12) %>% -->
<!--   pack_rows("Fit", 13, 18) %>% -->
<!--   footnote( -->
<!--     general = c("PID = Participant ID number (grouping variable)", -->
<!--                 "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes", -->
<!--                 "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05" -->
<!--     ),  -->
<!--     escape = FALSE -->
<!--   ) %>% -->
<!--   kable_styling(latex_options = "scale_down") %>% -->
<!--   kableExtra::landscape() %>% -->
<!--   gsub("_cwc", "", ., fixed = TRUE)  %>% -->
<!--   gsub("\\makecell[l]", "\\makecell[c]", ., fixed = TRUE) %>% -->
<!--   gsub("\\makecell[r]", "\\makecell[c]", ., fixed = TRUE) %>% -->
<!--   gsub("objVar$", "", ., fixed = TRUE) %>% -->
<!--   gsub("slope_intercept.", "slope.intercept", ., fixed = TRUE) %>% -->
<!--   gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position -->
<!--   gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position -->
<!--   save_kable("Tables/mdlRobustness.tex") -->
<!-- mdlTblRobustShort -->
<!-- ``` -->

<!-- <!-- FIGURES: --> -->

<!-- ```{r metaRobust, include=FALSE} -->
<!-- mdlRobustTblElements <- list( -->
<!--   # full -->
<!--   c(mdlWorkerLmerSlopesAttCoreInt, mdlWorkerLmerSlopesAttCoreIntZ), -->
<!--   c(mdlStudentLmerSlopesAttCoreInt, mdlStudentLmerSlopesAttCoreIntZ), -->
<!--   c(mdlMedicalLmerSlopesAttCoreInt, mdlMedicalLmerSlopesAttCoreIntZ), -->
<!--   # outgroup -->
<!--   c(mdlWorkerOutLmerSlopesCoreSdt, mdlWorkerOutLmerSlopesCoreSdtZ), -->
<!--   c(mdlStudentOutLmerSlopesCoreSdt, mdlStudentOutLmerSlopesCoreSdtZ), -->
<!--   c(mdlMedicalOutLmerSlopesCoreSdt, mdlMedicalOutLmerSlopesCoreSdtZ) -->
<!--   ) -->

<!-- # i =1 -->
<!-- robustMetaTbl <- data.frame() -->
<!-- for (i in 1:length(mdlRobustTblElements)){ -->
<!--   lmerTblTmp <- lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$beta %>% -->
<!--   select( -->
<!--     coef, -->
<!--     B = est, -->
<!--     se, -->
<!--     lwr, -->
<!--     upr, -->
<!--     tval, -->
<!--     Rsq -->
<!--   ) %>% -->
<!--   mutate( -->
<!--     n = lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$N, -->
<!--     m = nrow(.),  -->
<!--     #dv = gsub("Dutch", "", str_extract(lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$formula,".+?(?= ~)")), -->
<!--     sample = str_match(lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$data, "Tbl(.*?)(Full|Out)")[2], -->
<!--     formula = lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$formula, -->
<!--     coef = gsub(":", ".", coef) -->
<!--   ) -->
<!--   robustMetaTbl <- rbind(robustMetaTbl, lmerTblTmp) -->
<!-- } -->

<!-- robustMetaTbl <- robustMetaTbl %>% -->
<!--   arrange(formula, match( -->
<!--     coef, -->
<!--     c( -->
<!--       "CoreNeed_zwc", -->
<!--       "OutgroupInteraction_zwc", -->
<!--       "CoreNeed_zwc.OutgroupInteraction_zwc", -->
<!--       "Autonomy_zwc", -->
<!--       "Competence_zwc", -->
<!--       "Relatedness_zwc" -->
<!--     ) -->
<!--   )) %>%  -->
<!--   mutate(formula = gsub(" \\+ \\(.*", "", formula)) -->

<!-- robustMetaContact <- -->
<!--   metaLmerOut( -->
<!--     lmerDataTbl = robustMetaTbl %>% filter(formula == "AttitudesDutch ~ CoreNeed_cwc * OutgroupInteraction"), -->
<!--     type = "REML", #"FE",  -->
<!--     name = "RobustContact", -->
<!--     title = "Robustness — Contact and Need Fulfillment" -->
<!--   ) -->

<!-- robustMetaSDT <- -->
<!--   metaLmerOut( -->
<!--     lmerDataTbl = robustMetaTbl %>% filter(formula == "AttitudesDutch ~ CoreNeed_cwc + Competence_cwc + Autonomy_cwc +      Relatedness_cwc"), -->
<!--     type = "REML", #"FE",  -->
<!--     name = "RobustSDT", -->
<!--     title = "Robustness — Other Needs" -->
<!--   ) -->
<!-- ``` -->

<!-- ```{r robustForestPltComb, include=FALSE} -->
<!-- effRobust <- rbind( -->
<!--   robustMetaContact$eff %>% -->
<!--     filter(coef != "(Intercept)") %>% -->
<!--     mutate(analysis = "(A) Attitude ~ Contact and Need Fulfillment", -->
<!--            metaId = paste(coef, analysis, sep = ".")) %>% -->
<!--     as.data.frame, -->
<!--   robustMetaSDT$eff %>% -->
<!--     mutate(analysis = "(B) Attitude ~ Other Needs", -->
<!--            metaId = paste(coef, analysis, sep = ".")) %>% -->
<!--     as.data.frame -->
<!-- ) -->

<!-- metaSubForest(effRobust,  -->
<!--               title = "Meta Analysis: Forest Plot Robustness Analysis \n[Parametric]", -->
<!--               filename = "RobustnessComb", -->
<!--               addAbove = 5, -->
<!--               width = 600, -->
<!--               height = 800) -->
<!-- ``` -->
