---
output: latex_fragment
editor_options:
  chunk_output_type: console
bibliography: references.bib
csl: apa.csl
---

```{r setup, include=FALSE}
# R Studio Clean-Up
cat("\014") # clear console
# rm(list=ls()) # clear workspace - use restart R instead [cmd/alt + shift + F10]
gc() # garbage collector

# Install and Load Packages
# !IMPORTANT!
# BEFORE FIRST RENDER:
# To install all relevant packages please run "renv::restore()" (or renv::init() and then initiate from lockfile) in the console before the first use to ensure that all packages are using the correct version.
# to store the packages in a contained library within the project folder: renv::settings$use.cache(FALSE) and add 'RENV_CONFIG_SANDBOX_ENABLED = FALSE' to an '.Renviron' file
lib <- c(
  "rmarkdown",
  "knitr",
  "berryFunctions",
  "remedy",
  "bookdown",
  "brms",
  "psych",
  "ggplot2",
  "ggthemes",
  "purrr",
  "haven",
  "RColorBrewer",
  "plotly",
  "gridExtra",
  "ggpattern",
  "lme4",
  "nlme",
  "jtools",
  "gtsummary",
  "sessioninfo",
  "tibble",
  "pander",
  "devtools",
  "mada",
  "data.table",
  "plyr",
  "dplyr",
  "tidyr",
  "Hmisc",
  "kableExtra",
  "papaja",
  "stringr",
  "stringi",
  "reshape2",
  "lubridate",
  "misty",
  "sjPlot",
  "sjmisc",
  "metafor"
)
invisible(lapply(lib, library, character.only = TRUE))
rm(lib)

# Load Custom Packages
source("./scripts/functions/fun.panel.R")
source("./scripts/functions/themes.R")
source("./scripts/functions/binaryCor.R")
source("./scripts/functions/MlCorMat.R")
source("./scripts/functions/MlTbl.R")
source("./scripts/functions/metaLmer.R")

# Markdown Options
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # set working directory
knitr::opts_knit$get("root.dir") # check working directory
options(
  scipen = 999,
  digits = 4,
  width = 400
) # removes scientific quotation
# knitr::opts_chunk$set(echo = TRUE, cache = F, cache.path = rprojroot::find_rstudio_root_file('cache/')) # cache settings

# Global Chunk Options
knitr::opts_chunk$set(
  fig.width = 12,
  fig.height = 8,
  fig.path = "Figures/",
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)
```

```{r import, include=FALSE}
load("data/wrangled.RData")
# remove accidental surplus to avoid conflicts
# rm(list = ls(pattern = "mdl|medicalSdtComp"))
```

The full surveys are available in our OSF repository \citep{KreienkampMasked2022a} and the full data description is available in Online Supplementary Material A. Correlations and descriptive statistics of the included variables are available in Table \ref{tab:descrFullWide} and Table \ref{tab:descrOutWide}.

\subsection{Additional Materials}

In addition to the measurement of whether or not participants had an intergroup interaction and their situational core need fulfillment, we also measured a set of general psychological needs. 

\subsubsection{General Psychological Needs} In addition to the intergroup contact dummy and situational core need reported in the main text, we included a common measure of three self-determination theory needs \citep[see][]{Downie2008}. The measurement was identical in all three studies. The items were introduced either by “\textit{During the interaction:}” or “\textit{This morning [/afternoon]:}” and measured autonomy (“\textit{I was myself.}”), competence (“\textit{I felt competent.}”), and relatedness (without intergroup contact “\textit{I had a strong need to belong}”; with intergroup contact: “\textit{I shared information about myself.}” and “\textit{The other(s) shared information about themselves.}”). All items were rated on a continuous slider scale from very little (-50) to a great deal (+50).

\subsection{Study 1}

```{r workerSampleInfo, include=FALSE}
# combine education measure
workerOccupation <- 
  dtWorker$clean %>%
  select(PID, starts_with("occupation")) %>%
  mutate_all(as_factor) %>% 
  mutate_all(as.character) %>%
  replace(is.na(.), "") %>%
  unite("occupation", -PID, sep = "/") %>%
  mutate(occupation = trimws(occupation, which = "both", whitespace = "[/]")) %>%
  distinct

# summarize participant characteristics
workerSampleInfo <- 
  dtWorker$clean %>%
  group_by(PID) %>%
  summarise(
    dailiesN = n(), 
    morningN = sum(daytime=="morning"),
    afternoonN = sum(daytime=="afternoon"),
    age = age,
    gender = as_factor(Gender),
    edu = as_factor(education_level),
    nationality = as_factor(nationality)
  ) %>%
  distinct

# add occupation variable
workerSampleInfo <- merge(workerSampleInfo, workerOccupation)
rm(workerOccupation)

# divide into trait and state
dtWorkerSupp$workerWithinBetween <-
  MlTraitState(
    data = dtWorkerSupp$workerInteractionType,
    id = "PID",
    selection =
      c(
        "keyMotiveFulfilled",
        "competence.daily.all",
        "autonomy.daily.all",
        "relatedness.daily.all",
        "thermometerDutch_1",
        "keymotive_fulfillemt_1",
        "competence_1",
        "autonomy_1",
        "relatedness_1", 
        "quality_overall_1", 
        "OutgroupInteraction",
        "NonOutgroupInteraction", 
        "OutgroupInteractionM",
        "NonOutgroupInteractionM"
      )
  )

dtWorkerSupp$workerOutWithinBetween <-
  MlTraitState(
    data = dtWorkerSupp$workerInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection =
      c(
        "keyMotiveFulfilled",
        "thermometerDutch_1",
        "keymotive_fulfillemt_1",
        "competence_1",
        "autonomy_1",
        "relatedness_1", 
        "quality_overall_1"
      )
  )
```


\subsubsection{Results}

```{r workerModelOlsAttFreqQual, include=FALSE}
# create list to store Worker models
mdlWorker <- list()
```

```{r workerModelMLAttNull, include=FALSE}
# Create and save Model
mdlWorker$lmerAttNull <-
  lme4::lmer(thermometerDutch_1 ~ 1 + (1 | PID),
    data = dtWorker$full
  ) # use optim if it does not converge

mdlWorker$lmeAttNull <-
  lme(
    thermometerDutch_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorker$full,
    na.action=na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(lmerWorkerAttNull) #or with the lme function
summ(mdlWorker$lmerAttNull, digits = 3, center = TRUE)

# Save variances
mdlWorker$varAttNull <- 
  VarCorr(mdlWorker$lmeAttNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorker$tauAttNull <- 
  as.numeric(mdlWorker$varAttNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorker$sigmaAttNull <- 
  as.numeric(mdlWorker$varAttNull[2])
# The ICC estimate (between/between+within) is:
mdlWorker$IccAttNull <-
  (as.numeric(mdlWorker$varAttNull[1]) / (as.numeric(mdlWorker$varAttNull[1]) + as.numeric(mdlWorker$varAttNull[2])))
mdlWorker$IccPercAttNull <-
  ((as.numeric(mdlWorker$varAttNull[1]) / (as.numeric(mdlWorker$varAttNull[1]) + as.numeric(mdlWorker$varAttNull[2])))) * 100
```

```{r workerOutModelMLAttNull, include=FALSE}
# create empty list to organize models
mdlWorkerOut <- 
  list(
    Att = list(),
    Qlt = list()
  )

# Create and save Model
mdlWorkerOut$Att$lmerNull <-
  lme4::lmer(thermometerDutch_1 ~ 1 + (1 | PID), 
             data = dtWorkerSupp$workerOutgroupInteraction) # use optim if it does not converge
mdlWorkerOut$Att$lmeNull <-
  lme(
    thermometerDutch_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutgroupInteraction,
    na.action=na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.ML.r) #or with the lme function
summ(mdlWorkerOut$Att$lmerNull, digits = 3, center = TRUE)

# Save variances
mdlWorkerOut$Att$varNull <- 
  VarCorr(mdlWorkerOut$Att$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorkerOut$Att$tauNull <- 
  as.numeric(mdlWorkerOut$Att$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorkerOut$Att$sigmaNull <- 
  as.numeric(mdlWorkerOut$Att$varNull[2])
# The ICC estimate (between/between+within) is:
mdlWorkerOut$Att$IccNull <-
  (as.numeric(mdlWorkerOut$Att$varNull[1]) / (as.numeric(mdlWorkerOut$Att$varNull[1]) + as.numeric(mdlWorkerOut$Att$varNull[2])))
mdlWorkerOut$Att$IccPercNull <-
  ((as.numeric(mdlWorkerOut$Att$varNull[1]) / (as.numeric(mdlWorkerOut$Att$varNull[1]) + as.numeric(mdlWorkerOut$Att$varNull[2])))) * 100
```

```{r workerOutModelMLQltNull, include=FALSE}
# Create and save Model
mdlWorkerOut$Qlt$lmerNull <-
  lme4::lmer(quality_overall_1 ~ 1 + (1 | PID), 
             data = dtWorkerSupp$workerOutWithinBetween) # use optim if it does not converge

mdlWorkerOut$Qlt$lmeNull <-
  mdlWorkerOut$Qlt$lmeNull <- lme(
    quality_overall_1 ~ 1,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action=na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.Qual.ML.r) #or with the lme function
summ(mdlWorkerOut$Qlt$lmerNull, digits = 3)

# Save variances
mdlWorkerOut$Qlt$varNull <- 
  VarCorr(mdlWorkerOut$Qlt$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlWorkerOut$Qlt$tauNull <- 
  as.numeric(mdlWorkerOut$Qlt$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlWorkerOut$Qlt$sigmaNull <- 
  as.numeric(mdlWorkerOut$Qlt$varNull[2])
# The ICC estimate (between/between+within) is:
mdlWorkerOut$Qlt$IccNull <-
  (as.numeric(mdlWorkerOut$Qlt$varNull[1]) / (as.numeric(mdlWorkerOut$Qlt$varNull[1]) + as.numeric(mdlWorkerOut$Qlt$varNull[2])))
mdlWorkerOut$Qlt$IccPercNull <-
  ((as.numeric(mdlWorkerOut$Qlt$varNull[1]) / (as.numeric(mdlWorkerOut$Qlt$varNull[1]) + as.numeric(mdlWorkerOut$Qlt$varNull[2])))) * 100
```


```{r workerModelInterceptAttCoreInt, include=FALSE}
# Create and save Model
mdlWorker$lmeInterceptAttCoreInt <-
  lme(
    thermometerDutch_1 ~ keyMotiveFulfilled_cwc * OutgroupInteraction,
    random =  ~ 1 | PID,
    na.action=na.omit,
    data = dtWorkerSupp$workerWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorker$lmerInterceptAttCoreInt <- lmer(
    thermometerDutch_1 ~ keyMotiveFulfilled_cwc * OutgroupInteraction + (1 | PID),
    data = dtWorkerSupp$workerWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlWorker$lmerInterceptAttCoreIntCI <- 
  confint(method = "Wald", mdlWorker$lmerInterceptAttCoreInt)

# Compare new model to previous step
anova(mdlWorker$lmeAttNull, 
      mdlWorker$lmeInterceptAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorker$varInterceptAttCoreInt <- 
  lme4::VarCorr(mdlWorker$lmeInterceptAttCoreInt)
```
```{r workerModelSlopesAttCoreIntX, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorker$lmeSlopesAttCoreInt <- lme(
  thermometerDutch_1 ~
    keyMotiveFulfilled_cwc * OutgroupInteraction,
  random = ~ 1 + keyMotiveFulfilled_cwc + OutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  na.action=na.omit,
  data = dtWorkerSupp$workerWithinBetween
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorker$lmerSlopesAttCoreInt <- lmer(
    thermometerDutch_1 ~
      keyMotiveFulfilled_cwc * OutgroupInteraction +
      (1 + keyMotiveFulfilled_cwc + OutgroupInteraction | PID),
    data = dtWorkerSupp$workerWithinBetween
  ), 
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlWorker$lmerSlopesAttCoreIntCI <- 
  confint(method = "Wald", mdlWorker$lmerSlopesAttCoreInt)

# Compare new model to previous step
anova(mdlWorker$lmeAttNull, 
      mdlWorker$lmeInterceptAttCoreInt,
      mdlWorker$lmeSlopesAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlWorker$varSlopesAttCoreInt <- 
  lme4::VarCorr(mdlWorker$lmeSlopesAttCoreInt)

# Assumption Checks:
mdlWorker$diagSlopesAttCoreInt <-
  sjPlot::plot_model(mdlWorker$lmerSlopesAttCoreInt, type = "diag")
grid.arrange(
  mdlWorker$diagSlopesAttCoreInt[[1]],
  mdlWorker$diagSlopesAttCoreInt[[2]]$`PID`,
  mdlWorker$diagSlopesAttCoreInt[[3]],
  mdlWorker$diagSlopesAttCoreInt[[4]]
)

# Plot prediction model
mdlWorker$predSlopesAttCoreInt <- 
  dtWorkerSupp$workerWithinBetween %>%
  select(thermometerDutch_1, session, PID) %>% 
  mutate(measure = predict(mdlWorker$lmeSlopesAttCoreInt,
                           dtWorkerSupp$workerWithinBetween,
                           re.form = NA
                           )
         )

(
  mdlWorker$predPltSlopesAttCoreInt <-
    ggplot(data = mdlWorker$predSlopesAttCoreInt, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Worker_PredictionPlot_SlopesAttCoreInt.png",
  mdlWorker$predPltSlopesAttCoreInt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

To build further confidence in our results, we assessed two additional models that might offer alternative explanations. First, to ensure that the effect of core need fulfillment is specific to an actual contact, we compared the effect to core need fulfillment in situations without an intergroup contact. For this, we analyzed the generalized situational core need fulfillment (either during a contact or about the daytime in general) and tested whether the effect differed during experience sampling measurements with and without outgroup contacts. We found no main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlWorker$lmeSlopesAttCoreInt, lmerCI = mdlWorker$lmerSlopesAttCoreIntCI, varName = "keyMotiveFulfilled_cwc")`) but a significant interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlWorker$lmeSlopesAttCoreInt, lmerCI = mdlWorker$lmerSlopesAttCoreIntCI, varName = "keyMotiveFulfilled_cwc:OutgroupInteraction")`; also see Table \ref{tab:robustnessTblLong} and Figure \ref{fig:Robustness}). Together with a significant main effect of having an outgroup contact, this indicates that it is not key need fulfillment in general --- but only key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. 

```{r workerOutModelInterceptAttCoreSdt, include=FALSE}
# Create and save Model
mdlWorkerOut$Att$lmeInterceptCoreSdt <-
  lme(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlWorkerOut$Att$lmerInterceptCoreSdt <- lmer(
    thermometerDutch_1 ~ keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc + (1 | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# To be compared against a model with only the self-determination theory needs
mdlWorkerOut$Att$lmeInterceptSdt <-
  lme(
    thermometerDutch_1 ~ competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 | PID,
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

summ(
  mdlWorkerOut$Att$lmerInterceptSdt <- lmer(
    thermometerDutch_1 ~ competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc + (1 | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous steps
anova(
  mdlWorkerOut$Att$lmeInterceptSdt,
  mdlWorkerOut$Att$lmeInterceptCoreSdt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")
rm(lmeInterceptCoreRed)

# Save variances
mdlWorkerOut$Att$varInterceptCoreSdt <-
  lme4::VarCorr(mdlWorkerOut$Att$lmeInterceptCoreSdt)
```
```{r workerOutModelSlopesAttCoreSdt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesCoreSdt <-
  lme(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 + keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesCoreSdt <- lmer(
    thermometerDutch_1 ~
      keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc +
      (1 + keymotive_fulfillemt_1_cwc + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlWorkerOut$Att$lmerSlopesCoreSdtCI <- 
  confint(method = "Wald", mdlWorkerOut$Att$lmerSlopesCoreSdt)

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeInterceptSdt,
      mdlWorkerOut$Att$lmeInterceptCoreSdt, 
      mdlWorkerOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# model with SDT only
# Create and save Model (optimizer needed to reach convergence)
mdlWorkerOut$Att$lmeSlopesSdt <-
  lme(
    thermometerDutch_1 ~
      competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc,
    random = ~ 1 + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtWorkerSupp$workerOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlWorkerOut$Att$lmerSlopesSdt <- lmer(
    thermometerDutch_1 ~
      competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc +
      (1 + competence_1_cwc + autonomy_1_cwc + relatedness_1_cwc | PID),
    data = dtWorkerSupp$workerOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous step
anova(mdlWorkerOut$Att$lmeInterceptSdt,
      mdlWorkerOut$Att$lmeSlopesSdt, 
      mdlWorkerOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Worker: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")


# Save variances
mdlWorkerOut$Att$varSlopesCoreSdt <- 
  lme4::VarCorr(mdlWorkerOut$Att$lmeSlopesCoreSdt)

# Assumption Checks:
mdlWorkerOut$Att$diagSlopesCoreSdt <- 
  sjPlot::plot_model(mdlWorkerOut$Att$lmerSlopesCoreSdt, type = "diag")
grid.arrange(
  mdlWorkerOut$Att$diagSlopesCoreSdt[[1]],
  mdlWorkerOut$Att$diagSlopesCoreSdt[[2]]$`PID`,
  mdlWorkerOut$Att$diagSlopesCoreSdt[[3]],
  mdlWorkerOut$Att$diagSlopesCoreSdt[[4]]
)

# Plot prediction model
mdlWorkerOut$Att$predSlopesCoreSdt <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  filter(!is.na(autonomy_1)) %>%
  select(thermometerDutch_1, session, PID, autonomy_1) %>% 
  mutate(measure = predict(mdlWorkerOut$Att$lmeSlopesCoreSdt,
                           dtWorkerSupp$workerOutWithinBetween %>% filter(!is.na(autonomy_1)),
                           re.form = NA
                           )
         )

(
  mdlWorkerOut$Att$predPltSlopesCoreSdt <-
    ggplot(data = mdlWorkerOut$Att$predSlopesCoreSdt, aes(x = session, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = thermometerDutch_1), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/WorkerOut_PredictionPlot_SlopesAttCoreStd.png",
  mdlWorkerOut$Att$predPltSlopesCoreSdt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

# Model comparison
workerSdtComp <-
  anova(
    mdlWorkerOut$Att$lmerSlopesSdt, 
    mdlWorkerOut$Att$lmerSlopesCoreSdt
  ) %>%
  as.data.frame()
workerSdtCompDf <- workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Df"]
workerSdtCompN <- sapply(ranef(mdlWorkerOut$Att$lmerSlopesCoreSdt), nrow)
workerSdtCompChi <- workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2)
workerSdtCompP <-
  ifelse(workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001,
         "< .001",
         paste0("= ", workerSdtComp["mdlWorkerOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3)))

workerSdtCompChiSq <- paste0("$\\chi^2$(", workerSdtCompDf, ", \\textit{N} = ", workerSdtCompN, ") = ", workerSdtCompChi, ", \\textit{p} ", workerSdtCompP)
```

In a final step, we controlled for other fundamental psychological needs during the contact. We focus on the three commonly considered self-determination needs (SDT): competence, autonomy, and relatedness. We find that the core need fulfillment adds significantly above a model with only the self-determination theory needs (random slopes models; `r workerSdtCompChiSq`). We also find that next to relatedness (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreSdt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreSdtCI, varName = "relatedness_1_cwc")`), the core need explains the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlWorkerOut$Att$lmeSlopesCoreSdt, lmerCI = mdlWorkerOut$Att$lmerSlopesCoreSdtCI, varName = "keymotive_fulfillemt_1_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all three fundamental needs (competence and autonomy needs turning non-significant; all \textit{b} < `r coef(summary(mdlWorkerOut$Att$lmeSlopesCoreSdt))[c("competence_1_cwc", "autonomy_1_cwc"),"Value"] %>% max %>% round(2) %>% format(nsmall=2)`, all \textit{p} > `r coef(summary(mdlWorkerOut$Att$lmeSlopesCoreSdt))[c("competence_1_cwc", "autonomy_1_cwc"),"p-value"] %>% min %>% round(3) %>% format(nsmall=3)`). For full results see see Table \ref{tab:robustnessTblLong}, Figure \ref{fig:Robustness}, and Online Supplementary Material A. There is, thus, considerable evidence lending confidence to the stability and relevance of psychological need fulfillment as a predictor of positive outgroup attitudes for natural intergroup contacts.

\subsection{Study 2}

```{r studentSampleInfo, include=FALSE}
# summarize participant characteristics
studentSampleInfo <- 
  dtStudents$full %>%
  mutate(gender = as.factor(ifelse(.$Gender == 1, "women", ifelse(.$Gender == 2, "man", ifelse(.$Gender == 3, "other", NA))))) %>%
  group_by(PID) %>%
  summarise(
    dailiesN = n(), 
    morningN = sum(periodMA=="morning"),
    afternoonN = sum(periodMA=="afternoon"),
    age = age,
    gender = gender,
    nationality = nationality
  ) %>%
  distinct

# look at frequencies of characteristics 
table(studentSampleInfo$gender)
table(as.character(studentSampleInfo$nationality))

# divide into trait and state
dtStudentSupp$studentWithinBetween <-
  MlTraitState(
    data = dtStudentSupp$studentInteractionType,
    id = "PID",
    selection =
      c(
        "KeyNeedFullfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AttitudesDutch",
        "quality_overall",
        "OutgroupInteraction",
        "NonOutgroupInteraction",
        "OutgroupInteractionM",
        "NonOutgroupInteractionM"
      )
  )
dtStudentSupp$studentOutWithinBetween <-
  MlTraitState(
    data = dtStudentSupp$studentInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection =
      c(
        "KeyNeedFullfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AttitudesDutch",
        "quality_overall"
      )
  )
```


\subsubsection{Results}

```{r studentModelOlsAttFreqQual, include=FALSE}
# create list to store Worker models
mdlStudent <- list()
```

```{r studentModelMLAttNull, include=FALSE}
# Create and save Model
mdlStudent$lmerAttNull <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
    data = dtStudents$full
  ) # use optim if it does not converge

mdlStudent$lmeAttNull <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtStudents$full,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(mdlStudent$lmerAttNull) #or with the lme function
summ(mdlStudent$lmerAttNull, digits = 3)

# Save variances
mdlStudent$varAttNull <- 
  VarCorr(mdlStudent$lmeAttNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlStudent$tauAttNull <- 
  as.numeric(mdlStudent$varAttNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlStudent$sigmaAttNull <- 
  as.numeric(mdlStudent$varAttNull[2])
# The ICC estimate (between/between+within) is:
mdlStudent$IccAttNull <-
  (as.numeric(mdlStudent$varAttNull[1]) / (as.numeric(mdlStudent$varAttNull[1]) + as.numeric(mdlStudent$varAttNull[2])))
mdlStudent$IccPercAttNull <-
  ((as.numeric(mdlStudent$varAttNull[1]) / (as.numeric(mdlStudent$varAttNull[1]) + as.numeric(mdlStudent$varAttNull[2])))) * 100
```

```{r studentOutModelMLAttNull, include=FALSE}
# create empty list to organize models
mdlStudentOut <- 
  list(
    Att = list(),
    Qlt = list()
  )

# Create and save Model
mdlStudentOut$Att$lmerNull <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID), 
             data = dtStudentSupp$studentOutgroupInteraction) # use optim if it does not converge
mdlStudentOut$Att$lmeNull <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutgroupInteraction,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.ML.r) #or with the lme function
summ(mdlStudentOut$Att$lmerNull, digits = 3, center = TRUE)

# Save variances
mdlStudentOut$Att$varNull <- 
  VarCorr(mdlStudentOut$Att$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlStudentOut$Att$tauNull <- 
  as.numeric(mdlStudentOut$Att$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlStudentOut$Att$sigmaNull <- 
  as.numeric(mdlStudentOut$Att$varNull[2])
# The ICC estimate (between/between+within) is:
mdlStudentOut$Att$IccNull <-
  (as.numeric(mdlStudentOut$Att$varNull[1]) / (as.numeric(mdlStudentOut$Att$varNull[1]) + as.numeric(mdlStudentOut$Att$varNull[2])))
mdlStudentOut$Att$IccPercNull <-
  ((as.numeric(mdlStudentOut$Att$varNull[1]) / (as.numeric(mdlStudentOut$Att$varNull[1]) + as.numeric(mdlStudentOut$Att$varNull[2])))) * 100
```

```{r studentOutModelMLQltNull, include=FALSE}
# Create and save Model
mdlStudentOut$Qlt$lmerNull <-
  lme4::lmer(quality_overall ~ 1 + (1 | PID), 
             data = dtStudentSupp$studentOutWithinBetween) # use optim if it does not converge
mdlStudentOut$Qlt$lmeNull <-
  mdlStudentOut$Qlt$lmeNull <-lme(
    quality_overall ~ 1,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.Qual.ML.r) #or with the lme function
summ(mdlStudentOut$Qlt$lmerNull, digits = 3)

# Save variances
mdlStudentOut$Qlt$varNull <- 
  VarCorr(mdlStudentOut$Qlt$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlStudentOut$Qlt$tauNull <- 
  as.numeric(mdlStudentOut$Qlt$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlStudentOut$Qlt$sigmaNull <- 
  as.numeric(mdlStudentOut$Qlt$varNull[2])
# The ICC estimate (between/between+within) is:
mdlStudentOut$Qlt$IccNull <-
  (as.numeric(mdlStudentOut$Qlt$varNull[1]) / (as.numeric(mdlStudentOut$Qlt$varNull[1]) + as.numeric(mdlStudentOut$Qlt$varNull[2])))
mdlStudentOut$Qlt$IccPercNull <-
  ((as.numeric(mdlStudentOut$Qlt$varNull[1]) / (as.numeric(mdlStudentOut$Qlt$varNull[1]) + as.numeric(mdlStudentOut$Qlt$varNull[2])))) * 100
```

```{r studentModelInterceptAttCoreInt, include=FALSE}
# Create and save Model
mdlStudent$lmeInterceptAttCoreInt <-
  lme(
    AttitudesDutch ~ KeyNeedFullfillment_cwc * OutgroupInteraction,
    random =  ~ 1 | PID,
    data = dtStudentSupp$studentWithinBetween
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudent$lmerInterceptAttCoreInt <- lmer(
    AttitudesDutch ~ KeyNeedFullfillment_cwc * OutgroupInteraction + (1 | PID),
    data = dtStudentSupp$studentWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudent$lmerInterceptAttCoreIntCI <- 
  confint(method = "Wald", mdlStudent$lmerInterceptAttCoreInt)

# Compare new model to previous step
anova(mdlStudent$lmeAttNull, 
      mdlStudent$lmeInterceptAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudent$varInterceptAttCoreInt <- 
  lme4::VarCorr(mdlStudent$lmeInterceptAttCoreInt)
```
```{r studentModelSlopesAttCoreIntX, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudent$lmeSlopesAttCoreInt <- lme(
  AttitudesDutch ~
    KeyNeedFullfillment_cwc * OutgroupInteraction,
  random = ~ 1 + KeyNeedFullfillment_cwc + OutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  data = dtStudentSupp$studentWithinBetween
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudent$lmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc * OutgroupInteraction +
      (1 + KeyNeedFullfillment_cwc + OutgroupInteraction | PID),
    data = dtStudentSupp$studentWithinBetween
  ), 
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudent$lmerSlopesAttCoreIntCI <- 
  confint(method = "Wald", mdlStudent$lmerSlopesAttCoreInt)

# Compare new model to previous step
anova(mdlStudent$lmeAttNull, 
      mdlStudent$lmeInterceptAttCoreInt,
      mdlStudent$lmeSlopesAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlStudent$varSlopesAttCoreInt <- 
  lme4::VarCorr(mdlStudent$lmeSlopesAttCoreInt)

# Assumption Checks:
mdlStudent$diagSlopesAttCoreInt <-
  sjPlot::plot_model(mdlStudent$lmerSlopesAttCoreInt, type = "diag")
grid.arrange(
  mdlStudent$diagSlopesAttCoreInt[[1]],
  mdlStudent$diagSlopesAttCoreInt[[2]]$`PID`,
  mdlStudent$diagSlopesAttCoreInt[[3]],
  mdlStudent$diagSlopesAttCoreInt[[4]]
)

# Plot prediction model
mdlStudent$predSlopesAttCoreInt <- 
  dtStudentSupp$studentWithinBetween %>%
  filter(PID %in% dtStudentSupp$studentPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlStudent$lmeSlopesAttCoreInt,
                           dtStudentSupp$studentWithinBetween %>% filter(PID %in% dtStudentSupp$studentPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudent$predPltSlopesAttCoreInt <-
    ggplot(data = mdlStudent$predSlopesAttCoreInt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Student_PredictionPlot_SlopesAttCoreInt.png",
  mdlStudent$predPltSlopesAttCoreInt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

Also for Study 2, we checked for alternative models. First, when considering generalized situational core need fulfillment together with whether an intergroup contact took place, we find that there is only a minuscule main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "KeyNeedFullfillment_cwc")`) but a stronger interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "KeyNeedFullfillment_cwc:OutgroupInteraction")`). Together with a significant main effect of having an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudent$lmeSlopesAttCoreInt, lmerCI = mdlStudent$lmerSlopesAttCoreIntCI, varName = "OutgroupInteraction")`), this indicates that it is not key need fulfillment in general --- but key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. This finding is consistent with the results of the previous study, albeit with a slightly weaker effect (likely because of the large number of measurements that did not include an outgroup interaction; For full results see Table \ref{tab:intergroupNeedsTblLong} and for visual comparison see Figure \ref{fig:AllportNeedFulfillment}).

```{r studentOutModelInterceptAttCoreSdt, include=FALSE}
# Create and save Model
mdlStudentOut$Att$lmeInterceptCoreSdt <-
  lme(
    AttitudesDutch ~ KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlStudentOut$Att$lmerInterceptCoreSdt <- lmer(
    AttitudesDutch ~ KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudentOut$Att$lmerInterceptCoreSdtCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerInterceptCoreSdt)

# To be compared against a model with only the self-determination theory needs
mdlStudentOut$Att$lmeInterceptSdt <-
  lme(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

summ(
  mdlStudentOut$Att$lmerInterceptSdt <- lmer(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous steps
anova(
  mdlStudentOut$Att$lmeNull,
  mdlStudentOut$Att$lmeInterceptSdt,
  mdlStudentOut$Att$lmeInterceptCoreSdt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")
rm(lmeInterceptCoreRed)

# Save variances
mdlStudentOut$Att$varInterceptCoreSdt <-
  lme4::VarCorr(mdlStudentOut$Att$lmeInterceptCoreSdt)
```
```{r studentOutModelSlopesAttCoreSdt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Att$lmeSlopesCoreSdt <-
  lme(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + KeyNeedFullfillment_cwc + Competence_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim", maxIter = 100, msMaxIter = 100),
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Att$lmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + KeyNeedFullfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# 95%CI
mdlStudentOut$Att$lmerSlopesCoreSdtCI <- 
  confint(method = "Wald", mdlStudentOut$Att$lmerSlopesCoreSdt)

# Compare new model to previous step
anova(mdlStudentOut$Att$lmeInterceptSdt,
      mdlStudentOut$Att$lmeInterceptCoreSdt, 
      mdlStudentOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# model with SDT only
# Create and save Model (optimizer needed to reach convergence)
mdlStudentOut$Att$lmeSlopesSdt <-
  lme(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtStudentSupp$studentOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlStudentOut$Att$lmerSlopesSdt <- lmer(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtStudentSupp$studentOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous step
anova(mdlStudentOut$Att$lmeInterceptSdt,
      mdlStudentOut$Att$lmeSlopesSdt, 
      mdlStudentOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Student: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")


# Save variances
mdlStudentOut$Att$varSlopesCoreSdt <- 
  lme4::VarCorr(mdlStudentOut$Att$lmeSlopesCoreSdt)

# Assumption Checks:
mdlStudentOut$Att$diagSlopesCoreSdt <- 
  sjPlot::plot_model(mdlStudentOut$Att$lmerSlopesCoreSdt, type = "diag")
grid.arrange(
  mdlStudentOut$Att$diagSlopesCoreSdt[[1]],
  mdlStudentOut$Att$diagSlopesCoreSdt[[2]]$`PID`,
  mdlStudentOut$Att$diagSlopesCoreSdt[[3]],
  mdlStudentOut$Att$diagSlopesCoreSdt[[4]]
)

# Plot prediction model
mdlStudentOut$Att$predSlopesCoreSdt <- 
  dtStudentSupp$studentOutWithinBetween %>%
  filter(PID %in% dtStudentSupp$studentOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID, Autonomy) %>% 
  mutate(measure = predict(mdlStudentOut$Att$lmeSlopesCoreSdt,
                           dtStudentSupp$studentOutWithinBetween %>% filter(PID %in% dtStudentSupp$studentOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlStudentOut$Att$predPltSlopesCoreSdt <-
    ggplot(data = mdlStudentOut$Att$predSlopesCoreSdt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/StudentOut_PredictionPlot_SlopesAttCoreStd.png",
  mdlStudentOut$Att$predPltSlopesCoreSdt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

# Model comparison
studentSdtComp <-
  anova(
    mdlStudentOut$Att$lmerSlopesSdt, 
    mdlStudentOut$Att$lmerSlopesCoreSdt
  ) %>%
  as.data.frame()
studentSdtCompDf <- studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Df"]
studentSdtCompN <- sapply(ranef(mdlStudentOut$Att$lmerSlopesCoreSdt), nrow)
studentSdtCompChi <- studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2)
studentSdtCompP <-
  ifelse(studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001,
         "< .001",
         paste0("= ", studentSdtComp["mdlStudentOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3)))

studentSdtCompChiSq <- paste0("$\\chi^2$(", studentSdtCompDf, ", \\textit{N} = ", studentSdtCompN, ") = ", studentSdtCompChi, ", \\textit{p} ", studentSdtCompP)
```

In a final step, we again checked whether during the interaction the core situational need remains a meaningful predictor even when taking other fundamental psychological needs into account. We find that the core need fulfillment adds significantly above a model with only the self-determination theory needs (random slopes models; `r studentSdtCompChiSq`). We find that the core need fulfillment explained the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "KeyNeedFullfillment_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all of the three fundamental needs. However, different from the first study, relatedness (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "Relatedness_cwc")`) and autonomy (`r MlCoeffLatex(lmeMdl = mdlStudentOut$Att$lmeSlopesCoreSdt, lmerCI = mdlStudentOut$Att$lmerSlopesCoreSdtCI, varName = "Autonomy_cwc")`) also predicted positive outgroup attitudes in this larger sample. For full results see Table \ref{tab:intergroupNeedsTblLong}, Figure \ref{fig:Robustness}, and Online Supplementary Material A. This means that also within this second sample, the fulfillment of psychological needs during intergroup contact remained a key predictor of positive outgroup attitudes, even when taking into account several alternative models.

\subsection{Study 3}

```{r medicalSampleInfo, include=FALSE}
# extract demographic information from eligibility questionnaire
medicalDemographicSupp <- 
  dtMedical$raw.eligibility %>%
  filter(session %in% dtMedical$full$session) %>%
  select(session, nationality, studentBachMa)
# summarize participant characteristics

medicalSampleInfo <-
  merge(dtMedical$full, medicalDemographicSupp, by = "session") %>%
  mutate(gender = as.factor(ifelse(.$Gender == 1, "women", ifelse(.$Gender == 2, "man", ifelse(.$Gender == 3, "other", NA))))) %>%
  group_by(PID) %>%
  summarise(
    dailiesN = n(), 
    morningN = sum(periodMA=="morning"),
    afternoonN = sum(periodMA=="afternoon"),
    age = age,
    gender = gender,
    nationality = nationality
  ) %>%
  distinct

# divide into trait and state
dtMedicalSupp$medicalWithinBetween <- 
  MlTraitState(
    data = dtMedical$full,
    id = "PID",
    selection =
      c(
        "OutgroupInteraction",
        "NonOutgroupInteraction",
        "OutgroupInteractionM",
        "NonOutgroupInteractionM"
      )
  )

```

\subsubsection{Results}

```{r medicalModelOlsAttFreqQual, include=FALSE}
# create list to store Worker models
mdlMedical <- list()
```

```{r medicalModelMLAttNull, include=FALSE}
# Create and save Model
mdlMedical$lmerAttNullType <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
             data = dtMedical$full %>%
               filter(complete.cases(
                 OutgroupInteraction, NonOutgroupInteraction
               ))) # use optim if it does not converge

mdlMedical$lmeAttNullType <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtMedical$full %>%
      filter(complete.cases(
        OutgroupInteraction, NonOutgroupInteraction
      )),
    na.action = na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(mdlMedical$lmerAttNull) #or with the lme function
summ(mdlMedical$lmerAttNullType, digits = 3)

# Save variances
mdlMedical$varAttNullType <- 
  VarCorr(mdlMedical$lmeAttNullType) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlMedical$tauAttNullType <- 
  as.numeric(mdlMedical$varAttNullType[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlMedical$sigmaAttNullType <- 
  as.numeric(mdlMedical$varAttNullType[2])
# The ICC estimate (between/between+within) is:
mdlMedical$IccAttNullType <-
  (as.numeric(mdlMedical$varAttNullType[1]) / (as.numeric(mdlMedical$varAttNullType[1]) + as.numeric(mdlMedical$varAttNullType[2])))
mdlMedical$IccPercAttNull <-
  ((as.numeric(mdlMedical$varAttNullType[1]) / (as.numeric(mdlMedical$varAttNullType[1]) + as.numeric(mdlMedical$varAttNullType[2])))) * 100
```

```{r medicalOutModelMLAttNull, include=FALSE}
# create empty list to organize models
mdlMedicalOut <- 
  list(
    Att = list(),
    Qlt = list()
  )

# Create and save Model
mdlMedicalOut$Att$lmerNull <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
             data = dtMedicalSupp$medicalOutWithinBetween) # use optim if it does not converge
mdlMedicalOut$Att$lmeNull <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.ML.r) #or with the lme function
summ(mdlMedicalOut$Att$lmerNull, digits = 3, center = TRUE)

# Save variances
mdlMedicalOut$Att$varNull <- 
  VarCorr(mdlMedicalOut$Att$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlMedicalOut$Att$tauNull <- 
  as.numeric(mdlMedicalOut$Att$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlMedicalOut$Att$sigmaNull <- 
  as.numeric(mdlMedicalOut$Att$varNull[2])
# The ICC estimate (between/between+within) is:
mdlMedicalOut$Att$IccNull <-
  (as.numeric(mdlMedicalOut$Att$varNull[1]) / (as.numeric(mdlMedicalOut$Att$varNull[1]) + as.numeric(mdlMedicalOut$Att$varNull[2])))
mdlMedicalOut$Att$IccPercNull <-
  ((as.numeric(mdlMedicalOut$Att$varNull[1]) / (as.numeric(mdlMedicalOut$Att$varNull[1]) + as.numeric(mdlMedicalOut$Att$varNull[2])))) * 100
```

```{r medicalOutModelMLQltNull, include=FALSE}
# Create and save Model
mdlMedicalOut$Qlt$lmerNull <-
  lme4::lmer(qualityOverall ~ 1 + (1 | PID), 
             data = dtMedicalSupp$medicalOutWithinBetween) # use optim if it does not converge
mdlMedicalOut$Qlt$lmeNull <-
  mdlMedicalOut$Qlt$lmeNull <-lme(
    qualityOverall ~ 1,
    random = ~ 1 | PID,
    na.action = na.omit,
    data = dtMedicalSupp$medicalOutWithinBetween,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(Null.Out.Qual.ML.r) #or with the lme function
summ(mdlMedicalOut$Qlt$lmerNull, digits = 3)

# Save variances
mdlMedicalOut$Qlt$varNull <- 
  VarCorr(mdlMedicalOut$Qlt$lmeNull) # save variances
# The estimate of (between-group or Intercept variance, tau_{00}^2):
mdlMedicalOut$Qlt$tauNull <- 
  as.numeric(mdlMedicalOut$Qlt$varNull[1])
# and the estimate of (within-group or residual variance, sigma^2) is:
mdlMedicalOut$Qlt$sigmaNull <- 
  as.numeric(mdlMedicalOut$Qlt$varNull[2])
# The ICC estimate (between/between+within) is:
mdlMedicalOut$Qlt$IccNull <-
  (as.numeric(mdlMedicalOut$Qlt$varNull[1]) / (as.numeric(mdlMedicalOut$Qlt$varNull[1]) + as.numeric(mdlMedicalOut$Qlt$varNull[2])))
mdlMedicalOut$Qlt$IccPercNull <-
  ((as.numeric(mdlMedicalOut$Qlt$varNull[1]) / (as.numeric(mdlMedicalOut$Qlt$varNull[1]) + as.numeric(mdlMedicalOut$Qlt$varNull[2])))) * 100
```

```{r medicalModelAttNullInt, include=FALSE}
# Create and save Model
mdlMedical$lmerAttNullInt <-
  lme4::lmer(AttitudesDutch ~ 1 + (1 | PID),
             data = dtMedical$full %>%
               filter(complete.cases(
                 OutgroupInteraction
               ))) # use optim if it does not converge

mdlMedical$lmeAttNullInt <-
  lme(
    AttitudesDutch ~ 1,
    random = ~ 1 | PID,
    data = dtMedical$full %>%
      filter(complete.cases(
        OutgroupInteraction
      )),
    na.action = na.omit,
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# Get summary with p-values (Satterthwaite's method)
# summary(mdlMedical$lmerAttNull) #or with the lme function
summ(mdlMedical$lmerAttNullInt, digits = 3)
```

```{r medicalModelInterceptAttCoreInt, include=FALSE}
# Create and save Model
mdlMedical$lmeInterceptAttCoreInt <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc * OutgroupInteraction,
    random =  ~ 1 | PID,
    na.action = na.omit,
    data = dtMedical$full
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedical$lmerInterceptAttCoreInt <- lmer(
    AttitudesDutch ~ KeyNeedFulfillment_cwc * OutgroupInteraction + (1 | PID),
    data = dtMedical$full
  ),
  confint = TRUE,
  digits = 3
)

mdlMedical$lmerInterceptAttCoreIntCI <- 
  confint(method = "Wald", mdlMedical$lmerInterceptAttCoreInt)

# Compare new model to previous step
anova(mdlMedical$lmeAttNullInt, 
      mdlMedical$lmeInterceptAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedical$varInterceptAttCoreInt <- 
  lme4::VarCorr(mdlMedical$lmeInterceptAttCoreInt)
```

```{r medicalModelSlopesAttCoreIntX, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedical$lmeSlopesAttCoreInt <- lme(
  AttitudesDutch ~
    KeyNeedFulfillment_cwc * OutgroupInteraction,
  random = ~ 1 + KeyNeedFulfillment_cwc + OutgroupInteraction | PID,
  control = lmeControl(opt = "optim"),
  na.action = na.omit,
  data = dtMedical$full
)

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedical$lmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc * OutgroupInteraction +
      (1 + KeyNeedFulfillment_cwc + OutgroupInteraction | PID),
    data = dtMedical$full
  ), 
  confint = TRUE,
  digits = 3
)

mdlMedical$lmerSlopesAttCoreIntCI <- 
  confint(method = "Wald", mdlMedical$lmerSlopesAttCoreInt)

# Compare new model to previous step
anova(mdlMedical$lmeAttNullInt, 
      mdlMedical$lmeInterceptAttCoreInt,
      mdlMedical$lmeSlopesAttCoreInt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  add_rownames(., var = "Description") %>%
  mutate(Description = gsub(".*\\$", "", Description)) %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedical$varSlopesAttCoreInt <- 
  lme4::VarCorr(mdlMedical$lmeSlopesAttCoreInt)

# Assumption Checks:
mdlMedical$diagSlopesAttCoreInt <-
  sjPlot::plot_model(mdlMedical$lmerSlopesAttCoreInt, type = "diag")
grid.arrange(
  mdlMedical$diagSlopesAttCoreInt[[1]],
  mdlMedical$diagSlopesAttCoreInt[[2]]$`PID`,
  mdlMedical$diagSlopesAttCoreInt[[3]],
  mdlMedical$diagSlopesAttCoreInt[[4]]
)

# Plot prediction model
mdlMedical$predSlopesAttCoreInt <- 
  dtMedical$full %>%
  filter(complete.cases(KeyNeedFulfillment, OutgroupInteraction)) %>%
  filter(PID %in% dtMedicalSupp$medicalPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID) %>% 
  mutate(measure = predict(mdlMedical$lmeSlopesAttCoreInt,
                           dtMedical$full %>% 
                             filter(complete.cases(KeyNeedFulfillment, OutgroupInteraction)) %>%
                             filter(PID %in% dtMedicalSupp$medicalPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedical$predPltSlopesAttCoreInt <-
    ggplot(data = mdlMedical$predSlopesAttCoreInt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap(~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/Medical_PredictionPlot_SlopesAttCoreInt.png",
  mdlMedical$predPltSlopesAttCoreInt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)
```

As with the previous two studies, we checked for alternative models of the key need fulfillment. First, when considering generalized situational core need fulfillment together with whether an intergroup contact took place, we find that there is no significant main effect of core need fulfillment (random slopes model; `r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "KeyNeedFulfillment_cwc")`) but a stronger interaction effect of core need fulfillment and outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "KeyNeedFulfillment_cwc:OutgroupInteractionYes")`). Together with a significant main effect of having an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedical$lmeSlopesAttCoreInt, lmerCI = mdlMedical$lmerSlopesAttCoreIntCI, varName = "OutgroupInteractionYes")`), this indicates that it is not key need fulfillment in general --- but key need fulfillment during an outgroup contact that predicts more positive outgroup attitudes. This finding is consistent with the results of the previous studies.

```{r medicalOutModelInterceptAttCoreSdt, include=FALSE}
# Create and save Model
mdlMedicalOut$Att$lmeInterceptCoreSdt <-
  lme(
    AttitudesDutch ~ KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method)
summ(
  mdlMedicalOut$Att$lmerInterceptCoreSdt <- lmer(
    AttitudesDutch ~ KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# To be compared against a model with only the self-determination theory needs
mdlMedicalOut$Att$lmeInterceptSdt <-
  lme(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 | PID,
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

summ(
  mdlMedicalOut$Att$lmerInterceptSdt <- lmer(
    AttitudesDutch ~ Competence_cwc + Autonomy_cwc + Relatedness_cwc + (1 | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous steps
anova(
  mdlMedicalOut$Att$lmeInterceptSdt,
  mdlMedicalOut$Att$lmeInterceptCoreSdt
  ) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# Save variances
mdlMedicalOut$Att$varInterceptCoreSdt <-
  lme4::VarCorr(mdlMedicalOut$Att$lmeInterceptCoreSdt)
```

```{r medicalOutModelSlopesAttCoreSdt, include=FALSE}
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesCoreSdt <-
  lme(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + KeyNeedFulfillment_cwc + Competence_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim", maxIter = 100, msMaxIter = 100),
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + KeyNeedFulfillment_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

mdlMedicalOut$Att$lmerSlopesCoreSdtCI <- 
  confint(method = "Wald", mdlMedicalOut$Att$lmerSlopesCoreSdt)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeInterceptSdt,
      mdlMedicalOut$Att$lmeInterceptCoreSdt, 
      mdlMedicalOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")

# model with SDT only
# Create and save Model (optimizer needed to reach convergence)
mdlMedicalOut$Att$lmeSlopesSdt <-
  lme(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc,
    random = ~ 1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID,
    control = lmeControl(opt = "optim"),
    data = dtMedicalSupp$medicalOutWithinBetween,
    na.action = na.exclude
  )

# Get summary with p-values (Satterthwaite's method) [+ save model for plotting]
summ(
  mdlMedicalOut$Att$lmerSlopesSdt <- lmer(
    AttitudesDutch ~
      Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = dtMedicalSupp$medicalOutWithinBetween
  ),
  confint = TRUE,
  digits = 3
)

# Compare new model to previous step
anova(mdlMedicalOut$Att$lmeInterceptSdt,
      mdlMedicalOut$Att$lmeSlopesSdt, 
      mdlMedicalOut$Att$lmeSlopesCoreSdt) %>%
  as.data.frame() %>%
  select(-call) %>%
  mutate(
    L.Ratio = round(L.Ratio, 3),
    `p-value` = ifelse(`p-value`>=.001, round(`p-value`, 3), "< .001")
  ) %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Medical: Model Comparison",
    format = "latex",
    linesep = "",
    booktabs = T,
    align = rep("c", ncol(.)),
    digits = 3
  ) %>%
  kable_styling(position = "left")


# Save variances
mdlMedicalOut$Att$varSlopesCoreSdt <- 
  lme4::VarCorr(mdlMedicalOut$Att$lmeSlopesCoreSdt)

# Assumption Checks:
mdlMedicalOut$Att$diagSlopesCoreSdt <- 
  sjPlot::plot_model(mdlMedicalOut$Att$lmerSlopesCoreSdt, type = "diag")
grid.arrange(
  mdlMedicalOut$Att$diagSlopesCoreSdt[[1]],
  mdlMedicalOut$Att$diagSlopesCoreSdt[[2]]$`PID`,
  mdlMedicalOut$Att$diagSlopesCoreSdt[[3]],
  mdlMedicalOut$Att$diagSlopesCoreSdt[[4]]
)

# Plot prediction model
mdlMedicalOut$Att$predSlopesCoreSdt <- 
  dtMedicalSupp$medicalOutWithinBetween %>%
  filter(complete.cases(
    KeyNeedFulfillment,
    Autonomy, Competence, Relatedness
    )) %>%
  filter(PID %in% dtMedicalSupp$medicalOutPltIDs) %>%
  select(AttitudesDutch, TIDnum, PID, Autonomy, Competence, Relatedness) %>% 
  mutate(measure = predict(mdlMedicalOut$Att$lmeSlopesCoreSdt,
                           dtMedicalSupp$medicalOutWithinBetween %>% 
                             filter(complete.cases(
                               KeyNeedFulfillment,
                               Autonomy, Competence, Relatedness
                             )) %>%
                             filter(PID %in% dtMedicalSupp$medicalOutPltIDs),
                           re.form = NA
                           )
         )

(
  mdlMedicalOut$Att$predPltSlopesCoreSdt <-
    ggplot(data = mdlMedicalOut$Att$predSlopesCoreSdt, aes(x = TIDnum, y = measure)) +
    geom_line(alpha = 1, color = "blue") +
    geom_line(aes(y = AttitudesDutch), alpha = 1) +
    facet_wrap( ~ PID, ncol = 6) +
    xlab("Time") +
    ylab("Outgroup Attitudes") +
    theme_Publication()
)
ggsave(
  filename = "Figures/MedicalOut_PredictionPlot_SlopesAttCoreStd.png",
  mdlMedicalOut$Att$predPltSlopesCoreSdt,
  width = 18,
  height = 12,
  dpi = 800,
  units = "cm",
  device = "png"
)

# Model comparison
medicalSdtComp <-
  anova(
    mdlMedicalOut$Att$lmerSlopesSdt, 
    mdlMedicalOut$Att$lmerSlopesCoreSdt
  ) %>%
  as.data.frame()
medicalSdtCompDf <- medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Df"]
medicalSdtCompN <- sapply(ranef(mdlMedicalOut$Att$lmerSlopesCoreSdt), nrow)
medicalSdtCompChi <- medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Chisq"] %>% round(2) %>% format(nsmall=2)
medicalSdtCompP <-
  ifelse(medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] < .001,
         "< .001",
         paste0("= ", medicalSdtComp["mdlMedicalOut$Att$lmerSlopesCoreSdt", "Pr(>Chisq)"] %>% round(3) %>% format(nsmall = 3)))

medicalSdtCompChiSq <- paste0("$\\chi^2$(", medicalSdtCompDf, ", \\textit{N} = ", medicalSdtCompN, ") = ", medicalSdtCompChi, ", \\textit{p} ", medicalSdtCompP)
```

In a final step, we again checked whether during the interaction the core situational need remains a meaningful predictor even when taking other fundamental psychological needs into account. We find that the core need fulfillment adds additional variance above a model with only the self-determination theory needs (random slopes models; `r medicalSdtCompChiSq`). We find that the core need explains the most variance in outgroup attitudes after an outgroup contact (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "KeyNeedFulfillment_cwc")`). When compared to the model with only the SDT needs, the core need fulfillment flexibly takes on some of the explained variance of all of the three fundamental needs. However, similar to the previous study, in this large sample relatedness (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Relatedness_cwc")`), competence (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Competence_cwc")`) and autonomy (`r MlCoeffLatex(lmeMdl = mdlMedicalOut$Att$lmeSlopesCoreSdt, lmerCI = mdlMedicalOut$Att$lmerSlopesCoreSdtCI, varName = "Autonomy_cwc")`) each also predicted positive outgroup attitudes independently. This being said, the regression coefficient for the core need was three times larger (with all scaling being equal). For full results see Table \ref{tab:robustnessTblLong} and Figure \ref{fig:Robustness} as well as Online Supplementary Material A. Across all three studies, psychological need fulfillment, thus, remained a robust and flexible predictor of positive outgroup attitudes.


```{r robustnessTblLong, include=FALSE}
# Table of all robustness checks (w/ and w/out SDT only)

# Full Sample
# Study 1:
robustTblWorkerFull <- 
  dtWorkerSupp$workerWithinBetween %>%
  select(
    AttitudesDutch = thermometerDutch_1,
    AttitudesDutch_zwc = thermometerDutch_1_zwc,
    CoreNeed_cwc = keyMotiveFulfilled_cwc,
    CoreNeed_zwc = keyMotiveFulfilled_zwc,
    OutgroupInteraction = OutgroupInteraction,
    OutgroupInteraction_zwc = OutgroupInteraction_zwc,
    PID = PID
  )
mdlWorkerLmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc * OutgroupInteraction +
      (1 + CoreNeed_cwc + OutgroupInteraction | PID),
    data = robustTblWorkerFull
  )
mdlWorkerLmerSlopesAttCoreIntZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc * OutgroupInteraction_zwc +
      (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID),
    data = robustTblWorkerFull
  )
#Study 2:
robustTblStudentFull <- 
  dtStudentSupp$studentWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFullfillment_cwc,
    CoreNeed_zwc = KeyNeedFullfillment_zwc,
    OutgroupInteraction = OutgroupInteraction,
    OutgroupInteraction_zwc = OutgroupInteraction_zwc, 
    PID = PID
  )
mdlStudentLmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc * OutgroupInteraction +
      (1 + CoreNeed_cwc + OutgroupInteraction | PID),
    data = robustTblStudentFull
  )
mdlStudentLmerSlopesAttCoreIntZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc * OutgroupInteraction_zwc +
      (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID),
    data = robustTblStudentFull
  )
#Study 3:
robustTblMedicalFull <- 
  dtMedicalSupp$medicalWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFulfillment_cwc,
    CoreNeed_zwc = KeyNeedFulfillment_zwc,
    OutgroupInteraction = OutgroupInteraction,
    OutgroupInteraction_zwc = OutgroupInteraction_zwc, 
    PID = PID
  )
mdlMedicalLmerSlopesAttCoreInt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc * OutgroupInteraction +
      (1 + CoreNeed_cwc + OutgroupInteraction | PID),
    #data = dtMedical$full
    data = robustTblMedicalFull
  )
mdlMedicalLmerSlopesAttCoreIntZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc * OutgroupInteraction_zwc +
      (1 + CoreNeed_zwc + OutgroupInteraction_zwc | PID),
    #data = dtMedical$full
    data = robustTblMedicalFull
  )

# SDT
# Study 1:
robustTblWorkerOut <- 
  dtWorkerSupp$workerOutWithinBetween %>%
  select(
    AttitudesDutch = thermometerDutch_1,
    AttitudesDutch_zwc = thermometerDutch_1_zwc,
    CoreNeed_cwc = keymotive_fulfillemt_1_cwc,
    CoreNeed_zwc = keymotive_fulfillemt_1_zwc,
    Competence_cwc = competence_1_cwc,
    Competence_zwc = competence_1_zwc,
    Autonomy_cwc = autonomy_1_cwc,
    Autonomy_zwc = autonomy_1_zwc,
    Relatedness_cwc = relatedness_1_cwc,
    Relatedness_zwc = relatedness_1_zwc,
    PID = PID
  )
mdlWorkerOutLmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = robustTblWorkerOut
  )
mdlWorkerOutLmerSlopesCoreSdtZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc +
      (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID),
    data = robustTblWorkerOut
  )
# Study 2:
robustTblStudentOut <- 
  dtStudentSupp$studentOutWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFullfillment_cwc,
    CoreNeed_zwc = KeyNeedFullfillment_zwc,
    Competence_cwc = Competence_cwc,
    Competence_zwc = Competence_zwc,
    Autonomy_cwc = Autonomy_cwc,
    Autonomy_zwc = Autonomy_zwc,
    Relatedness_cwc = Relatedness_cwc,
    Relatedness_zwc = Relatedness_zwc,
    PID = PID
  )
mdlStudentOutLmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = robustTblStudentOut
  )
mdlStudentOutLmerSlopesCoreSdtZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc +
      (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID),
    data = robustTblStudentOut
  )
# Study 3:
robustTblMedicalOut <- 
  dtMedicalSupp$medicalOutWithinBetween %>%
  select(
    AttitudesDutch = AttitudesDutch,
    AttitudesDutch_zwc = AttitudesDutch_zwc,
    CoreNeed_cwc = KeyNeedFulfillment_cwc,
    CoreNeed_zwc = KeyNeedFulfillment_zwc,
    Competence_cwc = Competence_cwc,
    Competence_zwc = Competence_zwc,
    Autonomy_cwc = Autonomy_cwc,
    Autonomy_zwc = Autonomy_zwc,
    Relatedness_cwc = Relatedness_cwc,
    Relatedness_zwc = Relatedness_zwc,
    PID = PID
  )
mdlMedicalOutLmerSlopesCoreSdt <- lmer(
    AttitudesDutch ~
      CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc +
      (1 + CoreNeed_cwc + Competence_cwc + Autonomy_cwc + Relatedness_cwc | PID),
    data = robustTblMedicalOut
  )
mdlMedicalOutLmerSlopesCoreSdtZ <- lmer(
    AttitudesDutch_zwc ~
      CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc +
      (1 + CoreNeed_zwc + Competence_zwc + Autonomy_zwc + Relatedness_zwc | PID),
    data = robustTblMedicalOut
  )

# collect models for table
mdlRobustTblElements <- list(
  # full
  c(mdlWorkerLmerSlopesAttCoreInt, mdlWorkerLmerSlopesAttCoreIntZ),
  c(mdlStudentLmerSlopesAttCoreInt, mdlStudentLmerSlopesAttCoreIntZ),
  c(mdlMedicalLmerSlopesAttCoreInt, mdlMedicalLmerSlopesAttCoreIntZ),
  # outgroup
  c(mdlWorkerOutLmerSlopesCoreSdt, mdlWorkerOutLmerSlopesCoreSdtZ),
  c(mdlStudentOutLmerSlopesCoreSdt, mdlStudentOutLmerSlopesCoreSdtZ),
  c(mdlMedicalOutLmerSlopesCoreSdt, mdlMedicalOutLmerSlopesCoreSdtZ)
  )

mdlRobustPrep <- list()
for (i in 1:length(mdlRobustTblElements)) {
  mdlRobustPrep[[i]] <- lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])
}

# manual assembly
shortRobustPrep <- list()
for(i in 1:length(mdlRobustPrep)){
  study <- str_extract(mdlRobustPrep[[i]]$fit$data, "Worker|Student|Medical")
  sample <- str_extract(mdlRobustPrep[[i]]$fit$data, "Full|Out")
  #dv <- sub(" ~.*", "", mdlRobustPrep[[i]]$fit$formula)
  #pred <- gsub("\\(Intercept\\)", "", paste(mdlRobustPrep[[i]]$coeficients$coef, collapse = ''))
  
  name <- paste(study, sample, sep='.')
  tmp <- rbind(
    mdlRobustPrep[[i]]$coeficients[, c("coef", "B", "Beta")],
    data.frame(
      coef = "R2Marg_R2Cond",
      B = mdlRobustPrep[[i]]$fit$R2Marg_R2Cond,
      Beta = ""
    )
  )
  shortRobustPrep[[name]] <- tmp
}


tmp <- shortRobustPrep[grepl("Full", names(shortRobustPrep))]
fullRobustTbl <- data.frame(coef = shortRobustPrep$Medical.Full$coef)
for (i in 1:length(tmp)){
  fullRobustTbl <- join(fullRobustTbl, tmp[[i]], by = "coef")
}

tmp <- shortRobustPrep[grepl("Out", names(shortRobustPrep))]
outRobustTbl <- data.frame(coef = shortRobustPrep$Medical.Out$coef)
for (i in 1:length(tmp)){
  outRobustTbl <- join(outRobustTbl, tmp[[i]], by = "coef")
}

robustTblLong <- rbind(
  fullRobustTbl,
  outRobustTbl
)

robustTblLong$coef <- mapvalues(
  robustTblLong$coef,
  from = c(
    "R2Marg_R2Cond"
  ),
  to = c(
    "$R^2_{marginal}$ / $R^2_{conditional}$"
  )
)

mdlTblRobustLong <- robustTblLong %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    #format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.)-1)),
    escape = FALSE
  ) %>%
  kable_classic() %>%
  add_header_above(., c(" ", "Study 1" = 2, "Study 2" = 2, "Study 3" = 2)) %>%
  pack_rows("Contact [Full Sample]", 1, 5) %>%
  pack_rows("Self-Determination Theory [Outgroup Interactions only]", 6, 11) %>%
  kableExtra::footnote(
    .,
    general = c("**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"), 
    escape = FALSE
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  #kableExtra::landscape() %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/mdlRobustlong.tex")
```

```{r robustnessTblWide, include=FALSE}
# Wide format
mdlRobustTbl <- data.frame(
  coef = c(
    sapply(mdlRobustPrep, function(x) x[1]$coeficients$coef) %>% unlist %>% unique,
    names(mdlRobustPrep[[1]]$random),
    names(mdlRobustPrep[[1]]$fit)
  )
)
for (i in 1:length(mdlRobustPrep)){
  mdlRobustTbl <- join(mdlRobustTbl, mdlRobustPrep[[i]]$mdlTbl, by = "coef")
  #mdlTbl <- merge(mdlRobustTbl, mdlRobustPrep[[i]]$mdlTbl, by = "coef", all = TRUE, sort = FALSE, no.dups = TRUE, suffixes=c("", ""))
}

mdlRobustTblHeader <- data.frame(
  data = as.character(mdlRobustTbl[mdlRobustTbl$coef == "data",]),
  formula = as.character(mdlRobustTbl[mdlRobustTbl$coef == "formula",])
) %>%
  filter(data != "",
         data != "data") %>%
  mutate(study = str_extract(data, "Worker|Student|Medical")) %>%
  mutate(study = gsub("Worker", "Study 1", study)) %>%
  mutate(study = gsub("Student", "Study 2", study)) %>%
  mutate(study = gsub("Medical", "Study 3", study)) %>%
  mutate(dv = sub(" ~.*", "", formula)) %>%
  mutate(dv = gsub("Raw", " ", dv)) %>%
  mutate(pred = str_extract(formula, "CoreNeed|Allport")) %>%
  mutate(header = paste(study, pred, sep = " - "))

mdlRobustTblHeaderFreq <- rbind.data.frame(rle(mdlRobustTblHeader$header)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)

mdlRobustTblHeaderDv <- data.frame(names = mdlRobustTblHeader$dv, span = 2) %>% 
  mutate(names = as.character(names)) %>%
  rbind(c("", 1), .) %>%
  mutate(span = as.numeric(span))

mdlRobustTblHeaderStudy <- rbind.data.frame(rle(mdlRobustTblHeader$study)) %>%
  mutate(lengths = lengths*2) %>%
  rename(names = values, span = lengths) %>%
  rbind(c(1, ""), .) %>%
  mutate(span = as.numeric(span)) %>%
  select(names, span)

mdlRobustTbl$coef <- mapvalues(
  mdlRobustTbl$coef,
  from = c(
    "sigmaSq",
    "tau00",
    "tau11",
    "rho01",
    "rho00",
    "R2_marginal",
    "R2_conditional", 
    "R2Marg_R2Cond"
  ),
  to = c(
    "$\\sigma^2$",
    "$\\tau_{00}$",
    "$\\tau_{11}$",
    "$\\rho_{01}$",
    "$\\rho_{00}$",
    "$R^2_{marginal}$",
    "$R^2_{conditional}$",
    "$R^2_{marginal}$ / $R^2_{conditional}$"
  )
)

# Long Table
mdlTblRobustLong <- mdlRobustTbl %>%
  replace(is.na(.), "") %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    #format = "latex",
    linesep = "",
    booktabs = T,
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  ) %>%
  kable_classic() %>%
  add_header_above(., mdlRobustTblHeaderStudy) %>%
  add_header_above(
    .,
    c(
      "",
      "Contact [Full Sample]" = 6,
      "Self-Determination Theory [Outgroup Interactions only]" = 6
    )
  ) %>%
  pack_rows("Fixed", 1, 7) %>%
  pack_rows("Random", 8, 12) %>%
  pack_rows("Fit", 13, 25) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    ),
    escape = FALSE
  ) %>%
  gsub("_cwc", "", ., fixed = TRUE) 

# shortened Table
mdlTblRobustShort <- mdlRobustTbl %>%
  replace(is.na(.), "")
names(mdlTblRobustShort) <- make.unique(names(mdlTblRobustShort))
mdlTblRobustShort <- mdlTblRobustShort %>%
  filter(
    !coef %in% c(
      "data",
      "formula",
      "groupId",
      "$R^2_{marginal}$",
      "$R^2_{conditional}$",
      "logLik",
      "deviance"
    )
  ) %>%
  mutate_all(linebreak) %>%
  kbl(
    .,
    caption = "Robustness Analyses",
    format = "latex",
    linesep = "",
    booktabs = TRUE,
    col.names = c("", rep(c("$B$", "$\\beta$"), (ncol(.)-1)/2)),
    align = c("l", rep("c", ncol(.) - 1)),
    escape = FALSE,
    digits = 3
  )  %>%
  kable_classic() %>%
  add_header_above(., mdlRobustTblHeaderStudy) %>%
  add_header_above(
    .,
    c(
      "",
      "Contact [Full Sample]" = 6,
      "Self-Determination Theory [Outgroup Interactions only]" = 6
    )
  ) %>%
  pack_rows("Fixed", 1, 7) %>%
  pack_rows("Random", 8, 12) %>%
  pack_rows("Fit", 13, 18) %>%
  footnote(
    general = c("PID = Participant ID number (grouping variable)",
                "$\\sigma^2$: residual variance, $\\tau_{00}$: random intercept variance, $\\tau_{11}$: random slope variance(s), $\\rho_{01}$: random slope-intercept correlation(s) , $\\rho_{00}$: correlation(s) between random slopes",
                "**** $p$ < .0001, *** $p$ < .001, ** $p$ < .01, * $p$ < .05"
    ), 
    escape = FALSE
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  kableExtra::landscape() %>%
  gsub("_cwc", "", ., fixed = TRUE)  %>%
  gsub("\\makecell[l]", "\\makecell[c]", ., fixed = TRUE) %>%
  gsub("\\makecell[r]", "\\makecell[c]", ., fixed = TRUE) %>%
  gsub("objVar$", "", ., fixed = TRUE) %>%
  gsub("slope_intercept.", "slope.intercept", ., fixed = TRUE) %>%
  gsub("\\begin{table}", "\\begin{table}\n\\begin{minipage}[t][\\textheight][t]{\\textwidth}", ., fixed = TRUE) %>% # fix table position
  gsub("\\end{table}", "\\end{minipage}\n\\end{table}", ., fixed = TRUE) %>% # fix table position
  save_kable("Tables/mdlRobustness.tex")
mdlTblRobustShort
```

<!-- FIGURES: -->

```{r metaRobust, include=FALSE}
mdlRobustTblElements <- list(
  # full
  c(mdlWorkerLmerSlopesAttCoreInt, mdlWorkerLmerSlopesAttCoreIntZ),
  c(mdlStudentLmerSlopesAttCoreInt, mdlStudentLmerSlopesAttCoreIntZ),
  c(mdlMedicalLmerSlopesAttCoreInt, mdlMedicalLmerSlopesAttCoreIntZ),
  # outgroup
  c(mdlWorkerOutLmerSlopesCoreSdt, mdlWorkerOutLmerSlopesCoreSdtZ),
  c(mdlStudentOutLmerSlopesCoreSdt, mdlStudentOutLmerSlopesCoreSdtZ),
  c(mdlMedicalOutLmerSlopesCoreSdt, mdlMedicalOutLmerSlopesCoreSdtZ)
  )

# i =1
robustMetaTbl <- data.frame()
for (i in 1:length(mdlRobustTblElements)){
  lmerTblTmp <- lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$beta %>%
  select(
    coef,
    B = est,
    se,
    lwr,
    upr,
    tval,
    Rsq
  ) %>%
  mutate(
    n = lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$N,
    m = nrow(.), 
    #dv = gsub("Dutch", "", str_extract(lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$formula,".+?(?= ~)")),
    sample = str_match(lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$data, "Tbl(.*?)(Full|Out)")[2],
    formula = lmerTblPrep(mdlRobustTblElements[[i]][[1]], mdlRobustTblElements[[i]][[2]])$fit$formula,
    coef = gsub(":", ".", coef)
  )
  robustMetaTbl <- rbind(robustMetaTbl, lmerTblTmp)
}

robustMetaTbl <- robustMetaTbl %>%
  arrange(formula, match(
    coef,
    c(
      "CoreNeed_zwc",
      "OutgroupInteraction_zwc",
      "CoreNeed_zwc.OutgroupInteraction_zwc",
      "Autonomy_zwc",
      "Competence_zwc",
      "Relatedness_zwc"
    )
  )) %>% 
  mutate(formula = gsub(" \\+ \\(.*", "", formula))

robustMetaContact <-
  metaLmerOut(
    lmerDataTbl = robustMetaTbl %>% filter(formula == "AttitudesDutch ~ CoreNeed_cwc * OutgroupInteraction"),
    type = "REML", #"FE", 
    name = "RobustContact",
    title = "Robustness — Contact and Need Fulfillment"
  )

robustMetaSDT <-
  metaLmerOut(
    lmerDataTbl = robustMetaTbl %>% filter(formula == "AttitudesDutch ~ CoreNeed_cwc + Competence_cwc + Autonomy_cwc +      Relatedness_cwc"),
    type = "REML", #"FE", 
    name = "RobustSDT",
    title = "Robustness — Other Needs"
  )
```

```{r robustForestPltComb, include=FALSE}
effRobust <- rbind(
  robustMetaContact$eff %>%
    filter(coef != "(Intercept)") %>%
    mutate(analysis = "(A) Attitude ~ Contact and Need Fulfillment",
           metaId = paste(coef, analysis, sep = ".")) %>%
    as.data.frame,
  robustMetaSDT$eff %>%
    mutate(analysis = "(B) Attitude ~ Other Needs",
           metaId = paste(coef, analysis, sep = ".")) %>%
    as.data.frame
)

metaSubForest(effRobust, 
              title = "Meta Analysis: Forest Plot Robustness Analysis \n[Parametric]",
              filename = "RobustnessComb",
              addAbove = 5,
              width = 600,
              height = 800)
```
